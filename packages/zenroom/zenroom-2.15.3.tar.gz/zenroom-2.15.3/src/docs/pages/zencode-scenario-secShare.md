# Scenario 'secshare': sharing a secret in parts with a quorum


This small scenario contains statements to cryptographically share a secret in parts, and recompose it. The cryptography is based on Lagrange's interpolation and it offers:

 - A configurable amount of shares, the secret has to be split into
 - A configurable *quorum*, so the minimum amount of shares needed to recompose the secret
 
## Applications of secret sharing

This flow is known as "multisig" in the cryptography and the *Bitcoin* world. Some simple use cases are:
 - The secret contains a password to dncrypt a document: the document can be decrypted only if the quorum is reached, so if the minimum decided amount of secret shares are provided 
 - A simple voting system, where 9 people have to vote about eating pizza or not:
  - You have 2 secrets, one is "Yes" one is "No".
  - Both secrets will be shared in 9 parts.
  - Each person receives a secret share of the "Yes" secret and one of the "No" secret.
  - In order to vote, each person communicates their choice by sending either their "Yes" or "No" secret share to the ballot master.
  - The ballot master recomposes the secret shares: if "Yes" is printed out, then there will be pizza. If "No" is printed out, there will be misery and starvation. if a gibberish string comes out, it means that someone hasn't voted, or they tampered with their secret share.
  
 - The pizza example can be applied in a situation with 4 secrets, where each one is a name, who are running for elections where 60 people are voting and the minimum amount of votes (the quorum) can for example be *1/3 + 1*, so 21 votes. In this case, if one of the candidates' names come out, you have a winner. If the output is a gibberish string, the election is void. 


## Share the secret

You'll need a *secret*, so a simple object (string, hex... etc) long no more than 32 bytes, looking like this:

[](../_media/examples/zencode_cookbook/secshare/Secret.json ':include :type=code json')

In order to share the secret you'll have to specify in *how many parts* you want to share it and what the *quorum* is. To do so, execute a Zencode script like this:

[](../_media/examples/zencode_cookbook/secshare/createSharedSecret.zen ':include :type=code gherkin')

This will output you an array contaning the "shared secrets", in an array that we have renamed:

[](../_media/examples/zencode_cookbook/secshare/sharedSecret.json ':include :type=code json')

## Remove shares from the array

In order to test if the whole flow works, we need to remove some shares from the array, we do this in Zencode by removing randomly picked elements:

[](../_media/examples/zencode_cookbook/secshare/removeShares.zen ':include :type=code gherkin')

This will output you an array contaning less "shared secrets", in this case matching the quorum of 5:

[](../_media/examples/zencode_cookbook/secshare/sharedSecret5parts.json ':include :type=code json')


## Recompose the secret

Time to check if the 5 randomly pick elements can get our secret back together, you'll use a script like this:

[](../_media/examples/zencode_cookbook/secshare/composeSecretShares.zen ':include :type=code gherkin')

If successful, you'll see the original secret coming out as output:

[](../_media/examples/zencode_cookbook/secshare/composedSecretShares.json ':include :type=code json')

Please note that Zenroom will output something even if the quorum wasn't met or one (or more) of the shares was broken, so you'll get an output anyway, although it will be different from the original secret.




# The script used to create the material in this page

All the smart contracts and the data you see in this page are generated by the secshare script [secshare.bats](https://github.com/dyne/Zenroom/blob/master/test/zencode/secshare.bats). If you want to run the script (on Linux) you should: 
 - *git clone https://github.com/dyne/Zenroom.git*
 - install **zsh** and **jq**
 - download a [zenroom binary](https://zenroom.org/#downloads) and place it */bin* or */usr/bin* or in *./Zenroom/src*
