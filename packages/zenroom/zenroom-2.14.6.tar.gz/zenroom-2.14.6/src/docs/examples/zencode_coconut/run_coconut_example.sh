#!/usr/bin/env zsh

set -e
set -u
set -o pipefail

# alias zenroom="${1:-../../src/zenroom}"
pfx=.
echo
echo "=========================================="
echo "= COCONUT INTEGRATION TESTS - CREDENTIALS"
echo "=========================================="
echo
echo "###################################"
echo "## ZERO KNOWLEDGE CREDENTIAL"

# _PARTICIPANT-credential-keygen: in this smart contract the participant generates its keypair.
zenroom -z $pfx/credential_keygen.zen | tee keypair.keys

# _PARTICIPANT-credential-request: here the participant produces a "blind signature request", 
# that includes its public key the blind signature request needs to be sent to issuer that will have to sign it.
zenroom -k keypair.keys -z $pfx/create_request.zen | tee request.json

# _ISSUER-keygen: this generates the keypair of the issuer (the issuer is the trusted authority that issue credentials).
zenroom -z $pfx/issuer_keygen.zen | tee issuer_keypair.keys

# _ISSUER-publish-verifier: this produces the "issuer's verifier", 
# a cryptographical object that needs to be produced only once and published (e.g. on a blockchain).
zenroom -k issuer_keypair.keys -z $pfx/publish_verifier.zen | tee verifier.json

# _ISSUER-credential-sign: here the issuer signs the blind signature request produced by the script "create_request.zen",
# the output of this smart contract (signature.json) will be sent back to the participant.
zenroom -k issuer_keypair.keys -a request.json -z $pfx/issuer_sign.zen | tee signature.json

# _PARTICIPANT-aggregate-credential-signature: here the participants aggregagtes the "signature" received from the issuer, produced by 
# the contract "issuer_sign.zen", into a credential. Potentially more signatures (from the same issuer or from different issuers), 
# can be aggregated in one credential.
# Cryptography: this generates sigma (AggCred(σ1, . . . , σt) → (σ):) 
zenroom -k keypair.keys -a signature.json -z $pfx/aggregate_signature.zen | tee credentials.json

# _PARTICIPANT-prove-credential: here the participant creates the "proof", an anonymised version of the credential, 
# that can be generated each time the participant wants to use that credential, without being tracked.
# Cryptography: this generates theta (❖ ProveCred(vk, m, φ0) → (Θ, φ0):
zenroom -k credentials.json -a verifier.json -z $pfx/create_proof.zen | tee proof.json

# _ANYBODY-verify-credential: here anyone can check that the proof (generated by the smart contract "create_proof.zen") is valid, 
# by matching it with the issuer's verifier, produced by the issuer with the smart contract "publish_verifier.zen" and made public,
# in a blockchain, typically this will the actor performing the transaction. 
# Cryptography: returns a boolean VerifyCred(vk, Θ, φ0) 
zenroom -k proof.json -a verifier.json -z $pfx/verify_proof.zen
