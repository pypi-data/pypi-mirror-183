<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>redvox.common.sensor_reader_utils API documentation</title>
<meta name="description" content="This module loads sensor data from Redvox packets" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>redvox.common.sensor_reader_utils</code></h1>
</header>
<section id="section-intro">
<p>This module loads sensor data from Redvox packets</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module loads sensor data from Redvox packets
&#34;&#34;&#34;

from typing import Callable, Dict, List, Optional, Tuple, Union

import numpy as np
# noinspection Mypy
import pyarrow as pa

import redvox.api1000.proto.redvox_api_m_pb2 as api_m
from redvox.common import date_time_utils as dtu
from redvox.common.sensor_data import SensorData, SensorType


# Dataframe column definitions
COMPRESSED_AUDIO_COLUMNS: List[str] = [
    &#34;timestamps&#34;,
    &#34;unaltered_timestamps&#34;,
    &#34;compressed_audio&#34;,
    &#34;audio_codec&#34;,
]

IMAGE_COLUMNS: List[str] = [
    &#34;timestamps&#34;,
    &#34;unaltered_timestamps&#34;,
    &#34;image&#34;,
    &#34;image_codec&#34;,
]

LOCATION_COLUMNS: List[str] = [
    &#34;timestamps&#34;,
    &#34;unaltered_timestamps&#34;,
    &#34;gps_timestamps&#34;,
    &#34;latitude&#34;,
    &#34;longitude&#34;,
    &#34;altitude&#34;,
    &#34;speed&#34;,
    &#34;bearing&#34;,
    &#34;horizontal_accuracy&#34;,
    &#34;vertical_accuracy&#34;,
    &#34;speed_accuracy&#34;,
    &#34;bearing_accuracy&#34;,
    &#34;location_provider&#34;,
]

STATION_HEALTH_COLUMNS: List[str] = [
    &#34;timestamps&#34;,
    &#34;unaltered_timestamps&#34;,
    &#34;battery_charge_remaining&#34;,
    &#34;battery_current_strength&#34;,
    &#34;internal_temp_c&#34;,
    &#34;network_type&#34;,
    &#34;network_strength&#34;,
    &#34;power_state&#34;,
    &#34;avail_ram&#34;,
    &#34;avail_disk&#34;,
    &#34;cell_service&#34;,
    &#34;cpu_utilization&#34;,
    &#34;wifi_wake_lock&#34;,
    &#34;screen_state&#34;,
    &#34;screen_brightness&#34;,
]

# These are used for checking if a field is present or not
__ACCELEROMETER_FIELD_NAME: str = &#34;accelerometer&#34;
__AMBIENT_TEMPERATURE_FIELD_NAME: str = &#34;ambient_temperature&#34;
__AUDIO_FIELD_NAME: str = &#34;audio&#34;
__COMPRESSED_AUDIO_FIELD_NAME: str = &#34;compressed_audio&#34;
__GRAVITY_FIELD_NAME: str = &#34;gravity&#34;
__GYROSCOPE_FIELD_NAME: str = &#34;gyroscope&#34;
__IMAGE_FIELD_NAME: str = &#34;image&#34;
__LIGHT_FIELD_NAME: str = &#34;light&#34;
__LINEAR_ACCELERATION_FIELD_NAME: str = &#34;linear_acceleration&#34;
__LOCATION_FIELD_NAME: str = &#34;location&#34;
__MAGNETOMETER_FIELD_NAME: str = &#34;magnetometer&#34;
__ORIENTATION_FIELD_NAME: str = &#34;orientation&#34;
__PRESSURE_FIELD_NAME: str = &#34;pressure&#34;
__PROXIMITY_FIELD_NAME: str = &#34;proximity&#34;
__RELATIVE_HUMIDITY_FIELD_NAME: str = &#34;relative_humidity&#34;
__ROTATION_VECTOR: str = &#34;rotation_vector&#34;
__VELOCITY: str = &#34;velocity&#34;

__SENSOR_TYPE_TO_FIELD_NAME: Dict[SensorType, str] = {
    SensorType.UNKNOWN_SENSOR: &#34;unknown&#34;,
    SensorType.STATION_HEALTH: &#34;unknown&#34;,
    SensorType.ACCELEROMETER: __ACCELEROMETER_FIELD_NAME,
    SensorType.AMBIENT_TEMPERATURE: __AMBIENT_TEMPERATURE_FIELD_NAME,
    SensorType.AUDIO: __AUDIO_FIELD_NAME,
    SensorType.COMPRESSED_AUDIO: __COMPRESSED_AUDIO_FIELD_NAME,
    SensorType.GRAVITY: __GRAVITY_FIELD_NAME,
    SensorType.GYROSCOPE: __GYROSCOPE_FIELD_NAME,
    SensorType.IMAGE: __IMAGE_FIELD_NAME,
    SensorType.LIGHT: __LIGHT_FIELD_NAME,
    SensorType.LINEAR_ACCELERATION: __LINEAR_ACCELERATION_FIELD_NAME,
    SensorType.LOCATION: __LOCATION_FIELD_NAME,
    SensorType.BEST_LOCATION: __LOCATION_FIELD_NAME,
    SensorType.MAGNETOMETER: __MAGNETOMETER_FIELD_NAME,
    SensorType.ORIENTATION: __ORIENTATION_FIELD_NAME,
    SensorType.PRESSURE: __PRESSURE_FIELD_NAME,
    SensorType.PROXIMITY: __PROXIMITY_FIELD_NAME,
    SensorType.RELATIVE_HUMIDITY: __RELATIVE_HUMIDITY_FIELD_NAME,
    SensorType.ROTATION_VECTOR: __ROTATION_VECTOR,
    SensorType.INFRARED: __PROXIMITY_FIELD_NAME,
}

Sensor = Union[
    api_m.RedvoxPacketM.Sensors.Xyz,
    api_m.RedvoxPacketM.Sensors.Single,
    api_m.RedvoxPacketM.Sensors.Audio,
    api_m.RedvoxPacketM.Sensors.Image,
    api_m.RedvoxPacketM.Sensors.Location,
    api_m.RedvoxPacketM.Sensors.CompressedAudio,
]

# Maps a sensor type to a function that can extract that sensor for a particular packet.
__SENSOR_TYPE_TO_SENSOR_FN: Dict[
    SensorType,
    Optional[
        Callable[
            [api_m.RedvoxPacketM],
            Sensor,
        ]
    ],
] = {
    SensorType.UNKNOWN_SENSOR: None,
    SensorType.STATION_HEALTH: None,
    SensorType.ACCELEROMETER: lambda packet: packet.sensors.accelerometer,
    SensorType.AMBIENT_TEMPERATURE: lambda packet: packet.sensors.ambient_temperature,
    SensorType.AUDIO: lambda packet: packet.sensors.audio,
    SensorType.COMPRESSED_AUDIO: lambda packet: packet.sensors.compressed_audio,
    SensorType.GRAVITY: lambda packet: packet.sensors.gravity,
    SensorType.GYROSCOPE: lambda packet: packet.sensors.gyroscope,
    SensorType.IMAGE: lambda packet: packet.sensors.image,
    SensorType.LIGHT: lambda packet: packet.sensors.light,
    SensorType.LINEAR_ACCELERATION: lambda packet: packet.sensors.linear_acceleration,
    SensorType.LOCATION: lambda packet: packet.sensors.location,
    SensorType.BEST_LOCATION: lambda packet: packet.sensors.location,
    SensorType.MAGNETOMETER: lambda packet: packet.sensors.magnetometer,
    SensorType.ORIENTATION: lambda packet: packet.sensors.orientation,
    SensorType.PRESSURE: lambda packet: packet.sensors.pressure,
    SensorType.PROXIMITY: lambda packet: packet.sensors.proximity,
    SensorType.RELATIVE_HUMIDITY: lambda packet: packet.sensors.relative_humidity,
    SensorType.ROTATION_VECTOR: lambda packet: packet.sensors.rotation_vector,
    SensorType.INFRARED: lambda packet: packet.sensors.proximity,
}


def __has_sensor(
        data: Union[api_m.RedvoxPacketM, api_m.RedvoxPacketM.Sensors], field_name: str
) -&gt; bool:
    &#34;&#34;&#34;
    Returns true if the given packet or sensors instance contains the valid sensor.

    :param data: Either a packet or a packet&#39;s sensors message.
    :param field_name: The name of the sensor being checked.
    :return: True if the sensor exists, False otherwise.
    &#34;&#34;&#34;
    if isinstance(data, api_m.RedvoxPacketM):
        # noinspection Mypy,PyTypeChecker
        return data.sensors.HasField(field_name)

    if isinstance(data, api_m.RedvoxPacketM.Sensors):
        # noinspection Mypy,PyTypeChecker
        return data.HasField(field_name)

    return False


def __packet_duration_s(packet: api_m.RedvoxPacketM) -&gt; float:
    &#34;&#34;&#34;
    Returns the packet duration in seconds.

    :param packet: The packet to calculate the duration for.
    :return: The packet duration in seconds.
    &#34;&#34;&#34;
    return len(packet.sensors.audio.samples.values) / packet.sensors.audio.sample_rate


def __packet_duration_us(packet: api_m.RedvoxPacketM) -&gt; float:
    &#34;&#34;&#34;
    Returns the packet duration in microseconds.

    :param packet: The packet to calculate the duration for.
    :return: The packet duration in microseconds.
    &#34;&#34;&#34;
    return __packet_duration_s(packet) * 1_000_000.0


def __stats_for_sensor_per_packet_per_second(num_packets: int,
                                             packet_dur_s: float,
                                             timestamps: np.array) -&gt; Tuple[float, float, float]:
    &#34;&#34;&#34;
    Sensor being evaluated must either have 1/packet or 1/second sample rate

    :param num_packets: number of packets to calculate stats for
    :param packet_dur_s: duration of packet in seconds
    :param timestamps: timestamps of the samples
    :return: sample rate in hz, sample interval in seconds, and sample interval std deviation
    &#34;&#34;&#34;
    if len(timestamps) != num_packets:
        sample_rate = 1.0
    else:
        sample_rate = 1 / packet_dur_s
    sample_interval = 1 / sample_rate
    sample_interval_std = (
        dtu.microseconds_to_seconds(float(np.std(np.diff(timestamps))))
        if len(timestamps) &gt; 1
        else np.nan
    )
    return sample_rate, sample_interval, sample_interval_std


def get_empty_sensor(
        name: str, sensor_type: SensorType = SensorType.UNKNOWN_SENSOR
) -&gt; SensorData:
    &#34;&#34;&#34;
    create a sensor data object with no data

    :param name: name of the sensor
    :param sensor_type: type of the sensor to create, default SensorType.UNKNOWN_SENSOR
    :return: empty sensor
    &#34;&#34;&#34;
    return SensorData(name, pa.Table.from_pydict({&#34;timestamps&#34;: []}), sensor_type)


def get_sensor_description(sensor: Sensor) -&gt; str:
    &#34;&#34;&#34;
    read the sensor&#39;s description from the sensor

    :param sensor: the sensor to read the description from
    :return: the sensor&#39;s description
    &#34;&#34;&#34;
    return sensor.sensor_description


def get_sample_statistics(data_df: pa.Table) -&gt; Tuple[float, float, float]:
    &#34;&#34;&#34;
    calculate the sample rate, interval and interval std dev using the timestamps in the dataframe

    :param data_df: the dataframe containing timestamps to calculate statistics from
    :return: a Tuple containing the sample rate, interval and interval std dev
    &#34;&#34;&#34;
    sample_interval: float
    sample_interval_std: float
    timestamps: np.array = data_df[&#34;timestamps&#34;].to_numpy()
    if timestamps.size &gt; 1:
        sample_interval = dtu.microseconds_to_seconds(
            float(np.mean(np.diff(timestamps)))
        )
        sample_interval_std = dtu.microseconds_to_seconds(
            float(np.std(np.diff(timestamps)))
        )
    else:
        sample_interval = np.nan
        sample_interval_std = np.nan
    return 1.0 / sample_interval, sample_interval, sample_interval_std


def read_apim_xyz_sensor(
        sensor: api_m.RedvoxPacketM.Sensors.Xyz, column_id: str
) -&gt; pa.Table:
    &#34;&#34;&#34;
    read a sensor that has xyz data channels from an api M data packet
    raises Attribute Error if sensor does not contain xyz channels

    :param sensor: the xyz api M sensor to read
    :param column_id: string, used to name the columns
    :return: dictionary representing the data in the sensor
    &#34;&#34;&#34;
    timestamps: np.ndarray = np.array(sensor.timestamps.timestamps)
    try:
        columns: List[str] = [
            &#34;timestamps&#34;,
            &#34;unaltered_timestamps&#34;,
            f&#34;{column_id}_x&#34;,
            f&#34;{column_id}_y&#34;,
            f&#34;{column_id}_z&#34;,
        ]
        return pa.Table.from_pydict(
            dict(zip(columns, [timestamps,
                               timestamps,
                               np.array(sensor.x_samples.values),
                               np.array(sensor.y_samples.values),
                               np.array(sensor.z_samples.values),
                               ]
                     )
                 )
        )
    except AttributeError:
        raise


def read_apim_single_sensor(
        sensor: api_m.RedvoxPacketM.Sensors.Single, column_id: str
) -&gt; pa.Table:
    &#34;&#34;&#34;
    read a sensor that has a single data channel from an api M data packet
    raises Attribute Error if sensor does not contain exactly one data channel

    :param sensor: the single channel api M sensor to read
    :param column_id: string, used to name the columns
    :return: pyarrow table representing the data in the sensor
    &#34;&#34;&#34;
    timestamps: np.ndarray = np.array(sensor.timestamps.timestamps)
    try:
        columns: List[str] = [&#34;timestamps&#34;, &#34;unaltered_timestamps&#34;, column_id]
        return pa.Table.from_pydict(dict(zip(columns, [timestamps, timestamps, np.array(sensor.samples.values)])))
    except AttributeError:
        raise


def apim_compressed_audio_to_pyarrow(comp_audio: api_m.RedvoxPacketM.Sensors.CompressedAudio) -&gt; pa.Table:
    &#34;&#34;&#34;
    :param comp_audio: compressed audio sensor to convert to pyarrow table
    :return: pyarrow table representation of compressed audio data
    &#34;&#34;&#34;
    return pa.Table.from_pydict(
        dict(zip(COMPRESSED_AUDIO_COLUMNS,
                 [
                     comp_audio.first_sample_timestamp,
                     comp_audio.first_sample_timestamp,
                     np.array(list(comp_audio.audio_bytes)),
                     comp_audio.audio_codec,
                 ]
                 )
             )
    )


def apim_image_to_pyarrow(image_sensor: api_m.RedvoxPacketM.Sensors.Image) -&gt; pa.Table:
    &#34;&#34;&#34;
    :param image_sensor: image sensor to convert to pyarrow table
    :return: pyarrow table representation of image data
    &#34;&#34;&#34;
    timestamps = image_sensor.timestamps.timestamps
    codecs = np.full(len(timestamps), image_sensor.image_codec)
    return pa.Table.from_pydict(
        dict(zip(IMAGE_COLUMNS,
                 [timestamps, timestamps, image_sensor.samples, codecs]
                 )
             )
    )


def apim_best_location_to_pyarrow(best_loc: api_m.RedvoxPacketM.Sensors.Location.BestLocation,
                                  packet_start_timestamp: float) -&gt; pa.Table:
    &#34;&#34;&#34;
    :param best_loc: best location to convert to pyarrow table
    :param packet_start_timestamp: timestamp of packet&#39;s first sample
    :return: pyarrow table representation of best location data
    &#34;&#34;&#34;
    return pa.Table.from_pydict(
        dict(zip(LOCATION_COLUMNS,
                 [
                     [packet_start_timestamp],
                     [best_loc.latitude_longitude_timestamp.mach],
                     [best_loc.latitude_longitude_timestamp.gps],
                     [best_loc.latitude],
                     [best_loc.longitude],
                     [best_loc.altitude],
                     [best_loc.speed],
                     [best_loc.bearing],
                     [best_loc.horizontal_accuracy],
                     [best_loc.vertical_accuracy],
                     [best_loc.speed_accuracy],
                     [best_loc.bearing_accuracy],
                     [best_loc.location_provider],
                 ]
                 )
             )
    )


def apim_location_to_pyarrow(loc: api_m.RedvoxPacketM.Sensors.Location) -&gt; pa.Table:
    &#34;&#34;&#34;
    :param loc: location sensor to convert to pyarrow table
    :return: pyarrow table representation of location data
    &#34;&#34;&#34;
    timestamps = loc.timestamps.timestamps
    gps_timestamps = loc.timestamps_gps.timestamps
    lat_samples = loc.latitude_samples.values
    lon_samples = loc.longitude_samples.values
    alt_samples = loc.altitude_samples.values
    spd_samples = loc.speed_samples.values
    bear_samples = loc.bearing_samples.values
    hor_acc_samples = loc.horizontal_accuracy_samples.values
    vert_acc_samples = loc.vertical_accuracy_samples.values
    spd_acc_samples = loc.speed_accuracy_samples.values
    bear_acc_samples = loc.bearing_accuracy_samples.values
    loc_prov_samples = loc.location_providers
    data_for_df = [[], [], [], [], [], [], [], [], [], [], [], [], []]
    for i in range(len(timestamps)):
        data_for_df[0].append(timestamps[i])
        data_for_df[1].append(timestamps[i])
        data_for_df[2].append(np.nan if len(gps_timestamps) &lt;= i else gps_timestamps[i])
        data_for_df[3].append(lat_samples[i])
        data_for_df[4].append(lon_samples[i])
        data_for_df[5].append(np.nan if len(alt_samples) &lt;= i else alt_samples[i])
        data_for_df[6].append(np.nan if len(spd_samples) &lt;= i else spd_samples[i])
        data_for_df[7].append(np.nan if len(bear_samples) &lt;= i else bear_samples[i])
        data_for_df[8].append(np.nan if len(hor_acc_samples) &lt;= i else hor_acc_samples[i])
        data_for_df[9].append(np.nan if len(vert_acc_samples) &lt;= i else vert_acc_samples[i])
        data_for_df[10].append(np.nan if len(spd_acc_samples) &lt;= i else spd_acc_samples[i])
        data_for_df[11].append(np.nan if len(bear_acc_samples) &lt;= i else bear_acc_samples[i])
        data_for_df[12].append(api_m.RedvoxPacketM.Sensors.Location.LocationProvider.UNKNOWN
                               if len(loc_prov_samples) &lt;= i else loc_prov_samples[i])
    return pa.Table.from_pydict(dict(zip(LOCATION_COLUMNS, data_for_df)))


def apim_health_to_pyarrow(metrics: api_m.RedvoxPacketM.StationInformation.StationMetrics) -&gt; pa.Table:
    &#34;&#34;&#34;
    :param metrics: station metrics to convert to pyarrow table
    :return: pyarrow table representation of station metrics data
    &#34;&#34;&#34;
    timestamps = metrics.timestamps.timestamps
    bat_samples = metrics.battery.values
    bat_cur_samples = metrics.battery_current.values
    temp_samples = metrics.temperature.values
    net_samples = metrics.network_type
    net_str_samples = metrics.network_strength.values
    pow_samples = metrics.power_state
    avail_ram_samples = metrics.available_ram.values
    avail_disk_samples = metrics.available_disk.values
    cell_samples = metrics.cell_service_state
    cpu_util_samples = metrics.cpu_utilization.values
    wake_lock_samples = metrics.wifi_wake_lock
    screen_state_samples = metrics.screen_state
    screen_bright_samples = metrics.screen_brightness.values
    data_for_df = [], [], [], [], [], [], [], [], [], [], [], [], [], [], []
    for i in range(len(timestamps)):
        data_for_df[0].append(timestamps[i])
        data_for_df[1].append(timestamps[i])
        data_for_df[2].append(np.nan if len(bat_samples) &lt; i + 1 else bat_samples[i])
        data_for_df[3].append(np.nan if len(bat_cur_samples) &lt; i + 1 else bat_cur_samples[i])
        data_for_df[4].append(np.nan if len(temp_samples) &lt; i + 1 else temp_samples[i])
        data_for_df[5].append(api_m.RedvoxPacketM.StationInformation.StationMetrics.NetworkType.UNKNOWN_NETWORK
                              if len(net_samples) &lt; i + 1 else net_samples[i])
        data_for_df[6].append(np.nan if len(net_str_samples) &lt; i + 1 else net_str_samples[i])
        data_for_df[7].append(api_m.RedvoxPacketM.StationInformation.StationMetrics.PowerState.UNKNOWN_POWER_STATE
                              if len(pow_samples) &lt; i + 1 else pow_samples[i])
        data_for_df[8].append(np.nan if len(avail_ram_samples) &lt; i + 1 else avail_ram_samples[i])
        data_for_df[9].append(np.nan if len(avail_disk_samples) &lt; i + 1 else avail_disk_samples[i])
        data_for_df[10].append(api_m.RedvoxPacketM.StationInformation.StationMetrics.CellServiceState.UNKNOWN
                               if len(cell_samples) &lt; i + 1 else cell_samples[i])
        data_for_df[11].append(np.nan if len(cpu_util_samples) &lt; i + 1 else cpu_util_samples[i])
        data_for_df[12].append(api_m.RedvoxPacketM.StationInformation.StationMetrics.WifiWakeLock.NONE
                               if len(wake_lock_samples) &lt; i + 1 else wake_lock_samples[i])
        data_for_df[13].append(api_m.RedvoxPacketM.StationInformation.StationMetrics.ScreenState.UNKNOWN_SCREEN_STATE
                               if len(screen_state_samples) &lt; i + 1 else screen_state_samples[i])
        data_for_df[14].append(np.nan if len(screen_bright_samples) &lt; i + 1 else screen_bright_samples[i])
    return pa.Table.from_pydict(dict(zip(STATION_HEALTH_COLUMNS, data_for_df)))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="redvox.common.sensor_reader_utils.apim_best_location_to_pyarrow"><code class="name flex">
<span>def <span class="ident">apim_best_location_to_pyarrow</span></span>(<span>best_loc: src.redvox_api_m.redvox_api_m_pb2.BestLocation, packet_start_timestamp: float) ‑> pyarrow.lib.Table</span>
</code></dt>
<dd>
<div class="desc"><p>:param best_loc: best location to convert to pyarrow table
:param packet_start_timestamp: timestamp of packet's first sample
:return: pyarrow table representation of best location data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apim_best_location_to_pyarrow(best_loc: api_m.RedvoxPacketM.Sensors.Location.BestLocation,
                                  packet_start_timestamp: float) -&gt; pa.Table:
    &#34;&#34;&#34;
    :param best_loc: best location to convert to pyarrow table
    :param packet_start_timestamp: timestamp of packet&#39;s first sample
    :return: pyarrow table representation of best location data
    &#34;&#34;&#34;
    return pa.Table.from_pydict(
        dict(zip(LOCATION_COLUMNS,
                 [
                     [packet_start_timestamp],
                     [best_loc.latitude_longitude_timestamp.mach],
                     [best_loc.latitude_longitude_timestamp.gps],
                     [best_loc.latitude],
                     [best_loc.longitude],
                     [best_loc.altitude],
                     [best_loc.speed],
                     [best_loc.bearing],
                     [best_loc.horizontal_accuracy],
                     [best_loc.vertical_accuracy],
                     [best_loc.speed_accuracy],
                     [best_loc.bearing_accuracy],
                     [best_loc.location_provider],
                 ]
                 )
             )
    )</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.apim_compressed_audio_to_pyarrow"><code class="name flex">
<span>def <span class="ident">apim_compressed_audio_to_pyarrow</span></span>(<span>comp_audio: src.redvox_api_m.redvox_api_m_pb2.CompressedAudio) ‑> pyarrow.lib.Table</span>
</code></dt>
<dd>
<div class="desc"><p>:param comp_audio: compressed audio sensor to convert to pyarrow table
:return: pyarrow table representation of compressed audio data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apim_compressed_audio_to_pyarrow(comp_audio: api_m.RedvoxPacketM.Sensors.CompressedAudio) -&gt; pa.Table:
    &#34;&#34;&#34;
    :param comp_audio: compressed audio sensor to convert to pyarrow table
    :return: pyarrow table representation of compressed audio data
    &#34;&#34;&#34;
    return pa.Table.from_pydict(
        dict(zip(COMPRESSED_AUDIO_COLUMNS,
                 [
                     comp_audio.first_sample_timestamp,
                     comp_audio.first_sample_timestamp,
                     np.array(list(comp_audio.audio_bytes)),
                     comp_audio.audio_codec,
                 ]
                 )
             )
    )</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.apim_health_to_pyarrow"><code class="name flex">
<span>def <span class="ident">apim_health_to_pyarrow</span></span>(<span>metrics: src.redvox_api_m.redvox_api_m_pb2.StationMetrics) ‑> pyarrow.lib.Table</span>
</code></dt>
<dd>
<div class="desc"><p>:param metrics: station metrics to convert to pyarrow table
:return: pyarrow table representation of station metrics data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apim_health_to_pyarrow(metrics: api_m.RedvoxPacketM.StationInformation.StationMetrics) -&gt; pa.Table:
    &#34;&#34;&#34;
    :param metrics: station metrics to convert to pyarrow table
    :return: pyarrow table representation of station metrics data
    &#34;&#34;&#34;
    timestamps = metrics.timestamps.timestamps
    bat_samples = metrics.battery.values
    bat_cur_samples = metrics.battery_current.values
    temp_samples = metrics.temperature.values
    net_samples = metrics.network_type
    net_str_samples = metrics.network_strength.values
    pow_samples = metrics.power_state
    avail_ram_samples = metrics.available_ram.values
    avail_disk_samples = metrics.available_disk.values
    cell_samples = metrics.cell_service_state
    cpu_util_samples = metrics.cpu_utilization.values
    wake_lock_samples = metrics.wifi_wake_lock
    screen_state_samples = metrics.screen_state
    screen_bright_samples = metrics.screen_brightness.values
    data_for_df = [], [], [], [], [], [], [], [], [], [], [], [], [], [], []
    for i in range(len(timestamps)):
        data_for_df[0].append(timestamps[i])
        data_for_df[1].append(timestamps[i])
        data_for_df[2].append(np.nan if len(bat_samples) &lt; i + 1 else bat_samples[i])
        data_for_df[3].append(np.nan if len(bat_cur_samples) &lt; i + 1 else bat_cur_samples[i])
        data_for_df[4].append(np.nan if len(temp_samples) &lt; i + 1 else temp_samples[i])
        data_for_df[5].append(api_m.RedvoxPacketM.StationInformation.StationMetrics.NetworkType.UNKNOWN_NETWORK
                              if len(net_samples) &lt; i + 1 else net_samples[i])
        data_for_df[6].append(np.nan if len(net_str_samples) &lt; i + 1 else net_str_samples[i])
        data_for_df[7].append(api_m.RedvoxPacketM.StationInformation.StationMetrics.PowerState.UNKNOWN_POWER_STATE
                              if len(pow_samples) &lt; i + 1 else pow_samples[i])
        data_for_df[8].append(np.nan if len(avail_ram_samples) &lt; i + 1 else avail_ram_samples[i])
        data_for_df[9].append(np.nan if len(avail_disk_samples) &lt; i + 1 else avail_disk_samples[i])
        data_for_df[10].append(api_m.RedvoxPacketM.StationInformation.StationMetrics.CellServiceState.UNKNOWN
                               if len(cell_samples) &lt; i + 1 else cell_samples[i])
        data_for_df[11].append(np.nan if len(cpu_util_samples) &lt; i + 1 else cpu_util_samples[i])
        data_for_df[12].append(api_m.RedvoxPacketM.StationInformation.StationMetrics.WifiWakeLock.NONE
                               if len(wake_lock_samples) &lt; i + 1 else wake_lock_samples[i])
        data_for_df[13].append(api_m.RedvoxPacketM.StationInformation.StationMetrics.ScreenState.UNKNOWN_SCREEN_STATE
                               if len(screen_state_samples) &lt; i + 1 else screen_state_samples[i])
        data_for_df[14].append(np.nan if len(screen_bright_samples) &lt; i + 1 else screen_bright_samples[i])
    return pa.Table.from_pydict(dict(zip(STATION_HEALTH_COLUMNS, data_for_df)))</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.apim_image_to_pyarrow"><code class="name flex">
<span>def <span class="ident">apim_image_to_pyarrow</span></span>(<span>image_sensor: src.redvox_api_m.redvox_api_m_pb2.Image) ‑> pyarrow.lib.Table</span>
</code></dt>
<dd>
<div class="desc"><p>:param image_sensor: image sensor to convert to pyarrow table
:return: pyarrow table representation of image data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apim_image_to_pyarrow(image_sensor: api_m.RedvoxPacketM.Sensors.Image) -&gt; pa.Table:
    &#34;&#34;&#34;
    :param image_sensor: image sensor to convert to pyarrow table
    :return: pyarrow table representation of image data
    &#34;&#34;&#34;
    timestamps = image_sensor.timestamps.timestamps
    codecs = np.full(len(timestamps), image_sensor.image_codec)
    return pa.Table.from_pydict(
        dict(zip(IMAGE_COLUMNS,
                 [timestamps, timestamps, image_sensor.samples, codecs]
                 )
             )
    )</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.apim_location_to_pyarrow"><code class="name flex">
<span>def <span class="ident">apim_location_to_pyarrow</span></span>(<span>loc: src.redvox_api_m.redvox_api_m_pb2.Location) ‑> pyarrow.lib.Table</span>
</code></dt>
<dd>
<div class="desc"><p>:param loc: location sensor to convert to pyarrow table
:return: pyarrow table representation of location data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apim_location_to_pyarrow(loc: api_m.RedvoxPacketM.Sensors.Location) -&gt; pa.Table:
    &#34;&#34;&#34;
    :param loc: location sensor to convert to pyarrow table
    :return: pyarrow table representation of location data
    &#34;&#34;&#34;
    timestamps = loc.timestamps.timestamps
    gps_timestamps = loc.timestamps_gps.timestamps
    lat_samples = loc.latitude_samples.values
    lon_samples = loc.longitude_samples.values
    alt_samples = loc.altitude_samples.values
    spd_samples = loc.speed_samples.values
    bear_samples = loc.bearing_samples.values
    hor_acc_samples = loc.horizontal_accuracy_samples.values
    vert_acc_samples = loc.vertical_accuracy_samples.values
    spd_acc_samples = loc.speed_accuracy_samples.values
    bear_acc_samples = loc.bearing_accuracy_samples.values
    loc_prov_samples = loc.location_providers
    data_for_df = [[], [], [], [], [], [], [], [], [], [], [], [], []]
    for i in range(len(timestamps)):
        data_for_df[0].append(timestamps[i])
        data_for_df[1].append(timestamps[i])
        data_for_df[2].append(np.nan if len(gps_timestamps) &lt;= i else gps_timestamps[i])
        data_for_df[3].append(lat_samples[i])
        data_for_df[4].append(lon_samples[i])
        data_for_df[5].append(np.nan if len(alt_samples) &lt;= i else alt_samples[i])
        data_for_df[6].append(np.nan if len(spd_samples) &lt;= i else spd_samples[i])
        data_for_df[7].append(np.nan if len(bear_samples) &lt;= i else bear_samples[i])
        data_for_df[8].append(np.nan if len(hor_acc_samples) &lt;= i else hor_acc_samples[i])
        data_for_df[9].append(np.nan if len(vert_acc_samples) &lt;= i else vert_acc_samples[i])
        data_for_df[10].append(np.nan if len(spd_acc_samples) &lt;= i else spd_acc_samples[i])
        data_for_df[11].append(np.nan if len(bear_acc_samples) &lt;= i else bear_acc_samples[i])
        data_for_df[12].append(api_m.RedvoxPacketM.Sensors.Location.LocationProvider.UNKNOWN
                               if len(loc_prov_samples) &lt;= i else loc_prov_samples[i])
    return pa.Table.from_pydict(dict(zip(LOCATION_COLUMNS, data_for_df)))</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.get_empty_sensor"><code class="name flex">
<span>def <span class="ident">get_empty_sensor</span></span>(<span>name: str, sensor_type: <a title="redvox.common.sensor_data.SensorType" href="sensor_data.html#redvox.common.sensor_data.SensorType">SensorType</a> = SensorType.UNKNOWN_SENSOR) ‑> <a title="redvox.common.sensor_data.SensorData" href="sensor_data.html#redvox.common.sensor_data.SensorData">SensorData</a></span>
</code></dt>
<dd>
<div class="desc"><p>create a sensor data object with no data</p>
<p>:param name: name of the sensor
:param sensor_type: type of the sensor to create, default SensorType.UNKNOWN_SENSOR
:return: empty sensor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_empty_sensor(
        name: str, sensor_type: SensorType = SensorType.UNKNOWN_SENSOR
) -&gt; SensorData:
    &#34;&#34;&#34;
    create a sensor data object with no data

    :param name: name of the sensor
    :param sensor_type: type of the sensor to create, default SensorType.UNKNOWN_SENSOR
    :return: empty sensor
    &#34;&#34;&#34;
    return SensorData(name, pa.Table.from_pydict({&#34;timestamps&#34;: []}), sensor_type)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.get_sample_statistics"><code class="name flex">
<span>def <span class="ident">get_sample_statistics</span></span>(<span>data_df: pyarrow.lib.Table) ‑> Tuple[float, float, float]</span>
</code></dt>
<dd>
<div class="desc"><p>calculate the sample rate, interval and interval std dev using the timestamps in the dataframe</p>
<p>:param data_df: the dataframe containing timestamps to calculate statistics from
:return: a Tuple containing the sample rate, interval and interval std dev</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sample_statistics(data_df: pa.Table) -&gt; Tuple[float, float, float]:
    &#34;&#34;&#34;
    calculate the sample rate, interval and interval std dev using the timestamps in the dataframe

    :param data_df: the dataframe containing timestamps to calculate statistics from
    :return: a Tuple containing the sample rate, interval and interval std dev
    &#34;&#34;&#34;
    sample_interval: float
    sample_interval_std: float
    timestamps: np.array = data_df[&#34;timestamps&#34;].to_numpy()
    if timestamps.size &gt; 1:
        sample_interval = dtu.microseconds_to_seconds(
            float(np.mean(np.diff(timestamps)))
        )
        sample_interval_std = dtu.microseconds_to_seconds(
            float(np.std(np.diff(timestamps)))
        )
    else:
        sample_interval = np.nan
        sample_interval_std = np.nan
    return 1.0 / sample_interval, sample_interval, sample_interval_std</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.get_sensor_description"><code class="name flex">
<span>def <span class="ident">get_sensor_description</span></span>(<span>sensor: Union[src.redvox_api_m.redvox_api_m_pb2.Xyz, src.redvox_api_m.redvox_api_m_pb2.Single, src.redvox_api_m.redvox_api_m_pb2.Audio, src.redvox_api_m.redvox_api_m_pb2.Image, src.redvox_api_m.redvox_api_m_pb2.Location, src.redvox_api_m.redvox_api_m_pb2.CompressedAudio]) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>read the sensor's description from the sensor</p>
<p>:param sensor: the sensor to read the description from
:return: the sensor's description</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sensor_description(sensor: Sensor) -&gt; str:
    &#34;&#34;&#34;
    read the sensor&#39;s description from the sensor

    :param sensor: the sensor to read the description from
    :return: the sensor&#39;s description
    &#34;&#34;&#34;
    return sensor.sensor_description</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.read_apim_single_sensor"><code class="name flex">
<span>def <span class="ident">read_apim_single_sensor</span></span>(<span>sensor: src.redvox_api_m.redvox_api_m_pb2.Single, column_id: str) ‑> pyarrow.lib.Table</span>
</code></dt>
<dd>
<div class="desc"><p>read a sensor that has a single data channel from an api M data packet
raises Attribute Error if sensor does not contain exactly one data channel</p>
<p>:param sensor: the single channel api M sensor to read
:param column_id: string, used to name the columns
:return: pyarrow table representing the data in the sensor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_apim_single_sensor(
        sensor: api_m.RedvoxPacketM.Sensors.Single, column_id: str
) -&gt; pa.Table:
    &#34;&#34;&#34;
    read a sensor that has a single data channel from an api M data packet
    raises Attribute Error if sensor does not contain exactly one data channel

    :param sensor: the single channel api M sensor to read
    :param column_id: string, used to name the columns
    :return: pyarrow table representing the data in the sensor
    &#34;&#34;&#34;
    timestamps: np.ndarray = np.array(sensor.timestamps.timestamps)
    try:
        columns: List[str] = [&#34;timestamps&#34;, &#34;unaltered_timestamps&#34;, column_id]
        return pa.Table.from_pydict(dict(zip(columns, [timestamps, timestamps, np.array(sensor.samples.values)])))
    except AttributeError:
        raise</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.read_apim_xyz_sensor"><code class="name flex">
<span>def <span class="ident">read_apim_xyz_sensor</span></span>(<span>sensor: src.redvox_api_m.redvox_api_m_pb2.Xyz, column_id: str) ‑> pyarrow.lib.Table</span>
</code></dt>
<dd>
<div class="desc"><p>read a sensor that has xyz data channels from an api M data packet
raises Attribute Error if sensor does not contain xyz channels</p>
<p>:param sensor: the xyz api M sensor to read
:param column_id: string, used to name the columns
:return: dictionary representing the data in the sensor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_apim_xyz_sensor(
        sensor: api_m.RedvoxPacketM.Sensors.Xyz, column_id: str
) -&gt; pa.Table:
    &#34;&#34;&#34;
    read a sensor that has xyz data channels from an api M data packet
    raises Attribute Error if sensor does not contain xyz channels

    :param sensor: the xyz api M sensor to read
    :param column_id: string, used to name the columns
    :return: dictionary representing the data in the sensor
    &#34;&#34;&#34;
    timestamps: np.ndarray = np.array(sensor.timestamps.timestamps)
    try:
        columns: List[str] = [
            &#34;timestamps&#34;,
            &#34;unaltered_timestamps&#34;,
            f&#34;{column_id}_x&#34;,
            f&#34;{column_id}_y&#34;,
            f&#34;{column_id}_z&#34;,
        ]
        return pa.Table.from_pydict(
            dict(zip(columns, [timestamps,
                               timestamps,
                               np.array(sensor.x_samples.values),
                               np.array(sensor.y_samples.values),
                               np.array(sensor.z_samples.values),
                               ]
                     )
                 )
        )
    except AttributeError:
        raise</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="redvox.common" href="index.html">redvox.common</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="redvox.common.sensor_reader_utils.apim_best_location_to_pyarrow" href="#redvox.common.sensor_reader_utils.apim_best_location_to_pyarrow">apim_best_location_to_pyarrow</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.apim_compressed_audio_to_pyarrow" href="#redvox.common.sensor_reader_utils.apim_compressed_audio_to_pyarrow">apim_compressed_audio_to_pyarrow</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.apim_health_to_pyarrow" href="#redvox.common.sensor_reader_utils.apim_health_to_pyarrow">apim_health_to_pyarrow</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.apim_image_to_pyarrow" href="#redvox.common.sensor_reader_utils.apim_image_to_pyarrow">apim_image_to_pyarrow</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.apim_location_to_pyarrow" href="#redvox.common.sensor_reader_utils.apim_location_to_pyarrow">apim_location_to_pyarrow</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.get_empty_sensor" href="#redvox.common.sensor_reader_utils.get_empty_sensor">get_empty_sensor</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.get_sample_statistics" href="#redvox.common.sensor_reader_utils.get_sample_statistics">get_sample_statistics</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.get_sensor_description" href="#redvox.common.sensor_reader_utils.get_sensor_description">get_sensor_description</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.read_apim_single_sensor" href="#redvox.common.sensor_reader_utils.read_apim_single_sensor">read_apim_single_sensor</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.read_apim_xyz_sensor" href="#redvox.common.sensor_reader_utils.read_apim_xyz_sensor">read_apim_xyz_sensor</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>