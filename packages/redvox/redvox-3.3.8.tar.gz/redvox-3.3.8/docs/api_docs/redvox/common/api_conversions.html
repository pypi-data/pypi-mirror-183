<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>redvox.common.api_conversions API documentation</title>
<meta name="description" content="Provides functionality for converting between API versions." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>redvox.common.api_conversions</code></h1>
</header>
<section id="section-intro">
<p>Provides functionality for converting between API versions.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Provides functionality for converting between API versions.
&#34;&#34;&#34;

# TODO: Document
# TODO: Test
# TODO: Implement (de)normalization now that dynamic range in known in API M (how does this fork API 900 to API M?)
# TODO: Update any method that sets an enum to accent Union[Enum, int] to fix mypy type errors involving that
# TODO: Breakup conversion into smaller, more testable functions
# TODO: Rework location sensor conversions
# TODO: Add functions for converting compressed audio... in fact, this might make the most sent from converting API 900
# TODO:   into API M data since FLAC requires integers
from typing import List, Optional, Dict, Union

import numpy as np

import redvox.api1000.common.common as common_m
import redvox.api1000.proto.redvox_api_m_pb2 as api_m
import redvox.common.date_time_utils as dt_utls
import redvox.api900.lib.api900_pb2 as api_900
import redvox.api900.reader as reader_900
from redvox.api1000.wrapped_redvox_packet.sensors.sensors import Sensors
from redvox.api1000.wrapped_redvox_packet.sensors.location import LocationProvider
from redvox.api1000.wrapped_redvox_packet.station_information import (
    OsType,
    StationInformation,
    StationMetrics,
    AudioSamplingRate,
)
from redvox.api1000.wrapped_redvox_packet.timing_information import SynchExchange
from redvox.api1000.wrapped_redvox_packet.wrapped_packet import WrappedRedvoxPacketM
import redvox
import redvox.api900.reader_utils as reader_utils

_NORMALIZATION_CONSTANT: int = 0x7FFFFF
NAN: float = float(&#34;nan&#34;)


def _normalize_audio_count(count: int, normalize_by: Optional[float] = None) -&gt; float:
    norm: float = normalize_by if normalize_by is not None else _NORMALIZATION_CONSTANT
    return float(count) / float(norm)


def _denormalize_audio_count(norm: float) -&gt; int:
    return int(round(norm * float(_NORMALIZATION_CONSTANT)))


def _migrate_synch_exchanges_900_to_1000_raw(
    synch_exchanges: np.ndarray,
) -&gt; List[api_m.RedvoxPacketM.TimingInformation.SynchExchange]:
    exchanges: List[api_m.RedvoxPacketM.TimingInformation.SynchExchange] = []

    for i in range(0, len(synch_exchanges), 6):
        exchange: api_m.RedvoxPacketM.TimingInformation.SynchExchange = (
            api_m.RedvoxPacketM.TimingInformation.SynchExchange()
        )
        exchange.a1 = float(synch_exchanges[i])
        exchange.a2 = float(synch_exchanges[i + 1])
        exchange.a3 = float(synch_exchanges[i + 2])
        exchange.b1 = float(synch_exchanges[i + 3])
        exchange.b2 = float(synch_exchanges[i + 4])
        exchange.b3 = float(synch_exchanges[i + 5])
        exchange.unit = api_m.RedvoxPacketM.Unit.MICROSECONDS_SINCE_UNIX_EPOCH

        exchanges.append(exchange)

    return exchanges


def _migrate_synch_exchanges_900_to_1000(
    synch_exchanges: np.ndarray,
) -&gt; List[SynchExchange]:
    exchanges: List[SynchExchange] = []

    for i in range(0, len(synch_exchanges), 6):
        exchange: SynchExchange = SynchExchange.new()
        exchange.set_a1(float(synch_exchanges[i]))
        exchange.set_a2(float(synch_exchanges[i + 1]))
        exchange.set_a3(float(synch_exchanges[i + 2]))
        exchange.set_b1(float(synch_exchanges[i + 3]))
        exchange.set_b2(float(synch_exchanges[i + 4]))
        exchange.set_b3(float(synch_exchanges[i + 5]))
        exchanges.append(exchange)

    return exchanges


def _find_mach_time_zero_raw(packet: api_900.RedvoxPacket) -&gt; int:
    &#34;&#34;&#34;
    find the mach time zero in api 900 packets

    :param packet: api 900 redvox packet to read
    :return: mach time zero of the api 900 packet or -1 if it doesn&#39;t exist
    &#34;&#34;&#34;
    key: str = &#34;machTimeZero&#34;
    mtz: Optional[int] = reader_utils.get_metadata_raw(list(packet.metadata), key, int)
    if mtz is not None:
        return mtz

    location_sensor: Optional[
        api_900.UnevenlySampledChannel
    ] = reader_utils.find_uneven_channel_raw(
        packet,
        {
            api_900.ChannelType.LATITUDE,
            api_900.ChannelType.LONGITUDE,
            api_900.ChannelType.ALTITUDE,
            api_900.ChannelType.SPEED,
        },
    )
    if location_sensor is not None:
        mtz = reader_utils.get_metadata_raw(
            list(location_sensor.metadata), key, int
        )
        if mtz is not None:
            return mtz

    return -1


def _find_mach_time_zero(packet: reader_900.WrappedRedvoxPacket) -&gt; int:
    if &#34;machTimeZero&#34; in packet.metadata_as_dict():
        return int(packet.metadata_as_dict()[&#34;machTimeZero&#34;])

    location_sensor: Optional[reader_900.LocationSensor] = packet.location_sensor()
    if location_sensor is not None:
        if &#34;machTimeZero&#34; in location_sensor.metadata_as_dict():
            return int(location_sensor.metadata_as_dict()[&#34;machTimeZero&#34;])

    return -1


def _packet_length_microseconds_900(packet: reader_900.WrappedRedvoxPacket) -&gt; int:
    microphone_sensor: Optional[
        reader_900.MicrophoneSensor
    ] = packet.microphone_sensor()

    if microphone_sensor is not None:
        sample_rate_hz: float = microphone_sensor.sample_rate_hz()
        total_samples: int = len(microphone_sensor.payload_values())
        length_seconds: float = float(total_samples) / sample_rate_hz
        return round(dt_utls.seconds_to_microseconds(length_seconds))

    return 0


def _packet_length_microseconds_900_raw(packet: api_900.RedvoxPacket) -&gt; int:
    if len(packet.evenly_sampled_channels) == 0:
        return 0

    microphone_sensor: api_900.EvenlySampledChannel = packet.evenly_sampled_channels[0]

    sample_rate_hz: float = microphone_sensor.sample_rate_hz
    total_samples: int = reader_utils.payload_len(microphone_sensor)
    length_seconds: float = float(total_samples) / sample_rate_hz
    return round(dt_utls.seconds_to_microseconds(length_seconds))


# noinspection PyTypeChecker
# pylint: disable=C0103
def _migrate_os_type_900_to_1000(os: str) -&gt; OsType:
    os_lower: str = os.lower()
    if os_lower == &#34;android&#34;:
        return OsType.ANDROID

    if os_lower == &#34;ios&#34;:
        return OsType.IOS

    return OsType.UNKNOWN_OS


def _migrate_os_type_900_to_1000_raw(
    os: str,
):
    os_lower: str = os.lower()
    if os_lower == &#34;android&#34;:
        return api_m.RedvoxPacketM.StationInformation.OsType.ANDROID

    if os_lower == &#34;ios&#34;:
        return api_m.RedvoxPacketM.StationInformation.OsType.IOS

    return api_m.RedvoxPacketM.StationInformation.OsType.UNKNOWN_OS


# pylint: disable=C0103
def _migrate_os_type_1000_to_900(os: OsType) -&gt; str:
    if os == OsType.ANDROID:
        return &#34;Android&#34;
    elif os == OsType.IOS:
        return &#34;iOS&#34;
    else:
        print(f&#34;API 900 unsupported OsType: {os.name}&#34;)
        return os.name


def compute_stats_raw(
    has_stats: Union[
        api_m.RedvoxPacketM.TimingPayload,
        api_m.RedvoxPacketM.SamplePayload,
        api_m.RedvoxPacketM.DoubleSamplePayload,
    ]
):
    values: np.ndarray
    stats_container: api_m.RedvoxPacketM.SummaryStatistics
    if isinstance(has_stats, api_m.RedvoxPacketM.TimingPayload):
        values = np.array(has_stats.timestamps)
        stats_container = has_stats.timestamp_statistics
        mean_sr: float
        std_sr: float
        (mean_sr, std_sr) = common_m.sampling_rate_statistics(values)
        has_stats.mean_sample_rate = mean_sr
        has_stats.stdev_sample_rate = std_sr
    else:
        values = np.array(has_stats.values)
        stats_container = has_stats.value_statistics

    stats_container.count = len(values)
    # noinspection Mypy
    stats_container.min = values.min()
    # noinspection Mypy
    stats_container.max = values.max()
    # noinspection Mypy
    stats_container.mean = values.mean()
    # noinspection Mypy
    stats_container.standard_deviation = values.std()


# noinspection DuplicatedCode
def convert_api_900_to_1000_raw(packet: api_900.RedvoxPacket) -&gt; api_m.RedvoxPacketM:
    &#34;&#34;&#34;
    Converts a wrapped API 900 packet into a wrapped API M packet.

    :param packet: API 900 packet to convert.
    :return: A wrapped API M packet.
    &#34;&#34;&#34;
    packet_m: api_m.RedvoxPacketM = api_m.RedvoxPacketM()

    # Top-level metadata
    packet_m.api = 1000.0
    # noinspection PyUnresolvedReferences,Mypy
    packet_m.sub_api = api_m.SUB_API

    # Station information
    packet_m.station_information.id = packet.redvox_id
    packet_m.station_information.uuid = packet.uuid
    packet_m.station_information.make = packet.device_make
    packet_m.station_information.model = packet.device_model
    packet_m.station_information.os = _migrate_os_type_900_to_1000_raw(packet.device_os)
    packet_m.station_information.os_version = packet.device_os_version
    packet_m.station_information.app_version = packet.app_version
    packet_m.station_information.is_private = packet.is_private

    packet_m.station_information.app_settings.samples_per_window = \
        len(packet.evenly_sampled_channels[0].int32_payload.payload)

    packet_m.station_information.service_urls.acquisition_server = (
        packet.acquisition_server
    )
    packet_m.station_information.service_urls.synch_server = (
        packet.time_synchronization_server
    )
    packet_m.station_information.service_urls.auth_server = packet.authentication_server

    # API 900 does not maintain a copy of its settings. So we will not set anything in AppSettings

    # StationMetrics - We know a couple.
    packet_m.station_information.station_metrics.timestamps.unit = (
        api_m.RedvoxPacketM.Unit.MICROSECONDS_SINCE_UNIX_EPOCH
    )
    packet_m.station_information.station_metrics.timestamps.timestamps[:] = [
        packet.app_file_start_timestamp_machine
    ]
    packet_m.station_information.station_metrics.temperature.unit = (
        api_m.RedvoxPacketM.Unit.DEGREES_CELSIUS
    )
    packet_m.station_information.station_metrics.temperature.values[:] = [
        packet.device_temperature_c
    ]
    packet_m.station_information.station_metrics.battery.unit = (
        api_m.RedvoxPacketM.Unit.PERCENTAGE
    )
    packet_m.station_information.station_metrics.battery.values[:] = [
        packet.battery_level_percent
    ]

    # And we can fill in defaults for those we don&#39;t know
    packet_m.station_information.station_metrics.available_disk.unit = (
        api_m.RedvoxPacketM.Unit.BYTE
    )
    packet_m.station_information.station_metrics.available_disk.values[:] = [
        float(&#34;nan&#34;)
    ]
    packet_m.station_information.station_metrics.available_ram.unit = (
        api_m.RedvoxPacketM.Unit.BYTE
    )
    packet_m.station_information.station_metrics.available_ram.values[:] = [
        float(&#34;nan&#34;)
    ]
    packet_m.station_information.station_metrics.cpu_utilization.unit = (
        api_m.RedvoxPacketM.Unit.PERCENTAGE
    )
    packet_m.station_information.station_metrics.cpu_utilization.values[:] = [
        float(&#34;nan&#34;)
    ]
    packet_m.station_information.station_metrics.network_strength.unit = (
        api_m.RedvoxPacketM.Unit.DECIBEL
    )
    packet_m.station_information.station_metrics.network_strength.values[:] = [
        float(&#34;nan&#34;)
    ]
    packet_m.station_information.station_metrics.battery_current.unit = (
        api_m.RedvoxPacketM.Unit.MICROAMPERES
    )
    packet_m.station_information.station_metrics.battery_current.values[:] = [
        float(&#34;nan&#34;)
    ]
    packet_m.station_information.station_metrics.screen_brightness.unit = (
        api_m.RedvoxPacketM.Unit.PERCENTAGE
    )
    packet_m.station_information.station_metrics.screen_brightness.values[:] = [
        float(&#34;nan&#34;)
    ]

    packet_m.station_information.station_metrics.network_type[:] = [
        api_m.RedvoxPacketM.StationInformation.StationMetrics.NetworkType.UNKNOWN_NETWORK
    ]
    packet_m.station_information.station_metrics.cell_service_state[:] = [
        api_m.RedvoxPacketM.StationInformation.StationMetrics.CellServiceState.UNKNOWN
    ]
    packet_m.station_information.station_metrics.power_state[:] = [
        api_m.RedvoxPacketM.StationInformation.StationMetrics.PowerState.UNKNOWN_POWER_STATE
    ]
    packet_m.station_information.station_metrics.wifi_wake_lock[:] = [
        api_m.RedvoxPacketM.StationInformation.StationMetrics.WifiWakeLock.OTHER
    ]
    packet_m.station_information.station_metrics.screen_state[:] = [
        api_m.RedvoxPacketM.StationInformation.StationMetrics.ScreenState.UNKNOWN_SCREEN_STATE
    ]

    compute_stats_raw(packet_m.station_information.station_metrics.timestamps)
    compute_stats_raw(packet_m.station_information.station_metrics.temperature)
    compute_stats_raw(packet_m.station_information.station_metrics.battery)
    compute_stats_raw(packet_m.station_information.station_metrics.available_disk)
    compute_stats_raw(packet_m.station_information.station_metrics.available_ram)
    compute_stats_raw(packet_m.station_information.station_metrics.cpu_utilization)
    compute_stats_raw(packet_m.station_information.station_metrics.network_strength)
    compute_stats_raw(packet_m.station_information.station_metrics.battery_current)
    compute_stats_raw(packet_m.station_information.station_metrics.screen_brightness)

    # Timing information
    mach_time_900: int = packet.app_file_start_timestamp_machine
    os_time_900: int = packet.app_file_start_timestamp_epoch_microseconds_utc
    len_micros: int = _packet_length_microseconds_900_raw(packet)
    best_latency: float = reader_utils.get_metadata_or_default(
        list(packet.metadata), &#34;bestLatency&#34;, float, NAN
    )
    best_offset: float = reader_utils.get_metadata_or_default(
        list(packet.metadata), &#34;bestOffset&#34;, float, NAN
    )

    packet_m.timing_information.unit = (
        api_m.RedvoxPacketM.Unit.MICROSECONDS_SINCE_UNIX_EPOCH
    )
    packet_m.timing_information.packet_start_mach_timestamp = mach_time_900
    packet_m.timing_information.packet_start_os_timestamp = os_time_900
    packet_m.timing_information.packet_end_mach_timestamp = mach_time_900 + len_micros
    packet_m.timing_information.server_acquisition_arrival_timestamp = (
        packet.server_timestamp_epoch_microseconds_utc
    )
    packet_m.timing_information.packet_end_os_timestamp = os_time_900 + len_micros
    packet_m.timing_information.app_start_mach_timestamp = _find_mach_time_zero_raw(
        packet
    )
    packet_m.timing_information.best_latency = best_latency
    packet_m.timing_information.best_offset = best_offset

    synch_sensor: Optional[
        api_900.UnevenlySampledChannel
    ] = reader_utils.find_uneven_channel_raw(
        packet, {api_900.ChannelType.TIME_SYNCHRONIZATION}
    )
    if synch_sensor is not None:
        synch_payload: np.ndarray = reader_utils.extract_payload(synch_sensor)
        packet_m.timing_information.synch_exchanges.extend(
            _migrate_synch_exchanges_900_to_1000_raw(synch_payload)
        )

    # Sensors
    # Microphone / Audio
    if len(packet.evenly_sampled_channels) &lt; 1:
        raise ValueError(&#34;Cannot convert API900 to API1000; Audio sensor missing.&#34;)
    audio_900: api_900.EvenlySampledChannel = packet.evenly_sampled_channels[0]
    packet_m.sensors.audio.sensor_description = audio_900.sensor_name
    packet_m.sensors.audio.sample_rate = audio_900.sample_rate_hz
    packet_m.sensors.audio.first_sample_timestamp = (
        audio_900.first_sample_timestamp_epoch_microseconds_utc
    )
    packet_m.sensors.audio.bits_of_precision = 16.0
    packet_m.sensors.audio.encoding = &#34;counts&#34;
    normalized_audio: np.ndarray = (
        reader_utils.extract_payload(audio_900) / _NORMALIZATION_CONSTANT
    )
    packet_m.sensors.audio.samples.values[:] = list(normalized_audio)
    packet_m.sensors.audio.samples.unit = api_m.RedvoxPacketM.Unit.NORMALIZED_COUNTS
    for i in range(0, len(audio_900.metadata), 2):
        v: str = audio_900.metadata[i + 1] if (i + 1) &lt; len(audio_900.metadata) else &#34;&#34;
        packet_m.sensors.audio.metadata[audio_900.metadata[i]] = v
    compute_stats_raw(packet_m.sensors.audio.samples)

    # Pressure
    barometer_900: Optional[
        api_900.UnevenlySampledChannel
    ] = reader_utils.find_uneven_channel_raw(packet, {api_900.ChannelType.BAROMETER})
    if barometer_900 is not None:
        packet_m.sensors.pressure.sensor_description = barometer_900.sensor_name
        packet_m.sensors.pressure.timestamps.unit = (
            api_m.RedvoxPacketM.Unit.MICROSECONDS_SINCE_UNIX_EPOCH
        )
        packet_m.sensors.pressure.timestamps.timestamps[
            :
        ] = barometer_900.timestamps_microseconds_utc
        packet_m.sensors.pressure.samples.values[:] = list(
            reader_utils.extract_payload(barometer_900)
        )
        packet_m.sensors.pressure.samples.unit = api_m.RedvoxPacketM.Unit.KILOPASCAL
        for i in range(0, len(barometer_900.metadata), 2):
            v = (
                barometer_900.metadata[i + 1]
                if (i + 1) &lt; len(barometer_900.metadata)
                else &#34;&#34;
            )
            packet_m.sensors.pressure.metadata[barometer_900.metadata[i]] = v
        compute_stats_raw(packet_m.sensors.pressure.timestamps)
        compute_stats_raw(packet_m.sensors.pressure.samples)

    # Location
    loc_900: Optional[
        api_900.UnevenlySampledChannel
    ] = reader_utils.find_uneven_channel_raw(
        packet,
        {
            api_900.ChannelType.LATITUDE,
            api_900.ChannelType.LONGITUDE,
            api_900.ChannelType.ALTITUDE,
            api_900.ChannelType.SPEED,
            api_900.ChannelType.ACCURACY,
        },
    )
    if loc_900 is not None:
        total_samples: int = len(loc_900.timestamps_microseconds_utc)
        loc_payload: List[float] = list(reader_utils.extract_payload(loc_900))
        packet_m.sensors.location.sensor_description = loc_900.sensor_name
        packet_m.sensors.location.timestamps.unit = (
            api_m.RedvoxPacketM.Unit.MICROSECONDS_SINCE_UNIX_EPOCH
        )
        packet_m.sensors.location.timestamps.timestamps[
            :
        ] = loc_900.timestamps_microseconds_utc
        packet_m.sensors.location.timestamps_gps.unit = (
            api_m.RedvoxPacketM.Unit.MICROSECONDS_SINCE_UNIX_EPOCH
        )
        packet_m.sensors.location.timestamps_gps.timestamps[:] = [
            float(&#34;nan&#34;)
        ] * total_samples

        total_channels: int = len(loc_900.channel_types)

        lat_idx: Optional[int] = reader_utils.extract_uneven_payload_idx_raw(
            packet, api_900.ChannelType.LATITUDE
        )
        packet_m.sensors.location.latitude_samples.unit = (
            api_m.RedvoxPacketM.Unit.DECIMAL_DEGREES
        )
        if lat_idx is not None:
            packet_m.sensors.location.latitude_samples.values[:] = loc_payload[
                lat_idx::total_channels
            ]
        else:
            packet_m.sensors.location.latitude_samples.values[:] = [
                float(&#34;nan&#34;) * total_samples
            ]

        lng_idx: Optional[int] = reader_utils.extract_uneven_payload_idx_raw(
            packet, api_900.ChannelType.LONGITUDE
        )
        packet_m.sensors.location.longitude_samples.unit = (
            api_m.RedvoxPacketM.Unit.DECIMAL_DEGREES
        )
        if lng_idx is not None:
            packet_m.sensors.location.longitude_samples.values[:] = loc_payload[
                lng_idx::total_channels
            ]
        else:
            packet_m.sensors.location.longitude_samples.values[:] = [
                float(&#34;nan&#34;) * total_samples
            ]

        alt_idx: Optional[int] = reader_utils.extract_uneven_payload_idx_raw(
            packet, api_900.ChannelType.ALTITUDE
        )
        packet_m.sensors.location.altitude_samples.unit = (
            api_m.RedvoxPacketM.Unit.METERS
        )
        if alt_idx is not None:
            packet_m.sensors.location.altitude_samples.values[:] = loc_payload[
                alt_idx::total_channels
            ]
        else:
            packet_m.sensors.location.altitude_samples.values[:] = [
                float(&#34;nan&#34;) * total_samples
            ]

        speed_idx: Optional[int] = reader_utils.extract_uneven_payload_idx_raw(
            packet, api_900.ChannelType.SPEED
        )
        packet_m.sensors.location.speed_samples.unit = (
            api_m.RedvoxPacketM.Unit.METERS_PER_SECOND
        )
        if speed_idx is not None:
            packet_m.sensors.location.speed_samples.values[:] = loc_payload[
                speed_idx::total_channels
            ]
        else:
            packet_m.sensors.location.speed_samples.values[:] = [
                float(&#34;nan&#34;) * total_samples
            ]

        acc_idx: Optional[int] = reader_utils.extract_uneven_payload_idx_raw(
            packet, api_900.ChannelType.ACCURACY
        )
        packet_m.sensors.location.horizontal_accuracy_samples.unit = (
            api_m.RedvoxPacketM.Unit.METERS
        )
        if acc_idx is not None:
            packet_m.sensors.location.horizontal_accuracy_samples.values[
                :
            ] = loc_payload[acc_idx::total_channels]
        else:
            packet_m.sensors.location.horizontal_accuracy_samples.values[:] = [
                float(&#34;nan&#34;) * total_samples
            ]

        packet_m.sensors.location.bearing_samples.unit = (
            api_m.RedvoxPacketM.Unit.DECIMAL_DEGREES
        )
        packet_m.sensors.location.bearing_samples.values[:] = [
            float(&#34;nan&#34;) * total_samples
        ]

        packet_m.sensors.location.vertical_accuracy_samples.unit = (
            api_m.RedvoxPacketM.Unit.METERS
        )
        packet_m.sensors.location.vertical_accuracy_samples.values[:] = [
            float(&#34;nan&#34;) * total_samples
        ]
        packet_m.sensors.location.speed_accuracy_samples.unit = (
            api_m.RedvoxPacketM.Unit.METERS_PER_SECOND
        )
        packet_m.sensors.location.speed_accuracy_samples.values[:] = [
            float(&#34;nan&#34;) * total_samples
        ]
        packet_m.sensors.location.bearing_accuracy_samples.unit = (
            api_m.RedvoxPacketM.Unit.DECIMAL_DEGREES
        )
        packet_m.sensors.location.bearing_accuracy_samples.values[:] = [
            float(&#34;nan&#34;) * total_samples
        ]

        # Compute stats
        compute_stats_raw(packet_m.sensors.location.timestamps)
        compute_stats_raw(packet_m.sensors.location.timestamps_gps)
        compute_stats_raw(packet_m.sensors.location.latitude_samples)
        compute_stats_raw(packet_m.sensors.location.longitude_samples)
        compute_stats_raw(packet_m.sensors.location.altitude_samples)
        compute_stats_raw(packet_m.sensors.location.speed_samples)
        compute_stats_raw(packet_m.sensors.location.bearing_samples)
        compute_stats_raw(packet_m.sensors.location.horizontal_accuracy_samples)
        compute_stats_raw(packet_m.sensors.location.vertical_accuracy_samples)
        compute_stats_raw(packet_m.sensors.location.speed_accuracy_samples)
        compute_stats_raw(packet_m.sensors.location.bearing_accuracy_samples)

        # Bookkeeping
        use_location: bool = reader_utils.get_metadata_or_default(
            list(loc_900.metadata), &#34;useLocation&#34;, lambda val: v == &#34;T&#34;, False
        )
        desired_location: bool = reader_utils.get_metadata_or_default(
            list(loc_900.metadata), &#34;desiredLocation&#34;, lambda val: v == &#34;T&#34;, False
        )
        permission_location: bool = reader_utils.get_metadata_or_default(
            list(loc_900.metadata), &#34;permissionLocation&#34;, lambda val: v == &#34;T&#34;, False
        )
        enabled_location: bool = reader_utils.get_metadata_or_default(
            list(loc_900.metadata), &#34;enabledLocation&#34;, lambda val: v == &#34;T&#34;, False
        )

        if desired_location:
            packet_m.sensors.location.location_providers[:] = [
                api_m.RedvoxPacketM.Sensors.Location.LocationProvider.USER
            ] * total_samples
        elif enabled_location:
            packet_m.sensors.location.location_providers[:] = [
                api_m.RedvoxPacketM.Sensors.Location.LocationProvider.GPS
            ] * total_samples
        elif use_location and desired_location and permission_location:
            packet_m.sensors.location.location_providers[:] = [
                api_m.RedvoxPacketM.Sensors.Location.LocationProvider.NETWORK
            ] * total_samples
        else:
            packet_m.sensors.location.location_providers[:] = [
                api_m.RedvoxPacketM.Sensors.Location.LocationProvider.NONE
            ] * total_samples

        packet_m.sensors.location.location_permissions_granted = permission_location
        packet_m.sensors.location.location_services_enabled = use_location
        packet_m.sensors.location.location_services_requested = desired_location

        for (i, k) in enumerate(loc_900.metadata):
            if i + 1 &lt; len(loc_900.metadata):
                packet_m.sensors.location.metadata[k] = loc_900.metadata[i + 1]
            else:
                packet_m.sensors.location.metadata[k] = &#34;&#34;

    # # Time Synchronization
    # # This was already added to the timing information

    # Accelerometer
    accel_900: Optional[
        api_900.UnevenlySampledChannel
    ] = reader_utils.find_uneven_channel_raw(
        packet,
        {
            api_900.ChannelType.ACCELEROMETER_X,
            api_900.ChannelType.ACCELEROMETER_Y,
            api_900.ChannelType.ACCELEROMETER_Z,
        },
    )
    if accel_900 is not None:
        packet_m.sensors.accelerometer.sensor_description = accel_900.sensor_name
        packet_m.sensors.accelerometer.timestamps.unit = (
            api_m.RedvoxPacketM.Unit.MICROSECONDS_SINCE_UNIX_EPOCH
        )
        packet_m.sensors.accelerometer.timestamps.timestamps[
            :
        ] = accel_900.timestamps_microseconds_utc
        accel_payload: List[float] = list(reader_utils.extract_payload(accel_900))
        packet_m.sensors.accelerometer.x_samples.unit = (
            api_m.RedvoxPacketM.Unit.METERS_PER_SECOND_SQUARED
        )
        packet_m.sensors.accelerometer.x_samples.values[:] = accel_payload[0::3]
        packet_m.sensors.accelerometer.y_samples.unit = (
            api_m.RedvoxPacketM.Unit.METERS_PER_SECOND_SQUARED
        )
        packet_m.sensors.accelerometer.y_samples.values[:] = accel_payload[1::3]
        packet_m.sensors.accelerometer.z_samples.unit = (
            api_m.RedvoxPacketM.Unit.METERS_PER_SECOND_SQUARED
        )
        packet_m.sensors.accelerometer.z_samples.values[:] = accel_payload[2::3]
        compute_stats_raw(packet_m.sensors.accelerometer.timestamps)
        compute_stats_raw(packet_m.sensors.accelerometer.x_samples)
        compute_stats_raw(packet_m.sensors.accelerometer.y_samples)
        compute_stats_raw(packet_m.sensors.accelerometer.z_samples)

    # Magnetometer
    sensor: Optional[
        api_900.UnevenlySampledChannel
    ] = reader_utils.find_uneven_channel_raw(
        packet,
        {
            api_900.ChannelType.MAGNETOMETER_X,
            api_900.ChannelType.MAGNETOMETER_Y,
            api_900.ChannelType.MAGNETOMETER_Z,
        },
    )
    if sensor is not None:
        packet_m.sensors.magnetometer.sensor_description = sensor.sensor_name
        packet_m.sensors.magnetometer.timestamps.unit = (
            api_m.RedvoxPacketM.Unit.MICROSECONDS_SINCE_UNIX_EPOCH
        )
        packet_m.sensors.magnetometer.timestamps.timestamps[
            :
        ] = sensor.timestamps_microseconds_utc
        sensor_payload: List[float] = list(reader_utils.extract_payload(sensor))
        packet_m.sensors.magnetometer.x_samples.unit = (
            api_m.RedvoxPacketM.Unit.MICROTESLA
        )
        packet_m.sensors.magnetometer.x_samples.values[:] = sensor_payload[0::3]
        packet_m.sensors.magnetometer.y_samples.unit = (
            api_m.RedvoxPacketM.Unit.MICROTESLA
        )
        packet_m.sensors.magnetometer.y_samples.values[:] = sensor_payload[1::3]
        packet_m.sensors.magnetometer.z_samples.unit = (
            api_m.RedvoxPacketM.Unit.MICROTESLA
        )
        packet_m.sensors.magnetometer.z_samples.values[:] = sensor_payload[2::3]
        compute_stats_raw(packet_m.sensors.magnetometer.timestamps)
        compute_stats_raw(packet_m.sensors.magnetometer.x_samples)
        compute_stats_raw(packet_m.sensors.magnetometer.y_samples)
        compute_stats_raw(packet_m.sensors.magnetometer.z_samples)
    #
    # Gyroscope
    sensor = reader_utils.find_uneven_channel_raw(
        packet,
        {
            api_900.ChannelType.GYROSCOPE_X,
            api_900.ChannelType.GYROSCOPE_Y,
            api_900.ChannelType.GYROSCOPE_Z,
        },
    )
    if sensor is not None:
        packet_m.sensors.gyroscope.sensor_description = sensor.sensor_name
        packet_m.sensors.gyroscope.timestamps.unit = (
            api_m.RedvoxPacketM.Unit.MICROSECONDS_SINCE_UNIX_EPOCH
        )
        packet_m.sensors.gyroscope.timestamps.timestamps[
            :
        ] = sensor.timestamps_microseconds_utc
        sensor_payload = list(reader_utils.extract_payload(sensor))
        packet_m.sensors.gyroscope.x_samples.unit = (
            api_m.RedvoxPacketM.Unit.RADIANS_PER_SECOND
        )
        packet_m.sensors.gyroscope.x_samples.values[:] = sensor_payload[0::3]
        packet_m.sensors.gyroscope.y_samples.unit = (
            api_m.RedvoxPacketM.Unit.RADIANS_PER_SECOND
        )
        packet_m.sensors.gyroscope.y_samples.values[:] = sensor_payload[1::3]
        packet_m.sensors.gyroscope.z_samples.unit = (
            api_m.RedvoxPacketM.Unit.RADIANS_PER_SECOND
        )
        packet_m.sensors.gyroscope.z_samples.values[:] = sensor_payload[2::3]
        compute_stats_raw(packet_m.sensors.gyroscope.timestamps)
        compute_stats_raw(packet_m.sensors.gyroscope.x_samples)
        compute_stats_raw(packet_m.sensors.gyroscope.y_samples)
        compute_stats_raw(packet_m.sensors.gyroscope.z_samples)

    #
    # # Light
    light_900: Optional[
        api_900.UnevenlySampledChannel
    ] = reader_utils.find_uneven_channel_raw(packet, {api_900.ChannelType.LIGHT})
    if light_900 is not None:
        packet_m.sensors.light.sensor_description = light_900.sensor_name
        packet_m.sensors.light.timestamps.unit = (
            api_m.RedvoxPacketM.Unit.MICROSECONDS_SINCE_UNIX_EPOCH
        )
        packet_m.sensors.light.timestamps.timestamps[
            :
        ] = light_900.timestamps_microseconds_utc
        packet_m.sensors.light.samples.values[:] = list(
            reader_utils.extract_payload(light_900)
        )
        packet_m.sensors.light.samples.unit = api_m.RedvoxPacketM.Unit.LUX
        for i in range(0, len(light_900.metadata), 2):
            v = light_900.metadata[i + 1] if (i + 1) &lt; len(light_900.metadata) else &#34;&#34;
            packet_m.sensors.light.metadata[light_900.metadata[i]] = v
        compute_stats_raw(packet_m.sensors.light.timestamps)
        compute_stats_raw(packet_m.sensors.light.samples)

    # # Image
    # Not implemented for conversion. Only a very small fraction of API 900 was ever image capable, and not the public
    # app.

    # # Proximity
    proximity_900: Optional[
        api_900.UnevenlySampledChannel
    ] = reader_utils.find_uneven_channel_raw(packet, {api_900.ChannelType.INFRARED})
    if proximity_900 is not None:
        packet_m.sensors.proximity.sensor_description = proximity_900.sensor_name
        packet_m.sensors.proximity.timestamps.unit = (
            api_m.RedvoxPacketM.Unit.MICROSECONDS_SINCE_UNIX_EPOCH
        )
        packet_m.sensors.proximity.timestamps.timestamps[
            :
        ] = proximity_900.timestamps_microseconds_utc
        packet_m.sensors.proximity.samples.values[:] = list(
            reader_utils.extract_payload(proximity_900)
        )
        packet_m.sensors.proximity.samples.unit = api_m.RedvoxPacketM.Unit.CENTIMETERS
        for i in range(0, len(proximity_900.metadata), 2):
            v = (
                proximity_900.metadata[i + 1]
                if (i + 1) &lt; len(proximity_900.metadata)
                else &#34;&#34;
            )
            packet_m.sensors.proximity.metadata[proximity_900.metadata[i]] = v
        compute_stats_raw(packet_m.sensors.proximity.timestamps)
        compute_stats_raw(packet_m.sensors.proximity.samples)

    return packet_m


# noinspection DuplicatedCode
def convert_api_900_to_1000(
    wrapped_packet_900: reader_900.WrappedRedvoxPacket,
) -&gt; WrappedRedvoxPacketM:
    &#34;&#34;&#34;
    Converts a wrapped API 900 packet into a wrapped API M packet.

    :param wrapped_packet_900: API 900 packet to convert.
    :return: A wrapped API M packet.
    &#34;&#34;&#34;
    wrapped_packet_m: WrappedRedvoxPacketM = WrappedRedvoxPacketM.new()

    # Top-level metadata
    wrapped_packet_m.set_api(1000.0)
    # noinspection PyUnresolvedReferences,Mypy
    wrapped_packet_m.set_sub_api(api_m.SUB_API)

    # Station information
    station_information: StationInformation = wrapped_packet_m.get_station_information()
    station_information.set_id(wrapped_packet_900.redvox_id()).set_uuid(
        wrapped_packet_900.uuid()
    ).set_make(wrapped_packet_900.device_make()).set_model(
        wrapped_packet_900.device_model()
    ).set_os(
        _migrate_os_type_900_to_1000(wrapped_packet_900.device_os())
    ).set_os_version(
        wrapped_packet_900.device_os_version()
    ).set_app_version(
        wrapped_packet_900.app_version()
    ).set_is_private(
        wrapped_packet_900.is_private()
    )

    station_information.get_service_urls().set_acquisition_server(
        wrapped_packet_900.acquisition_server()
    ).set_synch_server(
        wrapped_packet_900.time_synchronization_server()
    ).set_auth_server(
        wrapped_packet_900.authentication_server()
    )

    # API 900 does not maintain a copy of its settings. So we will not set anything in AppSettings

    # StationMetrics - We know a couple. We take a slightly more cumbersome approach using the raw protobuf
    # to avoid some conversions between lists and np arrays.
    station_metrics: StationMetrics = station_information.get_station_metrics()
    station_metrics.get_timestamps().append_timestamp(
        wrapped_packet_900.app_file_start_timestamp_machine()
    )
    station_metrics.get_temperature().set_values(
        np.array([wrapped_packet_900.device_temperature_c()]), True
    )
    station_metrics.get_battery().set_values(
        np.array([wrapped_packet_900.battery_level_percent()]), True
    )

    # Timing information
    mach_time_900: int = wrapped_packet_900.app_file_start_timestamp_machine()
    os_time_900: int = (
        wrapped_packet_900.app_file_start_timestamp_epoch_microseconds_utc()
    )
    len_micros: int = _packet_length_microseconds_900(wrapped_packet_900)
    best_latency: Optional[float] = wrapped_packet_900.best_latency()
    best_latency = best_latency if best_latency is not None else NAN
    best_offset: Optional[float] = wrapped_packet_900.best_offset()
    best_offset = best_offset if best_offset is not None else NAN

    wrapped_packet_m.get_timing_information().set_unit(
        common_m.Unit.MICROSECONDS_SINCE_UNIX_EPOCH
    ).set_packet_start_mach_timestamp(mach_time_900).set_packet_start_os_timestamp(
        os_time_900
    ).set_packet_end_mach_timestamp(
        mach_time_900 + len_micros
    ).set_packet_end_os_timestamp(
        os_time_900 + len_micros
    ).set_server_acquisition_arrival_timestamp(
        wrapped_packet_900.server_timestamp_epoch_microseconds_utc()
    ).set_app_start_mach_timestamp(
        _find_mach_time_zero(wrapped_packet_900)
    ).set_best_latency(
        best_latency
    ).set_best_offset(
        best_offset
    )

    time_sensor = wrapped_packet_900.time_synchronization_sensor()
    if time_sensor is not None:
        wrapped_packet_m.get_timing_information().get_synch_exchanges().set_values(
            _migrate_synch_exchanges_900_to_1000(time_sensor.payload_values())
        )

    # Sensors
    sensors_m: Sensors = wrapped_packet_m.get_sensors()
    # Microphone / Audio
    mic_sensor_900: Optional[
        reader_900.MicrophoneSensor
    ] = wrapped_packet_900.microphone_sensor()
    if mic_sensor_900 is not None:
        normalized_audio: np.ndarray = (
            mic_sensor_900.payload_values() / _NORMALIZATION_CONSTANT
        )
        audio_sensor_m = sensors_m.new_audio()
        audio_sensor_m.set_first_sample_timestamp(
            mic_sensor_900.first_sample_timestamp_epoch_microseconds_utc()
        ).set_is_scrambled(wrapped_packet_900.is_scrambled()).set_sample_rate(
            mic_sensor_900.sample_rate_hz()
        ).set_sensor_description(
            mic_sensor_900.sensor_name()
        ).get_samples().set_values(
            normalized_audio, update_value_statistics=True
        )
        audio_sensor_m.get_metadata().set_metadata(mic_sensor_900.metadata_as_dict())

    # Barometer
    barometer_sensor_900: Optional[
        reader_900.BarometerSensor
    ] = wrapped_packet_900.barometer_sensor()
    if barometer_sensor_900 is not None:
        pressure_sensor_m = sensors_m.new_pressure()
        pressure_sensor_m.set_sensor_description(barometer_sensor_900.sensor_name())
        pressure_sensor_m.get_timestamps().set_timestamps(
            barometer_sensor_900.timestamps_microseconds_utc(), True
        )
        pressure_sensor_m.get_samples().set_values(
            barometer_sensor_900.payload_values(), True
        )
        pressure_sensor_m.get_metadata().set_metadata(
            barometer_sensor_900.metadata_as_dict()
        )

    # Location
    # TODO: rework
    location_sensor_900: Optional[
        reader_900.LocationSensor
    ] = wrapped_packet_900.location_sensor()
    if location_sensor_900 is not None:
        location_m = sensors_m.new_location()
        location_m.set_sensor_description(location_sensor_900.sensor_name())
        location_m.get_timestamps().set_timestamps(
            location_sensor_900.timestamps_microseconds_utc(), True
        )
        if location_sensor_900.check_for_preset_lat_lon():
            lat_lon: np.ndarray = location_sensor_900.get_payload_lat_lon()
            location_m.get_latitude_samples().set_values(lat_lon[:1], True)
            location_m.get_longitude_samples().set_values(lat_lon[1:], True)
        else:
            location_m.get_latitude_samples().set_values(
                location_sensor_900.payload_values_latitude(), True
            )
            location_m.get_longitude_samples().set_values(
                location_sensor_900.payload_values_longitude(), True
            )
            location_m.get_altitude_samples().set_values(
                location_sensor_900.payload_values_altitude(), True
            )
            location_m.get_speed_samples().set_values(
                location_sensor_900.payload_values_speed(), True
            )
            location_m.get_horizontal_accuracy_samples().set_values(
                location_sensor_900.payload_values_accuracy(), True
            )

        def _extract_meta_bool(metad: Dict[str, str], key: str) -&gt; bool:
            if key not in metad:
                return False

            return metad[key] == &#34;T&#34;

        loc_meta_900 = location_sensor_900.metadata_as_dict()
        use_location = _extract_meta_bool(loc_meta_900, &#34;useLocation&#34;)
        desired_location = _extract_meta_bool(loc_meta_900, &#34;desiredLocation&#34;)
        permission_location = _extract_meta_bool(loc_meta_900, &#34;permissionLocation&#34;)
        enabled_location = _extract_meta_bool(loc_meta_900, &#34;enabledLocation&#34;)

        n_p = location_m.get_timestamps().get_timestamps_count()

        if desired_location:
            location_m.get_location_providers().set_values(
                [LocationProvider.USER for i in range(n_p)]
            )
        elif enabled_location:
            location_m.get_location_providers().set_values(
                [LocationProvider.GPS for i in range(n_p)]
            )
        elif use_location and desired_location and permission_location:
            location_m.get_location_providers().set_values(
                [LocationProvider.NETWORK for i in range(n_p)]
            )
        else:
            location_m.get_location_providers().set_values(
                [LocationProvider.NONE for i in range(n_p)]
            )

        location_m.set_location_permissions_granted(permission_location)
        location_m.set_location_services_enabled(use_location)
        location_m.set_location_services_requested(desired_location)

        # Once we&#39;re done here, we should remove the original metadata
        if &#34;useLocation&#34; in loc_meta_900:
            del loc_meta_900[&#34;useLocation&#34;]
        if &#34;desiredLocation&#34; in loc_meta_900:
            del loc_meta_900[&#34;desiredLocation&#34;]
        if &#34;permissionLocation&#34; in loc_meta_900:
            del loc_meta_900[&#34;permissionLocation&#34;]
        if &#34;enabledLocation&#34; in loc_meta_900:
            del loc_meta_900[&#34;enabledLocation&#34;]
        if &#34;machTimeZero&#34; in loc_meta_900:
            del loc_meta_900[&#34;machTimeZero&#34;]
        location_m.get_metadata().set_metadata(loc_meta_900)

    # Time Synchronization
    # This was already added to the timing information

    # Accelerometer
    accelerometer_900 = wrapped_packet_900.accelerometer_sensor()
    if accelerometer_900 is not None:
        accelerometer_m = sensors_m.new_accelerometer()
        accelerometer_m.set_sensor_description(accelerometer_900.sensor_name())
        accelerometer_m.get_timestamps().set_timestamps(
            accelerometer_900.timestamps_microseconds_utc(), True
        )
        accelerometer_m.get_x_samples().set_values(
            accelerometer_900.payload_values_x(), True
        )
        accelerometer_m.get_y_samples().set_values(
            accelerometer_900.payload_values_y(), True
        )
        accelerometer_m.get_z_samples().set_values(
            accelerometer_900.payload_values_z(), True
        )
        accelerometer_m.get_metadata().set_metadata(
            accelerometer_900.metadata_as_dict()
        )

    # Magnetometer
    magnetometer_900 = wrapped_packet_900.magnetometer_sensor()
    if magnetometer_900 is not None:
        magnetometer_m = sensors_m.new_magnetometer()
        magnetometer_m.set_sensor_description(magnetometer_900.sensor_name())
        magnetometer_m.get_timestamps().set_timestamps(
            magnetometer_900.timestamps_microseconds_utc(), True
        )
        magnetometer_m.get_x_samples().set_values(
            magnetometer_900.payload_values_x(), True
        )
        magnetometer_m.get_y_samples().set_values(
            magnetometer_900.payload_values_y(), True
        )
        magnetometer_m.get_z_samples().set_values(
            magnetometer_900.payload_values_z(), True
        )
        magnetometer_m.get_metadata().set_metadata(magnetometer_900.metadata_as_dict())

    # Gyroscope
    gyroscope_900 = wrapped_packet_900.gyroscope_sensor()
    if gyroscope_900 is not None:
        gyroscope_m = sensors_m.new_gyroscope()
        gyroscope_m.set_sensor_description(gyroscope_900.sensor_name())
        gyroscope_m.get_timestamps().set_timestamps(
            gyroscope_900.timestamps_microseconds_utc(), True
        )
        gyroscope_m.get_x_samples().set_values(gyroscope_900.payload_values_x(), True)
        gyroscope_m.get_y_samples().set_values(gyroscope_900.payload_values_y(), True)
        gyroscope_m.get_z_samples().set_values(gyroscope_900.payload_values_z(), True)
        gyroscope_m.get_metadata().set_metadata(gyroscope_900.metadata_as_dict())

    # Light
    light_900 = wrapped_packet_900.light_sensor()
    if light_900 is not None:
        light_m = sensors_m.new_light()
        light_m.set_sensor_description(light_900.sensor_name())
        light_m.get_timestamps().set_timestamps(
            light_900.timestamps_microseconds_utc(), True
        )
        light_m.get_samples().set_values(light_900.payload_values(), True)
        light_m.get_metadata().set_metadata(light_900.metadata_as_dict())

    # Image
    # TODO: Implement

    # Proximity
    proximity_900 = wrapped_packet_900.infrared_sensor()
    if proximity_900 is not None:
        proximity_m = sensors_m.new_proximity()
        proximity_m.set_sensor_description(proximity_900.sensor_name())
        proximity_m.get_timestamps().set_timestamps(
            proximity_900.timestamps_microseconds_utc(), True
        )
        proximity_m.get_samples().set_values(proximity_900.payload_values(), True)
        proximity_m.get_metadata().set_metadata(proximity_900.metadata_as_dict())

    # Removed any other API 900 top-level metadata now that its been used
    meta = wrapped_packet_900.metadata_as_dict()
    if &#34;machTimeZero&#34; in meta:
        del meta[&#34;machTimeZero&#34;]
    if &#34;bestOffset&#34; in meta:
        del meta[&#34;bestOffset&#34;]
    if &#34;bestLatency&#34; in meta:
        del meta[&#34;bestLatency&#34;]
    wrapped_packet_m.get_metadata().append_metadata(
        &#34;migrated_from_api_900&#34;, f&#34;v{redvox.VERSION}&#34;
    )

    return wrapped_packet_m


def convert_api_1000_to_900(
    wrapped_packet_m: WrappedRedvoxPacketM,
) -&gt; reader_900.WrappedRedvoxPacket:
    &#34;&#34;&#34;
    Converts an API M wrapped packet into an API 900 wrapped packet.

    :param wrapped_packet_m: Packet to convert.
    :return: An API 900 wrapped packet.
    &#34;&#34;&#34;
    # TODO detect and warn about all the fields that are being dropped due to conversion!
    wrapped_packet_900: reader_900.WrappedRedvoxPacket = (
        reader_900.WrappedRedvoxPacket()
    )

    station_information_m = wrapped_packet_m.get_station_information()
    sensors_m = wrapped_packet_m.get_sensors()
    audio_m = sensors_m.get_audio()

    wrapped_packet_900.set_api(900)
    wrapped_packet_900.set_uuid(station_information_m.get_uuid())
    wrapped_packet_900.set_redvox_id(station_information_m.get_id())
    wrapped_packet_900.set_authenticated_email(station_information_m.get_auth_id())
    wrapped_packet_900.set_authentication_token(
        &#34;n/a&#34;
    )  # Different auth protocols are used, can&#39;t convert between
    wrapped_packet_900.set_firebase_token(&#34;n/a&#34;)  # No longer in API M packet
    wrapped_packet_900.set_is_backfilled(False)  # No longer useful metric in API M
    wrapped_packet_900.set_is_private(station_information_m.get_is_private())
    wrapped_packet_900.set_is_scrambled(False)
    wrapped_packet_900.set_device_make(station_information_m.get_make())
    wrapped_packet_900.set_device_model(station_information_m.get_model())
    wrapped_packet_900.set_device_os(
        _migrate_os_type_1000_to_900(station_information_m.get_os())
    )
    wrapped_packet_900.set_device_os_version(station_information_m.get_os_version())
    wrapped_packet_900.set_app_version(station_information_m.get_app_version())

    battery_metrics = station_information_m.get_station_metrics().get_battery()
    battery_percent: float = (
        battery_metrics.get_values()[-1]
        if battery_metrics.get_values_count() &gt; 0
        else 0.0
    )
    wrapped_packet_900.set_battery_level_percent(battery_percent)
    temp_metrics = station_information_m.get_station_metrics().get_temperature()
    device_temp: float = (
        temp_metrics.get_values()[-1] if temp_metrics.get_values_count() &gt; 0 else 0.0
    )
    wrapped_packet_900.set_device_temperature_c(device_temp)

    server_info_m = wrapped_packet_m.get_station_information().get_service_urls()
    wrapped_packet_900.set_acquisition_server(server_info_m.get_acquisition_server())
    wrapped_packet_900.set_time_synchronization_server(server_info_m.get_synch_server())
    wrapped_packet_900.set_authentication_server(server_info_m.get_auth_server())

    timing_info_m = wrapped_packet_m.get_timing_information()
    wrapped_packet_900.set_app_file_start_timestamp_epoch_microseconds_utc(
        round(timing_info_m.get_packet_start_os_timestamp())
    )
    wrapped_packet_900.set_app_file_start_timestamp_machine(
        round(timing_info_m.get_packet_start_mach_timestamp())
    )
    wrapped_packet_900.set_server_timestamp_epoch_microseconds_utc(
        round(timing_info_m.get_server_acquisition_arrival_timestamp())
    )

    # Top-level metadata
    wrapped_packet_900.add_metadata(
        &#34;machTimeZero&#34;, str(timing_info_m.get_app_start_mach_timestamp())
    )
    wrapped_packet_900.add_metadata(
        &#34;bestLatency&#34;, str(timing_info_m.get_best_latency())
    )
    wrapped_packet_900.add_metadata(&#34;bestOffset&#34;, str(timing_info_m.get_best_offset()))
    wrapped_packet_900.add_metadata(&#34;migrated_from_api_1000&#34;, f&#34;v{redvox.VERSION}&#34;)

    # Sensors
    if audio_m is not None:
        denorm_audio = list(
            map(_denormalize_audio_count, audio_m.get_samples().get_values())
        )
        mic_900 = reader_900.MicrophoneSensor()
        mic_900.set_sample_rate_hz(audio_m.get_sample_rate())
        mic_900.set_first_sample_timestamp_epoch_microseconds_utc(
            round(audio_m.get_first_sample_timestamp())
        )
        mic_900.set_sensor_name(audio_m.get_sensor_description())
        mic_900.set_metadata_as_dict(audio_m.get_metadata().get_metadata())
        mic_900.set_payload_values(denorm_audio)
        wrapped_packet_900.set_microphone_sensor(mic_900)

    pressure_m = sensors_m.get_pressure()
    if pressure_m is not None:
        barometer_900 = reader_900.BarometerSensor()
        barometer_900.set_sensor_name(pressure_m.get_sensor_description())
        barometer_900.set_metadata_as_dict(pressure_m.get_metadata().get_metadata())
        barometer_900.set_timestamps_microseconds_utc(
            pressure_m.get_timestamps().get_timestamps().astype(np.int64)
        )
        barometer_900.set_payload_values(pressure_m.get_samples().get_values())
        wrapped_packet_900.set_barometer_sensor(barometer_900)

    location_m = sensors_m.get_location()
    if location_m is not None:
        location_900 = reader_900.LocationSensor()
        location_900.set_sensor_name(location_m.get_sensor_description())
        location_900.set_timestamps_microseconds_utc(
            location_m.get_timestamps().get_timestamps().astype(np.int64)
        )
        location_900.set_payload_values(
            location_m.get_latitude_samples().get_values(),
            location_m.get_longitude_samples().get_values(),
            location_m.get_altitude_samples().get_values(),
            location_m.get_speed_samples().get_values(),
            location_m.get_horizontal_accuracy_samples().get_values(),
        )
        wrapped_packet_900.set_location_sensor(location_900)
        metadata = location_m.get_metadata().get_metadata()
        metadata[&#34;useLocation&#34;] = (
            &#34;T&#34; if location_m.get_location_services_enabled() else &#34;F&#34;
        )
        metadata[&#34;desiredLocation&#34;] = (
            &#34;T&#34; if location_m.get_location_services_requested() else &#34;F&#34;
        )
        metadata[&#34;permissionLocation&#34;] = (
            &#34;T&#34; if location_m.get_location_permissions_granted() else &#34;F&#34;
        )
        metadata[&#34;enabledLocation&#34;] = (
            &#34;T&#34;
            if LocationProvider.GPS in location_m.get_location_providers().get_values()
            else &#34;FD&#34;
        )
        location_900.set_metadata_as_dict(metadata)

    # Synch exchanges
    synch_exchanges_m = timing_info_m.get_synch_exchanges()
    if synch_exchanges_m.get_count() &gt; 0:
        synch_900 = reader_900.TimeSynchronizationSensor()
        values: List[int] = []

        for exchange in synch_exchanges_m.get_values():
            values.extend(
                [
                    round(exchange.get_a1()),
                    round(exchange.get_a2()),
                    round(exchange.get_a3()),
                    round(exchange.get_b1()),
                    round(exchange.get_b2()),
                    round(exchange.get_b3()),
                ]
            )

        synch_900.set_payload_values(values)
        wrapped_packet_900.set_time_synchronization_sensor(synch_900)

    accel_m = sensors_m.get_accelerometer()
    if accel_m is not None:
        accel_900 = reader_900.AccelerometerSensor()
        accel_900.set_sensor_name(accel_m.get_sensor_description())
        accel_900.set_timestamps_microseconds_utc(
            accel_m.get_timestamps().get_timestamps().astype(np.int64)
        )
        accel_900.set_metadata_as_dict(accel_m.get_metadata().get_metadata())
        accel_900.set_payload_values(
            accel_m.get_x_samples().get_values(),
            accel_m.get_y_samples().get_values(),
            accel_m.get_z_samples().get_values(),
        )
        wrapped_packet_900.set_accelerometer_sensor(accel_900)

    magnetometer_m = sensors_m.get_magnetometer()
    if magnetometer_m is not None:
        magnetometer_900 = reader_900.MagnetometerSensor()
        magnetometer_900.set_sensor_name(magnetometer_m.get_sensor_description())
        magnetometer_900.set_timestamps_microseconds_utc(
            magnetometer_m.get_timestamps().get_timestamps().astype(np.int64)
        )
        magnetometer_900.set_metadata_as_dict(
            magnetometer_m.get_metadata().get_metadata()
        )
        magnetometer_900.set_payload_values(
            magnetometer_m.get_x_samples().get_values(),
            magnetometer_m.get_y_samples().get_values(),
            magnetometer_m.get_z_samples().get_values(),
        )
        wrapped_packet_900.set_magnetometer_sensor(magnetometer_900)

    gyroscope_m = sensors_m.get_gyroscope()
    if gyroscope_m is not None:
        gyroscope_900 = reader_900.GyroscopeSensor()
        gyroscope_900.set_sensor_name(gyroscope_m.get_sensor_description())
        gyroscope_900.set_timestamps_microseconds_utc(
            gyroscope_m.get_timestamps().get_timestamps().astype(np.int64)
        )
        gyroscope_900.set_metadata_as_dict(gyroscope_m.get_metadata().get_metadata())
        gyroscope_900.set_payload_values(
            gyroscope_m.get_x_samples().get_values(),
            gyroscope_m.get_y_samples().get_values(),
            gyroscope_m.get_z_samples().get_values(),
        )
        wrapped_packet_900.set_gyroscope_sensor(gyroscope_900)

    # Light
    light_m = sensors_m.get_light()
    if light_m is not None:
        light_900 = reader_900.LightSensor()
        light_900.set_sensor_name(light_m.get_sensor_description())
        light_900.set_metadata_as_dict(light_m.get_metadata().get_metadata())
        light_900.set_timestamps_microseconds_utc(
            light_m.get_timestamps().get_timestamps().astype(np.int64)
        )
        light_900.set_payload_values(light_m.get_samples().get_values())
        wrapped_packet_900.set_light_sensor(light_900)

    # Image, skip for now

    # Infrared / proximity
    proximity_m = sensors_m.get_proximity()
    if proximity_m is not None:
        proximity_900 = reader_900.InfraredSensor()
        proximity_900.set_sensor_name(proximity_m.get_sensor_description())
        proximity_900.set_metadata_as_dict(proximity_m.get_metadata().get_metadata())
        proximity_900.set_timestamps_microseconds_utc(
            proximity_m.get_timestamps().get_timestamps().astype(np.int64)
        )
        proximity_900.set_payload_values(proximity_m.get_samples().get_values())
        wrapped_packet_900.set_infrared_sensor(proximity_900)

    return wrapped_packet_900</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="redvox.common.api_conversions.compute_stats_raw"><code class="name flex">
<span>def <span class="ident">compute_stats_raw</span></span>(<span>has_stats: Union[src.redvox_api_m.redvox_api_m_pb2.TimingPayload, src.redvox_api_m.redvox_api_m_pb2.SamplePayload, src.redvox_api_m.redvox_api_m_pb2.DoubleSamplePayload])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_stats_raw(
    has_stats: Union[
        api_m.RedvoxPacketM.TimingPayload,
        api_m.RedvoxPacketM.SamplePayload,
        api_m.RedvoxPacketM.DoubleSamplePayload,
    ]
):
    values: np.ndarray
    stats_container: api_m.RedvoxPacketM.SummaryStatistics
    if isinstance(has_stats, api_m.RedvoxPacketM.TimingPayload):
        values = np.array(has_stats.timestamps)
        stats_container = has_stats.timestamp_statistics
        mean_sr: float
        std_sr: float
        (mean_sr, std_sr) = common_m.sampling_rate_statistics(values)
        has_stats.mean_sample_rate = mean_sr
        has_stats.stdev_sample_rate = std_sr
    else:
        values = np.array(has_stats.values)
        stats_container = has_stats.value_statistics

    stats_container.count = len(values)
    # noinspection Mypy
    stats_container.min = values.min()
    # noinspection Mypy
    stats_container.max = values.max()
    # noinspection Mypy
    stats_container.mean = values.mean()
    # noinspection Mypy
    stats_container.standard_deviation = values.std()</code></pre>
</details>
</dd>
<dt id="redvox.common.api_conversions.convert_api_1000_to_900"><code class="name flex">
<span>def <span class="ident">convert_api_1000_to_900</span></span>(<span>wrapped_packet_m: <a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="../api900/wrapped_redvox_packet.html#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>Converts an API M wrapped packet into an API 900 wrapped packet.</p>
<p>:param wrapped_packet_m: Packet to convert.
:return: An API 900 wrapped packet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_api_1000_to_900(
    wrapped_packet_m: WrappedRedvoxPacketM,
) -&gt; reader_900.WrappedRedvoxPacket:
    &#34;&#34;&#34;
    Converts an API M wrapped packet into an API 900 wrapped packet.

    :param wrapped_packet_m: Packet to convert.
    :return: An API 900 wrapped packet.
    &#34;&#34;&#34;
    # TODO detect and warn about all the fields that are being dropped due to conversion!
    wrapped_packet_900: reader_900.WrappedRedvoxPacket = (
        reader_900.WrappedRedvoxPacket()
    )

    station_information_m = wrapped_packet_m.get_station_information()
    sensors_m = wrapped_packet_m.get_sensors()
    audio_m = sensors_m.get_audio()

    wrapped_packet_900.set_api(900)
    wrapped_packet_900.set_uuid(station_information_m.get_uuid())
    wrapped_packet_900.set_redvox_id(station_information_m.get_id())
    wrapped_packet_900.set_authenticated_email(station_information_m.get_auth_id())
    wrapped_packet_900.set_authentication_token(
        &#34;n/a&#34;
    )  # Different auth protocols are used, can&#39;t convert between
    wrapped_packet_900.set_firebase_token(&#34;n/a&#34;)  # No longer in API M packet
    wrapped_packet_900.set_is_backfilled(False)  # No longer useful metric in API M
    wrapped_packet_900.set_is_private(station_information_m.get_is_private())
    wrapped_packet_900.set_is_scrambled(False)
    wrapped_packet_900.set_device_make(station_information_m.get_make())
    wrapped_packet_900.set_device_model(station_information_m.get_model())
    wrapped_packet_900.set_device_os(
        _migrate_os_type_1000_to_900(station_information_m.get_os())
    )
    wrapped_packet_900.set_device_os_version(station_information_m.get_os_version())
    wrapped_packet_900.set_app_version(station_information_m.get_app_version())

    battery_metrics = station_information_m.get_station_metrics().get_battery()
    battery_percent: float = (
        battery_metrics.get_values()[-1]
        if battery_metrics.get_values_count() &gt; 0
        else 0.0
    )
    wrapped_packet_900.set_battery_level_percent(battery_percent)
    temp_metrics = station_information_m.get_station_metrics().get_temperature()
    device_temp: float = (
        temp_metrics.get_values()[-1] if temp_metrics.get_values_count() &gt; 0 else 0.0
    )
    wrapped_packet_900.set_device_temperature_c(device_temp)

    server_info_m = wrapped_packet_m.get_station_information().get_service_urls()
    wrapped_packet_900.set_acquisition_server(server_info_m.get_acquisition_server())
    wrapped_packet_900.set_time_synchronization_server(server_info_m.get_synch_server())
    wrapped_packet_900.set_authentication_server(server_info_m.get_auth_server())

    timing_info_m = wrapped_packet_m.get_timing_information()
    wrapped_packet_900.set_app_file_start_timestamp_epoch_microseconds_utc(
        round(timing_info_m.get_packet_start_os_timestamp())
    )
    wrapped_packet_900.set_app_file_start_timestamp_machine(
        round(timing_info_m.get_packet_start_mach_timestamp())
    )
    wrapped_packet_900.set_server_timestamp_epoch_microseconds_utc(
        round(timing_info_m.get_server_acquisition_arrival_timestamp())
    )

    # Top-level metadata
    wrapped_packet_900.add_metadata(
        &#34;machTimeZero&#34;, str(timing_info_m.get_app_start_mach_timestamp())
    )
    wrapped_packet_900.add_metadata(
        &#34;bestLatency&#34;, str(timing_info_m.get_best_latency())
    )
    wrapped_packet_900.add_metadata(&#34;bestOffset&#34;, str(timing_info_m.get_best_offset()))
    wrapped_packet_900.add_metadata(&#34;migrated_from_api_1000&#34;, f&#34;v{redvox.VERSION}&#34;)

    # Sensors
    if audio_m is not None:
        denorm_audio = list(
            map(_denormalize_audio_count, audio_m.get_samples().get_values())
        )
        mic_900 = reader_900.MicrophoneSensor()
        mic_900.set_sample_rate_hz(audio_m.get_sample_rate())
        mic_900.set_first_sample_timestamp_epoch_microseconds_utc(
            round(audio_m.get_first_sample_timestamp())
        )
        mic_900.set_sensor_name(audio_m.get_sensor_description())
        mic_900.set_metadata_as_dict(audio_m.get_metadata().get_metadata())
        mic_900.set_payload_values(denorm_audio)
        wrapped_packet_900.set_microphone_sensor(mic_900)

    pressure_m = sensors_m.get_pressure()
    if pressure_m is not None:
        barometer_900 = reader_900.BarometerSensor()
        barometer_900.set_sensor_name(pressure_m.get_sensor_description())
        barometer_900.set_metadata_as_dict(pressure_m.get_metadata().get_metadata())
        barometer_900.set_timestamps_microseconds_utc(
            pressure_m.get_timestamps().get_timestamps().astype(np.int64)
        )
        barometer_900.set_payload_values(pressure_m.get_samples().get_values())
        wrapped_packet_900.set_barometer_sensor(barometer_900)

    location_m = sensors_m.get_location()
    if location_m is not None:
        location_900 = reader_900.LocationSensor()
        location_900.set_sensor_name(location_m.get_sensor_description())
        location_900.set_timestamps_microseconds_utc(
            location_m.get_timestamps().get_timestamps().astype(np.int64)
        )
        location_900.set_payload_values(
            location_m.get_latitude_samples().get_values(),
            location_m.get_longitude_samples().get_values(),
            location_m.get_altitude_samples().get_values(),
            location_m.get_speed_samples().get_values(),
            location_m.get_horizontal_accuracy_samples().get_values(),
        )
        wrapped_packet_900.set_location_sensor(location_900)
        metadata = location_m.get_metadata().get_metadata()
        metadata[&#34;useLocation&#34;] = (
            &#34;T&#34; if location_m.get_location_services_enabled() else &#34;F&#34;
        )
        metadata[&#34;desiredLocation&#34;] = (
            &#34;T&#34; if location_m.get_location_services_requested() else &#34;F&#34;
        )
        metadata[&#34;permissionLocation&#34;] = (
            &#34;T&#34; if location_m.get_location_permissions_granted() else &#34;F&#34;
        )
        metadata[&#34;enabledLocation&#34;] = (
            &#34;T&#34;
            if LocationProvider.GPS in location_m.get_location_providers().get_values()
            else &#34;FD&#34;
        )
        location_900.set_metadata_as_dict(metadata)

    # Synch exchanges
    synch_exchanges_m = timing_info_m.get_synch_exchanges()
    if synch_exchanges_m.get_count() &gt; 0:
        synch_900 = reader_900.TimeSynchronizationSensor()
        values: List[int] = []

        for exchange in synch_exchanges_m.get_values():
            values.extend(
                [
                    round(exchange.get_a1()),
                    round(exchange.get_a2()),
                    round(exchange.get_a3()),
                    round(exchange.get_b1()),
                    round(exchange.get_b2()),
                    round(exchange.get_b3()),
                ]
            )

        synch_900.set_payload_values(values)
        wrapped_packet_900.set_time_synchronization_sensor(synch_900)

    accel_m = sensors_m.get_accelerometer()
    if accel_m is not None:
        accel_900 = reader_900.AccelerometerSensor()
        accel_900.set_sensor_name(accel_m.get_sensor_description())
        accel_900.set_timestamps_microseconds_utc(
            accel_m.get_timestamps().get_timestamps().astype(np.int64)
        )
        accel_900.set_metadata_as_dict(accel_m.get_metadata().get_metadata())
        accel_900.set_payload_values(
            accel_m.get_x_samples().get_values(),
            accel_m.get_y_samples().get_values(),
            accel_m.get_z_samples().get_values(),
        )
        wrapped_packet_900.set_accelerometer_sensor(accel_900)

    magnetometer_m = sensors_m.get_magnetometer()
    if magnetometer_m is not None:
        magnetometer_900 = reader_900.MagnetometerSensor()
        magnetometer_900.set_sensor_name(magnetometer_m.get_sensor_description())
        magnetometer_900.set_timestamps_microseconds_utc(
            magnetometer_m.get_timestamps().get_timestamps().astype(np.int64)
        )
        magnetometer_900.set_metadata_as_dict(
            magnetometer_m.get_metadata().get_metadata()
        )
        magnetometer_900.set_payload_values(
            magnetometer_m.get_x_samples().get_values(),
            magnetometer_m.get_y_samples().get_values(),
            magnetometer_m.get_z_samples().get_values(),
        )
        wrapped_packet_900.set_magnetometer_sensor(magnetometer_900)

    gyroscope_m = sensors_m.get_gyroscope()
    if gyroscope_m is not None:
        gyroscope_900 = reader_900.GyroscopeSensor()
        gyroscope_900.set_sensor_name(gyroscope_m.get_sensor_description())
        gyroscope_900.set_timestamps_microseconds_utc(
            gyroscope_m.get_timestamps().get_timestamps().astype(np.int64)
        )
        gyroscope_900.set_metadata_as_dict(gyroscope_m.get_metadata().get_metadata())
        gyroscope_900.set_payload_values(
            gyroscope_m.get_x_samples().get_values(),
            gyroscope_m.get_y_samples().get_values(),
            gyroscope_m.get_z_samples().get_values(),
        )
        wrapped_packet_900.set_gyroscope_sensor(gyroscope_900)

    # Light
    light_m = sensors_m.get_light()
    if light_m is not None:
        light_900 = reader_900.LightSensor()
        light_900.set_sensor_name(light_m.get_sensor_description())
        light_900.set_metadata_as_dict(light_m.get_metadata().get_metadata())
        light_900.set_timestamps_microseconds_utc(
            light_m.get_timestamps().get_timestamps().astype(np.int64)
        )
        light_900.set_payload_values(light_m.get_samples().get_values())
        wrapped_packet_900.set_light_sensor(light_900)

    # Image, skip for now

    # Infrared / proximity
    proximity_m = sensors_m.get_proximity()
    if proximity_m is not None:
        proximity_900 = reader_900.InfraredSensor()
        proximity_900.set_sensor_name(proximity_m.get_sensor_description())
        proximity_900.set_metadata_as_dict(proximity_m.get_metadata().get_metadata())
        proximity_900.set_timestamps_microseconds_utc(
            proximity_m.get_timestamps().get_timestamps().astype(np.int64)
        )
        proximity_900.set_payload_values(proximity_m.get_samples().get_values())
        wrapped_packet_900.set_infrared_sensor(proximity_900)

    return wrapped_packet_900</code></pre>
</details>
</dd>
<dt id="redvox.common.api_conversions.convert_api_900_to_1000"><code class="name flex">
<span>def <span class="ident">convert_api_900_to_1000</span></span>(<span>wrapped_packet_900: <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="../api900/wrapped_redvox_packet.html#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a>) ‑> <a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a></span>
</code></dt>
<dd>
<div class="desc"><p>Converts a wrapped API 900 packet into a wrapped API M packet.</p>
<p>:param wrapped_packet_900: API 900 packet to convert.
:return: A wrapped API M packet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_api_900_to_1000(
    wrapped_packet_900: reader_900.WrappedRedvoxPacket,
) -&gt; WrappedRedvoxPacketM:
    &#34;&#34;&#34;
    Converts a wrapped API 900 packet into a wrapped API M packet.

    :param wrapped_packet_900: API 900 packet to convert.
    :return: A wrapped API M packet.
    &#34;&#34;&#34;
    wrapped_packet_m: WrappedRedvoxPacketM = WrappedRedvoxPacketM.new()

    # Top-level metadata
    wrapped_packet_m.set_api(1000.0)
    # noinspection PyUnresolvedReferences,Mypy
    wrapped_packet_m.set_sub_api(api_m.SUB_API)

    # Station information
    station_information: StationInformation = wrapped_packet_m.get_station_information()
    station_information.set_id(wrapped_packet_900.redvox_id()).set_uuid(
        wrapped_packet_900.uuid()
    ).set_make(wrapped_packet_900.device_make()).set_model(
        wrapped_packet_900.device_model()
    ).set_os(
        _migrate_os_type_900_to_1000(wrapped_packet_900.device_os())
    ).set_os_version(
        wrapped_packet_900.device_os_version()
    ).set_app_version(
        wrapped_packet_900.app_version()
    ).set_is_private(
        wrapped_packet_900.is_private()
    )

    station_information.get_service_urls().set_acquisition_server(
        wrapped_packet_900.acquisition_server()
    ).set_synch_server(
        wrapped_packet_900.time_synchronization_server()
    ).set_auth_server(
        wrapped_packet_900.authentication_server()
    )

    # API 900 does not maintain a copy of its settings. So we will not set anything in AppSettings

    # StationMetrics - We know a couple. We take a slightly more cumbersome approach using the raw protobuf
    # to avoid some conversions between lists and np arrays.
    station_metrics: StationMetrics = station_information.get_station_metrics()
    station_metrics.get_timestamps().append_timestamp(
        wrapped_packet_900.app_file_start_timestamp_machine()
    )
    station_metrics.get_temperature().set_values(
        np.array([wrapped_packet_900.device_temperature_c()]), True
    )
    station_metrics.get_battery().set_values(
        np.array([wrapped_packet_900.battery_level_percent()]), True
    )

    # Timing information
    mach_time_900: int = wrapped_packet_900.app_file_start_timestamp_machine()
    os_time_900: int = (
        wrapped_packet_900.app_file_start_timestamp_epoch_microseconds_utc()
    )
    len_micros: int = _packet_length_microseconds_900(wrapped_packet_900)
    best_latency: Optional[float] = wrapped_packet_900.best_latency()
    best_latency = best_latency if best_latency is not None else NAN
    best_offset: Optional[float] = wrapped_packet_900.best_offset()
    best_offset = best_offset if best_offset is not None else NAN

    wrapped_packet_m.get_timing_information().set_unit(
        common_m.Unit.MICROSECONDS_SINCE_UNIX_EPOCH
    ).set_packet_start_mach_timestamp(mach_time_900).set_packet_start_os_timestamp(
        os_time_900
    ).set_packet_end_mach_timestamp(
        mach_time_900 + len_micros
    ).set_packet_end_os_timestamp(
        os_time_900 + len_micros
    ).set_server_acquisition_arrival_timestamp(
        wrapped_packet_900.server_timestamp_epoch_microseconds_utc()
    ).set_app_start_mach_timestamp(
        _find_mach_time_zero(wrapped_packet_900)
    ).set_best_latency(
        best_latency
    ).set_best_offset(
        best_offset
    )

    time_sensor = wrapped_packet_900.time_synchronization_sensor()
    if time_sensor is not None:
        wrapped_packet_m.get_timing_information().get_synch_exchanges().set_values(
            _migrate_synch_exchanges_900_to_1000(time_sensor.payload_values())
        )

    # Sensors
    sensors_m: Sensors = wrapped_packet_m.get_sensors()
    # Microphone / Audio
    mic_sensor_900: Optional[
        reader_900.MicrophoneSensor
    ] = wrapped_packet_900.microphone_sensor()
    if mic_sensor_900 is not None:
        normalized_audio: np.ndarray = (
            mic_sensor_900.payload_values() / _NORMALIZATION_CONSTANT
        )
        audio_sensor_m = sensors_m.new_audio()
        audio_sensor_m.set_first_sample_timestamp(
            mic_sensor_900.first_sample_timestamp_epoch_microseconds_utc()
        ).set_is_scrambled(wrapped_packet_900.is_scrambled()).set_sample_rate(
            mic_sensor_900.sample_rate_hz()
        ).set_sensor_description(
            mic_sensor_900.sensor_name()
        ).get_samples().set_values(
            normalized_audio, update_value_statistics=True
        )
        audio_sensor_m.get_metadata().set_metadata(mic_sensor_900.metadata_as_dict())

    # Barometer
    barometer_sensor_900: Optional[
        reader_900.BarometerSensor
    ] = wrapped_packet_900.barometer_sensor()
    if barometer_sensor_900 is not None:
        pressure_sensor_m = sensors_m.new_pressure()
        pressure_sensor_m.set_sensor_description(barometer_sensor_900.sensor_name())
        pressure_sensor_m.get_timestamps().set_timestamps(
            barometer_sensor_900.timestamps_microseconds_utc(), True
        )
        pressure_sensor_m.get_samples().set_values(
            barometer_sensor_900.payload_values(), True
        )
        pressure_sensor_m.get_metadata().set_metadata(
            barometer_sensor_900.metadata_as_dict()
        )

    # Location
    # TODO: rework
    location_sensor_900: Optional[
        reader_900.LocationSensor
    ] = wrapped_packet_900.location_sensor()
    if location_sensor_900 is not None:
        location_m = sensors_m.new_location()
        location_m.set_sensor_description(location_sensor_900.sensor_name())
        location_m.get_timestamps().set_timestamps(
            location_sensor_900.timestamps_microseconds_utc(), True
        )
        if location_sensor_900.check_for_preset_lat_lon():
            lat_lon: np.ndarray = location_sensor_900.get_payload_lat_lon()
            location_m.get_latitude_samples().set_values(lat_lon[:1], True)
            location_m.get_longitude_samples().set_values(lat_lon[1:], True)
        else:
            location_m.get_latitude_samples().set_values(
                location_sensor_900.payload_values_latitude(), True
            )
            location_m.get_longitude_samples().set_values(
                location_sensor_900.payload_values_longitude(), True
            )
            location_m.get_altitude_samples().set_values(
                location_sensor_900.payload_values_altitude(), True
            )
            location_m.get_speed_samples().set_values(
                location_sensor_900.payload_values_speed(), True
            )
            location_m.get_horizontal_accuracy_samples().set_values(
                location_sensor_900.payload_values_accuracy(), True
            )

        def _extract_meta_bool(metad: Dict[str, str], key: str) -&gt; bool:
            if key not in metad:
                return False

            return metad[key] == &#34;T&#34;

        loc_meta_900 = location_sensor_900.metadata_as_dict()
        use_location = _extract_meta_bool(loc_meta_900, &#34;useLocation&#34;)
        desired_location = _extract_meta_bool(loc_meta_900, &#34;desiredLocation&#34;)
        permission_location = _extract_meta_bool(loc_meta_900, &#34;permissionLocation&#34;)
        enabled_location = _extract_meta_bool(loc_meta_900, &#34;enabledLocation&#34;)

        n_p = location_m.get_timestamps().get_timestamps_count()

        if desired_location:
            location_m.get_location_providers().set_values(
                [LocationProvider.USER for i in range(n_p)]
            )
        elif enabled_location:
            location_m.get_location_providers().set_values(
                [LocationProvider.GPS for i in range(n_p)]
            )
        elif use_location and desired_location and permission_location:
            location_m.get_location_providers().set_values(
                [LocationProvider.NETWORK for i in range(n_p)]
            )
        else:
            location_m.get_location_providers().set_values(
                [LocationProvider.NONE for i in range(n_p)]
            )

        location_m.set_location_permissions_granted(permission_location)
        location_m.set_location_services_enabled(use_location)
        location_m.set_location_services_requested(desired_location)

        # Once we&#39;re done here, we should remove the original metadata
        if &#34;useLocation&#34; in loc_meta_900:
            del loc_meta_900[&#34;useLocation&#34;]
        if &#34;desiredLocation&#34; in loc_meta_900:
            del loc_meta_900[&#34;desiredLocation&#34;]
        if &#34;permissionLocation&#34; in loc_meta_900:
            del loc_meta_900[&#34;permissionLocation&#34;]
        if &#34;enabledLocation&#34; in loc_meta_900:
            del loc_meta_900[&#34;enabledLocation&#34;]
        if &#34;machTimeZero&#34; in loc_meta_900:
            del loc_meta_900[&#34;machTimeZero&#34;]
        location_m.get_metadata().set_metadata(loc_meta_900)

    # Time Synchronization
    # This was already added to the timing information

    # Accelerometer
    accelerometer_900 = wrapped_packet_900.accelerometer_sensor()
    if accelerometer_900 is not None:
        accelerometer_m = sensors_m.new_accelerometer()
        accelerometer_m.set_sensor_description(accelerometer_900.sensor_name())
        accelerometer_m.get_timestamps().set_timestamps(
            accelerometer_900.timestamps_microseconds_utc(), True
        )
        accelerometer_m.get_x_samples().set_values(
            accelerometer_900.payload_values_x(), True
        )
        accelerometer_m.get_y_samples().set_values(
            accelerometer_900.payload_values_y(), True
        )
        accelerometer_m.get_z_samples().set_values(
            accelerometer_900.payload_values_z(), True
        )
        accelerometer_m.get_metadata().set_metadata(
            accelerometer_900.metadata_as_dict()
        )

    # Magnetometer
    magnetometer_900 = wrapped_packet_900.magnetometer_sensor()
    if magnetometer_900 is not None:
        magnetometer_m = sensors_m.new_magnetometer()
        magnetometer_m.set_sensor_description(magnetometer_900.sensor_name())
        magnetometer_m.get_timestamps().set_timestamps(
            magnetometer_900.timestamps_microseconds_utc(), True
        )
        magnetometer_m.get_x_samples().set_values(
            magnetometer_900.payload_values_x(), True
        )
        magnetometer_m.get_y_samples().set_values(
            magnetometer_900.payload_values_y(), True
        )
        magnetometer_m.get_z_samples().set_values(
            magnetometer_900.payload_values_z(), True
        )
        magnetometer_m.get_metadata().set_metadata(magnetometer_900.metadata_as_dict())

    # Gyroscope
    gyroscope_900 = wrapped_packet_900.gyroscope_sensor()
    if gyroscope_900 is not None:
        gyroscope_m = sensors_m.new_gyroscope()
        gyroscope_m.set_sensor_description(gyroscope_900.sensor_name())
        gyroscope_m.get_timestamps().set_timestamps(
            gyroscope_900.timestamps_microseconds_utc(), True
        )
        gyroscope_m.get_x_samples().set_values(gyroscope_900.payload_values_x(), True)
        gyroscope_m.get_y_samples().set_values(gyroscope_900.payload_values_y(), True)
        gyroscope_m.get_z_samples().set_values(gyroscope_900.payload_values_z(), True)
        gyroscope_m.get_metadata().set_metadata(gyroscope_900.metadata_as_dict())

    # Light
    light_900 = wrapped_packet_900.light_sensor()
    if light_900 is not None:
        light_m = sensors_m.new_light()
        light_m.set_sensor_description(light_900.sensor_name())
        light_m.get_timestamps().set_timestamps(
            light_900.timestamps_microseconds_utc(), True
        )
        light_m.get_samples().set_values(light_900.payload_values(), True)
        light_m.get_metadata().set_metadata(light_900.metadata_as_dict())

    # Image
    # TODO: Implement

    # Proximity
    proximity_900 = wrapped_packet_900.infrared_sensor()
    if proximity_900 is not None:
        proximity_m = sensors_m.new_proximity()
        proximity_m.set_sensor_description(proximity_900.sensor_name())
        proximity_m.get_timestamps().set_timestamps(
            proximity_900.timestamps_microseconds_utc(), True
        )
        proximity_m.get_samples().set_values(proximity_900.payload_values(), True)
        proximity_m.get_metadata().set_metadata(proximity_900.metadata_as_dict())

    # Removed any other API 900 top-level metadata now that its been used
    meta = wrapped_packet_900.metadata_as_dict()
    if &#34;machTimeZero&#34; in meta:
        del meta[&#34;machTimeZero&#34;]
    if &#34;bestOffset&#34; in meta:
        del meta[&#34;bestOffset&#34;]
    if &#34;bestLatency&#34; in meta:
        del meta[&#34;bestLatency&#34;]
    wrapped_packet_m.get_metadata().append_metadata(
        &#34;migrated_from_api_900&#34;, f&#34;v{redvox.VERSION}&#34;
    )

    return wrapped_packet_m</code></pre>
</details>
</dd>
<dt id="redvox.common.api_conversions.convert_api_900_to_1000_raw"><code class="name flex">
<span>def <span class="ident">convert_api_900_to_1000_raw</span></span>(<span>packet: api900_pb2.RedvoxPacket) ‑> src.redvox_api_m.redvox_api_m_pb2.RedvoxPacketM</span>
</code></dt>
<dd>
<div class="desc"><p>Converts a wrapped API 900 packet into a wrapped API M packet.</p>
<p>:param packet: API 900 packet to convert.
:return: A wrapped API M packet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_api_900_to_1000_raw(packet: api_900.RedvoxPacket) -&gt; api_m.RedvoxPacketM:
    &#34;&#34;&#34;
    Converts a wrapped API 900 packet into a wrapped API M packet.

    :param packet: API 900 packet to convert.
    :return: A wrapped API M packet.
    &#34;&#34;&#34;
    packet_m: api_m.RedvoxPacketM = api_m.RedvoxPacketM()

    # Top-level metadata
    packet_m.api = 1000.0
    # noinspection PyUnresolvedReferences,Mypy
    packet_m.sub_api = api_m.SUB_API

    # Station information
    packet_m.station_information.id = packet.redvox_id
    packet_m.station_information.uuid = packet.uuid
    packet_m.station_information.make = packet.device_make
    packet_m.station_information.model = packet.device_model
    packet_m.station_information.os = _migrate_os_type_900_to_1000_raw(packet.device_os)
    packet_m.station_information.os_version = packet.device_os_version
    packet_m.station_information.app_version = packet.app_version
    packet_m.station_information.is_private = packet.is_private

    packet_m.station_information.app_settings.samples_per_window = \
        len(packet.evenly_sampled_channels[0].int32_payload.payload)

    packet_m.station_information.service_urls.acquisition_server = (
        packet.acquisition_server
    )
    packet_m.station_information.service_urls.synch_server = (
        packet.time_synchronization_server
    )
    packet_m.station_information.service_urls.auth_server = packet.authentication_server

    # API 900 does not maintain a copy of its settings. So we will not set anything in AppSettings

    # StationMetrics - We know a couple.
    packet_m.station_information.station_metrics.timestamps.unit = (
        api_m.RedvoxPacketM.Unit.MICROSECONDS_SINCE_UNIX_EPOCH
    )
    packet_m.station_information.station_metrics.timestamps.timestamps[:] = [
        packet.app_file_start_timestamp_machine
    ]
    packet_m.station_information.station_metrics.temperature.unit = (
        api_m.RedvoxPacketM.Unit.DEGREES_CELSIUS
    )
    packet_m.station_information.station_metrics.temperature.values[:] = [
        packet.device_temperature_c
    ]
    packet_m.station_information.station_metrics.battery.unit = (
        api_m.RedvoxPacketM.Unit.PERCENTAGE
    )
    packet_m.station_information.station_metrics.battery.values[:] = [
        packet.battery_level_percent
    ]

    # And we can fill in defaults for those we don&#39;t know
    packet_m.station_information.station_metrics.available_disk.unit = (
        api_m.RedvoxPacketM.Unit.BYTE
    )
    packet_m.station_information.station_metrics.available_disk.values[:] = [
        float(&#34;nan&#34;)
    ]
    packet_m.station_information.station_metrics.available_ram.unit = (
        api_m.RedvoxPacketM.Unit.BYTE
    )
    packet_m.station_information.station_metrics.available_ram.values[:] = [
        float(&#34;nan&#34;)
    ]
    packet_m.station_information.station_metrics.cpu_utilization.unit = (
        api_m.RedvoxPacketM.Unit.PERCENTAGE
    )
    packet_m.station_information.station_metrics.cpu_utilization.values[:] = [
        float(&#34;nan&#34;)
    ]
    packet_m.station_information.station_metrics.network_strength.unit = (
        api_m.RedvoxPacketM.Unit.DECIBEL
    )
    packet_m.station_information.station_metrics.network_strength.values[:] = [
        float(&#34;nan&#34;)
    ]
    packet_m.station_information.station_metrics.battery_current.unit = (
        api_m.RedvoxPacketM.Unit.MICROAMPERES
    )
    packet_m.station_information.station_metrics.battery_current.values[:] = [
        float(&#34;nan&#34;)
    ]
    packet_m.station_information.station_metrics.screen_brightness.unit = (
        api_m.RedvoxPacketM.Unit.PERCENTAGE
    )
    packet_m.station_information.station_metrics.screen_brightness.values[:] = [
        float(&#34;nan&#34;)
    ]

    packet_m.station_information.station_metrics.network_type[:] = [
        api_m.RedvoxPacketM.StationInformation.StationMetrics.NetworkType.UNKNOWN_NETWORK
    ]
    packet_m.station_information.station_metrics.cell_service_state[:] = [
        api_m.RedvoxPacketM.StationInformation.StationMetrics.CellServiceState.UNKNOWN
    ]
    packet_m.station_information.station_metrics.power_state[:] = [
        api_m.RedvoxPacketM.StationInformation.StationMetrics.PowerState.UNKNOWN_POWER_STATE
    ]
    packet_m.station_information.station_metrics.wifi_wake_lock[:] = [
        api_m.RedvoxPacketM.StationInformation.StationMetrics.WifiWakeLock.OTHER
    ]
    packet_m.station_information.station_metrics.screen_state[:] = [
        api_m.RedvoxPacketM.StationInformation.StationMetrics.ScreenState.UNKNOWN_SCREEN_STATE
    ]

    compute_stats_raw(packet_m.station_information.station_metrics.timestamps)
    compute_stats_raw(packet_m.station_information.station_metrics.temperature)
    compute_stats_raw(packet_m.station_information.station_metrics.battery)
    compute_stats_raw(packet_m.station_information.station_metrics.available_disk)
    compute_stats_raw(packet_m.station_information.station_metrics.available_ram)
    compute_stats_raw(packet_m.station_information.station_metrics.cpu_utilization)
    compute_stats_raw(packet_m.station_information.station_metrics.network_strength)
    compute_stats_raw(packet_m.station_information.station_metrics.battery_current)
    compute_stats_raw(packet_m.station_information.station_metrics.screen_brightness)

    # Timing information
    mach_time_900: int = packet.app_file_start_timestamp_machine
    os_time_900: int = packet.app_file_start_timestamp_epoch_microseconds_utc
    len_micros: int = _packet_length_microseconds_900_raw(packet)
    best_latency: float = reader_utils.get_metadata_or_default(
        list(packet.metadata), &#34;bestLatency&#34;, float, NAN
    )
    best_offset: float = reader_utils.get_metadata_or_default(
        list(packet.metadata), &#34;bestOffset&#34;, float, NAN
    )

    packet_m.timing_information.unit = (
        api_m.RedvoxPacketM.Unit.MICROSECONDS_SINCE_UNIX_EPOCH
    )
    packet_m.timing_information.packet_start_mach_timestamp = mach_time_900
    packet_m.timing_information.packet_start_os_timestamp = os_time_900
    packet_m.timing_information.packet_end_mach_timestamp = mach_time_900 + len_micros
    packet_m.timing_information.server_acquisition_arrival_timestamp = (
        packet.server_timestamp_epoch_microseconds_utc
    )
    packet_m.timing_information.packet_end_os_timestamp = os_time_900 + len_micros
    packet_m.timing_information.app_start_mach_timestamp = _find_mach_time_zero_raw(
        packet
    )
    packet_m.timing_information.best_latency = best_latency
    packet_m.timing_information.best_offset = best_offset

    synch_sensor: Optional[
        api_900.UnevenlySampledChannel
    ] = reader_utils.find_uneven_channel_raw(
        packet, {api_900.ChannelType.TIME_SYNCHRONIZATION}
    )
    if synch_sensor is not None:
        synch_payload: np.ndarray = reader_utils.extract_payload(synch_sensor)
        packet_m.timing_information.synch_exchanges.extend(
            _migrate_synch_exchanges_900_to_1000_raw(synch_payload)
        )

    # Sensors
    # Microphone / Audio
    if len(packet.evenly_sampled_channels) &lt; 1:
        raise ValueError(&#34;Cannot convert API900 to API1000; Audio sensor missing.&#34;)
    audio_900: api_900.EvenlySampledChannel = packet.evenly_sampled_channels[0]
    packet_m.sensors.audio.sensor_description = audio_900.sensor_name
    packet_m.sensors.audio.sample_rate = audio_900.sample_rate_hz
    packet_m.sensors.audio.first_sample_timestamp = (
        audio_900.first_sample_timestamp_epoch_microseconds_utc
    )
    packet_m.sensors.audio.bits_of_precision = 16.0
    packet_m.sensors.audio.encoding = &#34;counts&#34;
    normalized_audio: np.ndarray = (
        reader_utils.extract_payload(audio_900) / _NORMALIZATION_CONSTANT
    )
    packet_m.sensors.audio.samples.values[:] = list(normalized_audio)
    packet_m.sensors.audio.samples.unit = api_m.RedvoxPacketM.Unit.NORMALIZED_COUNTS
    for i in range(0, len(audio_900.metadata), 2):
        v: str = audio_900.metadata[i + 1] if (i + 1) &lt; len(audio_900.metadata) else &#34;&#34;
        packet_m.sensors.audio.metadata[audio_900.metadata[i]] = v
    compute_stats_raw(packet_m.sensors.audio.samples)

    # Pressure
    barometer_900: Optional[
        api_900.UnevenlySampledChannel
    ] = reader_utils.find_uneven_channel_raw(packet, {api_900.ChannelType.BAROMETER})
    if barometer_900 is not None:
        packet_m.sensors.pressure.sensor_description = barometer_900.sensor_name
        packet_m.sensors.pressure.timestamps.unit = (
            api_m.RedvoxPacketM.Unit.MICROSECONDS_SINCE_UNIX_EPOCH
        )
        packet_m.sensors.pressure.timestamps.timestamps[
            :
        ] = barometer_900.timestamps_microseconds_utc
        packet_m.sensors.pressure.samples.values[:] = list(
            reader_utils.extract_payload(barometer_900)
        )
        packet_m.sensors.pressure.samples.unit = api_m.RedvoxPacketM.Unit.KILOPASCAL
        for i in range(0, len(barometer_900.metadata), 2):
            v = (
                barometer_900.metadata[i + 1]
                if (i + 1) &lt; len(barometer_900.metadata)
                else &#34;&#34;
            )
            packet_m.sensors.pressure.metadata[barometer_900.metadata[i]] = v
        compute_stats_raw(packet_m.sensors.pressure.timestamps)
        compute_stats_raw(packet_m.sensors.pressure.samples)

    # Location
    loc_900: Optional[
        api_900.UnevenlySampledChannel
    ] = reader_utils.find_uneven_channel_raw(
        packet,
        {
            api_900.ChannelType.LATITUDE,
            api_900.ChannelType.LONGITUDE,
            api_900.ChannelType.ALTITUDE,
            api_900.ChannelType.SPEED,
            api_900.ChannelType.ACCURACY,
        },
    )
    if loc_900 is not None:
        total_samples: int = len(loc_900.timestamps_microseconds_utc)
        loc_payload: List[float] = list(reader_utils.extract_payload(loc_900))
        packet_m.sensors.location.sensor_description = loc_900.sensor_name
        packet_m.sensors.location.timestamps.unit = (
            api_m.RedvoxPacketM.Unit.MICROSECONDS_SINCE_UNIX_EPOCH
        )
        packet_m.sensors.location.timestamps.timestamps[
            :
        ] = loc_900.timestamps_microseconds_utc
        packet_m.sensors.location.timestamps_gps.unit = (
            api_m.RedvoxPacketM.Unit.MICROSECONDS_SINCE_UNIX_EPOCH
        )
        packet_m.sensors.location.timestamps_gps.timestamps[:] = [
            float(&#34;nan&#34;)
        ] * total_samples

        total_channels: int = len(loc_900.channel_types)

        lat_idx: Optional[int] = reader_utils.extract_uneven_payload_idx_raw(
            packet, api_900.ChannelType.LATITUDE
        )
        packet_m.sensors.location.latitude_samples.unit = (
            api_m.RedvoxPacketM.Unit.DECIMAL_DEGREES
        )
        if lat_idx is not None:
            packet_m.sensors.location.latitude_samples.values[:] = loc_payload[
                lat_idx::total_channels
            ]
        else:
            packet_m.sensors.location.latitude_samples.values[:] = [
                float(&#34;nan&#34;) * total_samples
            ]

        lng_idx: Optional[int] = reader_utils.extract_uneven_payload_idx_raw(
            packet, api_900.ChannelType.LONGITUDE
        )
        packet_m.sensors.location.longitude_samples.unit = (
            api_m.RedvoxPacketM.Unit.DECIMAL_DEGREES
        )
        if lng_idx is not None:
            packet_m.sensors.location.longitude_samples.values[:] = loc_payload[
                lng_idx::total_channels
            ]
        else:
            packet_m.sensors.location.longitude_samples.values[:] = [
                float(&#34;nan&#34;) * total_samples
            ]

        alt_idx: Optional[int] = reader_utils.extract_uneven_payload_idx_raw(
            packet, api_900.ChannelType.ALTITUDE
        )
        packet_m.sensors.location.altitude_samples.unit = (
            api_m.RedvoxPacketM.Unit.METERS
        )
        if alt_idx is not None:
            packet_m.sensors.location.altitude_samples.values[:] = loc_payload[
                alt_idx::total_channels
            ]
        else:
            packet_m.sensors.location.altitude_samples.values[:] = [
                float(&#34;nan&#34;) * total_samples
            ]

        speed_idx: Optional[int] = reader_utils.extract_uneven_payload_idx_raw(
            packet, api_900.ChannelType.SPEED
        )
        packet_m.sensors.location.speed_samples.unit = (
            api_m.RedvoxPacketM.Unit.METERS_PER_SECOND
        )
        if speed_idx is not None:
            packet_m.sensors.location.speed_samples.values[:] = loc_payload[
                speed_idx::total_channels
            ]
        else:
            packet_m.sensors.location.speed_samples.values[:] = [
                float(&#34;nan&#34;) * total_samples
            ]

        acc_idx: Optional[int] = reader_utils.extract_uneven_payload_idx_raw(
            packet, api_900.ChannelType.ACCURACY
        )
        packet_m.sensors.location.horizontal_accuracy_samples.unit = (
            api_m.RedvoxPacketM.Unit.METERS
        )
        if acc_idx is not None:
            packet_m.sensors.location.horizontal_accuracy_samples.values[
                :
            ] = loc_payload[acc_idx::total_channels]
        else:
            packet_m.sensors.location.horizontal_accuracy_samples.values[:] = [
                float(&#34;nan&#34;) * total_samples
            ]

        packet_m.sensors.location.bearing_samples.unit = (
            api_m.RedvoxPacketM.Unit.DECIMAL_DEGREES
        )
        packet_m.sensors.location.bearing_samples.values[:] = [
            float(&#34;nan&#34;) * total_samples
        ]

        packet_m.sensors.location.vertical_accuracy_samples.unit = (
            api_m.RedvoxPacketM.Unit.METERS
        )
        packet_m.sensors.location.vertical_accuracy_samples.values[:] = [
            float(&#34;nan&#34;) * total_samples
        ]
        packet_m.sensors.location.speed_accuracy_samples.unit = (
            api_m.RedvoxPacketM.Unit.METERS_PER_SECOND
        )
        packet_m.sensors.location.speed_accuracy_samples.values[:] = [
            float(&#34;nan&#34;) * total_samples
        ]
        packet_m.sensors.location.bearing_accuracy_samples.unit = (
            api_m.RedvoxPacketM.Unit.DECIMAL_DEGREES
        )
        packet_m.sensors.location.bearing_accuracy_samples.values[:] = [
            float(&#34;nan&#34;) * total_samples
        ]

        # Compute stats
        compute_stats_raw(packet_m.sensors.location.timestamps)
        compute_stats_raw(packet_m.sensors.location.timestamps_gps)
        compute_stats_raw(packet_m.sensors.location.latitude_samples)
        compute_stats_raw(packet_m.sensors.location.longitude_samples)
        compute_stats_raw(packet_m.sensors.location.altitude_samples)
        compute_stats_raw(packet_m.sensors.location.speed_samples)
        compute_stats_raw(packet_m.sensors.location.bearing_samples)
        compute_stats_raw(packet_m.sensors.location.horizontal_accuracy_samples)
        compute_stats_raw(packet_m.sensors.location.vertical_accuracy_samples)
        compute_stats_raw(packet_m.sensors.location.speed_accuracy_samples)
        compute_stats_raw(packet_m.sensors.location.bearing_accuracy_samples)

        # Bookkeeping
        use_location: bool = reader_utils.get_metadata_or_default(
            list(loc_900.metadata), &#34;useLocation&#34;, lambda val: v == &#34;T&#34;, False
        )
        desired_location: bool = reader_utils.get_metadata_or_default(
            list(loc_900.metadata), &#34;desiredLocation&#34;, lambda val: v == &#34;T&#34;, False
        )
        permission_location: bool = reader_utils.get_metadata_or_default(
            list(loc_900.metadata), &#34;permissionLocation&#34;, lambda val: v == &#34;T&#34;, False
        )
        enabled_location: bool = reader_utils.get_metadata_or_default(
            list(loc_900.metadata), &#34;enabledLocation&#34;, lambda val: v == &#34;T&#34;, False
        )

        if desired_location:
            packet_m.sensors.location.location_providers[:] = [
                api_m.RedvoxPacketM.Sensors.Location.LocationProvider.USER
            ] * total_samples
        elif enabled_location:
            packet_m.sensors.location.location_providers[:] = [
                api_m.RedvoxPacketM.Sensors.Location.LocationProvider.GPS
            ] * total_samples
        elif use_location and desired_location and permission_location:
            packet_m.sensors.location.location_providers[:] = [
                api_m.RedvoxPacketM.Sensors.Location.LocationProvider.NETWORK
            ] * total_samples
        else:
            packet_m.sensors.location.location_providers[:] = [
                api_m.RedvoxPacketM.Sensors.Location.LocationProvider.NONE
            ] * total_samples

        packet_m.sensors.location.location_permissions_granted = permission_location
        packet_m.sensors.location.location_services_enabled = use_location
        packet_m.sensors.location.location_services_requested = desired_location

        for (i, k) in enumerate(loc_900.metadata):
            if i + 1 &lt; len(loc_900.metadata):
                packet_m.sensors.location.metadata[k] = loc_900.metadata[i + 1]
            else:
                packet_m.sensors.location.metadata[k] = &#34;&#34;

    # # Time Synchronization
    # # This was already added to the timing information

    # Accelerometer
    accel_900: Optional[
        api_900.UnevenlySampledChannel
    ] = reader_utils.find_uneven_channel_raw(
        packet,
        {
            api_900.ChannelType.ACCELEROMETER_X,
            api_900.ChannelType.ACCELEROMETER_Y,
            api_900.ChannelType.ACCELEROMETER_Z,
        },
    )
    if accel_900 is not None:
        packet_m.sensors.accelerometer.sensor_description = accel_900.sensor_name
        packet_m.sensors.accelerometer.timestamps.unit = (
            api_m.RedvoxPacketM.Unit.MICROSECONDS_SINCE_UNIX_EPOCH
        )
        packet_m.sensors.accelerometer.timestamps.timestamps[
            :
        ] = accel_900.timestamps_microseconds_utc
        accel_payload: List[float] = list(reader_utils.extract_payload(accel_900))
        packet_m.sensors.accelerometer.x_samples.unit = (
            api_m.RedvoxPacketM.Unit.METERS_PER_SECOND_SQUARED
        )
        packet_m.sensors.accelerometer.x_samples.values[:] = accel_payload[0::3]
        packet_m.sensors.accelerometer.y_samples.unit = (
            api_m.RedvoxPacketM.Unit.METERS_PER_SECOND_SQUARED
        )
        packet_m.sensors.accelerometer.y_samples.values[:] = accel_payload[1::3]
        packet_m.sensors.accelerometer.z_samples.unit = (
            api_m.RedvoxPacketM.Unit.METERS_PER_SECOND_SQUARED
        )
        packet_m.sensors.accelerometer.z_samples.values[:] = accel_payload[2::3]
        compute_stats_raw(packet_m.sensors.accelerometer.timestamps)
        compute_stats_raw(packet_m.sensors.accelerometer.x_samples)
        compute_stats_raw(packet_m.sensors.accelerometer.y_samples)
        compute_stats_raw(packet_m.sensors.accelerometer.z_samples)

    # Magnetometer
    sensor: Optional[
        api_900.UnevenlySampledChannel
    ] = reader_utils.find_uneven_channel_raw(
        packet,
        {
            api_900.ChannelType.MAGNETOMETER_X,
            api_900.ChannelType.MAGNETOMETER_Y,
            api_900.ChannelType.MAGNETOMETER_Z,
        },
    )
    if sensor is not None:
        packet_m.sensors.magnetometer.sensor_description = sensor.sensor_name
        packet_m.sensors.magnetometer.timestamps.unit = (
            api_m.RedvoxPacketM.Unit.MICROSECONDS_SINCE_UNIX_EPOCH
        )
        packet_m.sensors.magnetometer.timestamps.timestamps[
            :
        ] = sensor.timestamps_microseconds_utc
        sensor_payload: List[float] = list(reader_utils.extract_payload(sensor))
        packet_m.sensors.magnetometer.x_samples.unit = (
            api_m.RedvoxPacketM.Unit.MICROTESLA
        )
        packet_m.sensors.magnetometer.x_samples.values[:] = sensor_payload[0::3]
        packet_m.sensors.magnetometer.y_samples.unit = (
            api_m.RedvoxPacketM.Unit.MICROTESLA
        )
        packet_m.sensors.magnetometer.y_samples.values[:] = sensor_payload[1::3]
        packet_m.sensors.magnetometer.z_samples.unit = (
            api_m.RedvoxPacketM.Unit.MICROTESLA
        )
        packet_m.sensors.magnetometer.z_samples.values[:] = sensor_payload[2::3]
        compute_stats_raw(packet_m.sensors.magnetometer.timestamps)
        compute_stats_raw(packet_m.sensors.magnetometer.x_samples)
        compute_stats_raw(packet_m.sensors.magnetometer.y_samples)
        compute_stats_raw(packet_m.sensors.magnetometer.z_samples)
    #
    # Gyroscope
    sensor = reader_utils.find_uneven_channel_raw(
        packet,
        {
            api_900.ChannelType.GYROSCOPE_X,
            api_900.ChannelType.GYROSCOPE_Y,
            api_900.ChannelType.GYROSCOPE_Z,
        },
    )
    if sensor is not None:
        packet_m.sensors.gyroscope.sensor_description = sensor.sensor_name
        packet_m.sensors.gyroscope.timestamps.unit = (
            api_m.RedvoxPacketM.Unit.MICROSECONDS_SINCE_UNIX_EPOCH
        )
        packet_m.sensors.gyroscope.timestamps.timestamps[
            :
        ] = sensor.timestamps_microseconds_utc
        sensor_payload = list(reader_utils.extract_payload(sensor))
        packet_m.sensors.gyroscope.x_samples.unit = (
            api_m.RedvoxPacketM.Unit.RADIANS_PER_SECOND
        )
        packet_m.sensors.gyroscope.x_samples.values[:] = sensor_payload[0::3]
        packet_m.sensors.gyroscope.y_samples.unit = (
            api_m.RedvoxPacketM.Unit.RADIANS_PER_SECOND
        )
        packet_m.sensors.gyroscope.y_samples.values[:] = sensor_payload[1::3]
        packet_m.sensors.gyroscope.z_samples.unit = (
            api_m.RedvoxPacketM.Unit.RADIANS_PER_SECOND
        )
        packet_m.sensors.gyroscope.z_samples.values[:] = sensor_payload[2::3]
        compute_stats_raw(packet_m.sensors.gyroscope.timestamps)
        compute_stats_raw(packet_m.sensors.gyroscope.x_samples)
        compute_stats_raw(packet_m.sensors.gyroscope.y_samples)
        compute_stats_raw(packet_m.sensors.gyroscope.z_samples)

    #
    # # Light
    light_900: Optional[
        api_900.UnevenlySampledChannel
    ] = reader_utils.find_uneven_channel_raw(packet, {api_900.ChannelType.LIGHT})
    if light_900 is not None:
        packet_m.sensors.light.sensor_description = light_900.sensor_name
        packet_m.sensors.light.timestamps.unit = (
            api_m.RedvoxPacketM.Unit.MICROSECONDS_SINCE_UNIX_EPOCH
        )
        packet_m.sensors.light.timestamps.timestamps[
            :
        ] = light_900.timestamps_microseconds_utc
        packet_m.sensors.light.samples.values[:] = list(
            reader_utils.extract_payload(light_900)
        )
        packet_m.sensors.light.samples.unit = api_m.RedvoxPacketM.Unit.LUX
        for i in range(0, len(light_900.metadata), 2):
            v = light_900.metadata[i + 1] if (i + 1) &lt; len(light_900.metadata) else &#34;&#34;
            packet_m.sensors.light.metadata[light_900.metadata[i]] = v
        compute_stats_raw(packet_m.sensors.light.timestamps)
        compute_stats_raw(packet_m.sensors.light.samples)

    # # Image
    # Not implemented for conversion. Only a very small fraction of API 900 was ever image capable, and not the public
    # app.

    # # Proximity
    proximity_900: Optional[
        api_900.UnevenlySampledChannel
    ] = reader_utils.find_uneven_channel_raw(packet, {api_900.ChannelType.INFRARED})
    if proximity_900 is not None:
        packet_m.sensors.proximity.sensor_description = proximity_900.sensor_name
        packet_m.sensors.proximity.timestamps.unit = (
            api_m.RedvoxPacketM.Unit.MICROSECONDS_SINCE_UNIX_EPOCH
        )
        packet_m.sensors.proximity.timestamps.timestamps[
            :
        ] = proximity_900.timestamps_microseconds_utc
        packet_m.sensors.proximity.samples.values[:] = list(
            reader_utils.extract_payload(proximity_900)
        )
        packet_m.sensors.proximity.samples.unit = api_m.RedvoxPacketM.Unit.CENTIMETERS
        for i in range(0, len(proximity_900.metadata), 2):
            v = (
                proximity_900.metadata[i + 1]
                if (i + 1) &lt; len(proximity_900.metadata)
                else &#34;&#34;
            )
            packet_m.sensors.proximity.metadata[proximity_900.metadata[i]] = v
        compute_stats_raw(packet_m.sensors.proximity.timestamps)
        compute_stats_raw(packet_m.sensors.proximity.samples)

    return packet_m</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="redvox.common" href="index.html">redvox.common</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="redvox.common.api_conversions.compute_stats_raw" href="#redvox.common.api_conversions.compute_stats_raw">compute_stats_raw</a></code></li>
<li><code><a title="redvox.common.api_conversions.convert_api_1000_to_900" href="#redvox.common.api_conversions.convert_api_1000_to_900">convert_api_1000_to_900</a></code></li>
<li><code><a title="redvox.common.api_conversions.convert_api_900_to_1000" href="#redvox.common.api_conversions.convert_api_900_to_1000">convert_api_900_to_1000</a></code></li>
<li><code><a title="redvox.common.api_conversions.convert_api_900_to_1000_raw" href="#redvox.common.api_conversions.convert_api_900_to_1000_raw">convert_api_900_to_1000_raw</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>