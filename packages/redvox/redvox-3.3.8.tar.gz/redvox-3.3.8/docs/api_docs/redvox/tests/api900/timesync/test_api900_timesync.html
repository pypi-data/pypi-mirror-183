<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>redvox.tests.api900.timesync.test_api900_timesync API documentation</title>
<meta name="description" content="API900 timesync test module" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>redvox.tests.api900.timesync.test_api900_timesync</code></h1>
</header>
<section id="section-intro">
<p>API900 timesync test module</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
API900 timesync test module
&#34;&#34;&#34;

import glob
import os.path
from typing import List
import unittest

# noinspection Mypy
import numpy as np

import redvox.tests as tests
import redvox.api900.reader as reader
import redvox.api900.timesync.api900_timesync as api900_timesync


class RedVoxTimesyncTests(unittest.TestCase):
    def setUp(self) -&gt; None:
        data_paths: List[str] = sorted(glob.glob(os.path.join(tests.TEST_DATA_DIR, &#34;1637680001*.rdvxz&#34;)))
        self.wrapped_packets_fs: List[reader.WrappedRedvoxPacket] = list(map(lambda path: reader.read_rdvxz_file(path),
                                                                             data_paths))
        mic_channels: List[reader.MicrophoneSensor] = list(map(
            lambda wrapped_packet: wrapped_packet.microphone_sensor(), self.wrapped_packets_fs))
        self.fs: float = mic_channels[0].sample_rate_hz()
        self.time_sync_data = api900_timesync.TimeSyncData(self.wrapped_packets_fs)

    def test_get_time_sync_data(self):
        self.assertEqual(len(self.time_sync_data.rev_start_times), len(self.wrapped_packets_fs))
        self.assertEqual(len(self.time_sync_data.latencies), len(self.wrapped_packets_fs))
        self.assertEqual(len(self.time_sync_data.offsets), len(self.wrapped_packets_fs))
        self.assertEqual(self.time_sync_data.best_latency, 69664.0)

    def test_compute_tri_message_stats(self):
        self.assertEqual(self.time_sync_data.latencies[0], 69664.0)
        self.assertEqual(self.time_sync_data.offsets[0], -22906528.)

    def test_validate_sensors(self):
        valid_sensor_settings = api900_timesync.validate_sensors(self.wrapped_packets_fs)
        self.assertTrue(valid_sensor_settings)
        one_packet = self.wrapped_packets_fs[0]
        valid_one_sensor = api900_timesync.validate_sensors([one_packet])
        self.assertTrue(valid_one_sensor)

    def test_find_bad_packets(self):
        self.assertEqual(len(self.time_sync_data.bad_packets), 0)

    def test_find_bad_packets_ratio(self):
        self.assertEqual(self.time_sync_data.get_ratio_bad_packets(), 0)

    def test_evaluate_latencies_and_offsets(self):
        self.assertEqual(len(self.time_sync_data.latencies), len(self.wrapped_packets_fs))
        self.assertEqual(len(self.time_sync_data.offsets), len(self.wrapped_packets_fs))
        self.assertEqual(self.time_sync_data.best_latency, 69664.0)
        self.assertEqual(self.time_sync_data.best_latency_index, 0)

    def test_get_latency_mean(self):
        self.assertAlmostEqual(self.time_sync_data.get_latency_mean(), 118049.66, 2)
        self.time_sync_data.best_latency = None
        self.assertEqual(self.time_sync_data.get_latency_mean(), None)

    def test_get_latency_std_dev(self):
        self.assertAlmostEqual(self.time_sync_data.get_latency_std_dev(), 84458.71, 2)
        self.time_sync_data.best_latency = None
        self.assertEqual(self.time_sync_data.get_latency_std_dev(), None)

    def test_get_valid_latencies(self):
        valid_latencies = self.time_sync_data.get_valid_latencies()
        self.assertEqual(len(valid_latencies), len(self.wrapped_packets_fs))
        self.assertEqual(69664.0, valid_latencies[0])
        latency_array = [1, 2, 3, 4, 0, 0, 6, 216]
        valid_latencies = self.time_sync_data.get_valid_latencies(latency_array)
        self.assertEqual(6, len(valid_latencies))
        self.assertEqual(6, valid_latencies[4])

    def test_get_offset_mean(self):
        self.assertAlmostEqual(self.time_sync_data.get_offset_mean(), -22903096.02, 2)
        old_best_latency = self.time_sync_data.best_latency
        self.time_sync_data.best_latency = None
        self.assertEqual(self.time_sync_data.get_offset_mean(), 0.0)
        self.time_sync_data.best_latency = old_best_latency
        self.time_sync_data.best_offset = 0.0
        self.assertEqual(self.time_sync_data.get_offset_mean(), 0.0)

    def test_get_offset_std_dev(self):
        self.assertAlmostEqual(self.time_sync_data.get_offset_std_dev(), 91847.39, 2)
        old_best_latency = self.time_sync_data.best_latency
        self.time_sync_data.best_latency = None
        self.assertEqual(self.time_sync_data.get_offset_std_dev(), 0.0)
        self.time_sync_data.best_latency = old_best_latency
        self.time_sync_data.best_offset = 0.0
        self.assertEqual(self.time_sync_data.get_offset_std_dev(), 0.0)

    def test_get_valid_offsets(self):
        valid_offsets = self.time_sync_data.get_valid_offsets()
        self.assertEqual(len(valid_offsets), len(self.wrapped_packets_fs))
        self.assertEqual(-22906528.0, valid_offsets[0])
        offset_array = [1, 2, 3, 4, 0, 0, 6, 216]
        valid_offsets = self.time_sync_data.get_valid_offsets(offset_array)
        self.assertEqual(6, len(valid_offsets))
        self.assertEqual(6, valid_offsets[4])

    def test_get_valid_rev_start_times(self):
        valid_starts = self.time_sync_data.get_valid_rev_start_times()
        self.assertEqual(len(valid_starts), len(self.wrapped_packets_fs))
        self.assertEqual(1532459174181472., valid_starts[0])

    def test_get_best_rev_start_time(self):
        best_start = self.time_sync_data.get_best_rev_start_time()
        self.assertEqual(1532459174181472.0, best_start)

    def test_correct_time_array(self):
        &#34;&#34;&#34; Example: A sample is taken every 0.5 seconds, and a file has 5 seconds (10 samples). Let&#39;s say we sampled
        for a total of 20 seconds (4 files, 40 samples). At the beginning of each file (every 10th sample, or every
        5 seconds), there is a start mach time and a start epoch time. Rebuild the time array
        with the packet with the lowest latency being the best start time. In this case, the best latency is 1,
        which occurs in file 2, which starts at 4 seconds.  In the end we should get 40 timestamps,
        starting at -1.0 and increasing at a rate of 0.5 seconds, and the 11th sample (idx 10) = 4 seconds. &#34;&#34;&#34;
        # the revised start times are in microseconds, but the corrected time is in seconds
        tsd_corrected = api900_timesync.TimeSyncData()
        tsd_corrected.rev_start_times = np.array([1000000, 4000000, 8000000, 13000000])
        tsd_corrected.best_latency = 1
        tsd_corrected.best_latency_index = 1
        tsd_corrected.latencies = np.array([2, 1, 2, 2])
        tsd_corrected.num_packets = 4
        tsd_corrected.sample_rate_hz = 2
        file_samples = 10  # 10 samples per file
        correct_time_array_sec = api900_timesync.update_evenly_sampled_time_array(tsd_corrected, file_samples)

        self.assertTrue(np.array_equal(np.arange(-1.0, 19.0, 0.5), correct_time_array_sec))
        self.assertEqual(4.0, correct_time_array_sec[10])
        self.assertTrue(isinstance(correct_time_array_sec, np.ndarray))

    def test_sync_packet_time(self):
        api900_timesync.sync_packet_time_900(self.wrapped_packets_fs, verbose=False)
        self.assertEqual(
            self.wrapped_packets_fs[0].magnetometer_sensor()._unevenly_sampled_channel.timestamps_microseconds_utc[0],
            1532459174286232)
        self.assertEqual(self.wrapped_packets_fs[0].microphone_sensor().first_sample_timestamp_epoch_microseconds_utc(),
                         1532459174181472)
        self.assertEqual(self.wrapped_packets_fs[0].app_file_start_timestamp_epoch_microseconds_utc(), 1532459174181472)
        self.assertEqual(self.wrapped_packets_fs[0].is_synch_corrected(), True)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests"><code class="flex name class">
<span>class <span class="ident">RedVoxTimesyncTests</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<div class="desc"><p>A class whose instances are single test cases.</p>
<p>By default, the test code itself should be placed in a method named
'runTest'.</p>
<p>If the fixture may be used for many test cases, create as
many test methods as are needed. When instantiating such a TestCase
subclass, specify in the constructor arguments the name of the test method
that the instance is to execute.</p>
<p>Test authors should subclass TestCase for their own tests. Construction
and deconstruction of the test's environment ('fixture') can be
implemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>
<p>If it is necessary to override the <strong>init</strong> method, the base class
<strong>init</strong> method must always be called. It is important that subclasses
should not change the signature of their <strong>init</strong> method, since instances
of the classes are instantiated automatically by parts of the framework
in order to be run.</p>
<p>When subclassing TestCase, you can set these attributes:
* failureException: determines which exception will be raised when
the instance's assertion methods fail; test methods raising this
exception will be deemed to have 'failed' rather than 'errored'.
* longMessage: determines whether long messages (including repr of
objects used in assert methods) will be printed on failure in <em>addition</em>
to any explicit message passed.
* maxDiff: sets the maximum length of a diff in failure messages
by assert methods using difflib. It is looked up as an instance
attribute so can be configured by individual tests if required.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RedVoxTimesyncTests(unittest.TestCase):
    def setUp(self) -&gt; None:
        data_paths: List[str] = sorted(glob.glob(os.path.join(tests.TEST_DATA_DIR, &#34;1637680001*.rdvxz&#34;)))
        self.wrapped_packets_fs: List[reader.WrappedRedvoxPacket] = list(map(lambda path: reader.read_rdvxz_file(path),
                                                                             data_paths))
        mic_channels: List[reader.MicrophoneSensor] = list(map(
            lambda wrapped_packet: wrapped_packet.microphone_sensor(), self.wrapped_packets_fs))
        self.fs: float = mic_channels[0].sample_rate_hz()
        self.time_sync_data = api900_timesync.TimeSyncData(self.wrapped_packets_fs)

    def test_get_time_sync_data(self):
        self.assertEqual(len(self.time_sync_data.rev_start_times), len(self.wrapped_packets_fs))
        self.assertEqual(len(self.time_sync_data.latencies), len(self.wrapped_packets_fs))
        self.assertEqual(len(self.time_sync_data.offsets), len(self.wrapped_packets_fs))
        self.assertEqual(self.time_sync_data.best_latency, 69664.0)

    def test_compute_tri_message_stats(self):
        self.assertEqual(self.time_sync_data.latencies[0], 69664.0)
        self.assertEqual(self.time_sync_data.offsets[0], -22906528.)

    def test_validate_sensors(self):
        valid_sensor_settings = api900_timesync.validate_sensors(self.wrapped_packets_fs)
        self.assertTrue(valid_sensor_settings)
        one_packet = self.wrapped_packets_fs[0]
        valid_one_sensor = api900_timesync.validate_sensors([one_packet])
        self.assertTrue(valid_one_sensor)

    def test_find_bad_packets(self):
        self.assertEqual(len(self.time_sync_data.bad_packets), 0)

    def test_find_bad_packets_ratio(self):
        self.assertEqual(self.time_sync_data.get_ratio_bad_packets(), 0)

    def test_evaluate_latencies_and_offsets(self):
        self.assertEqual(len(self.time_sync_data.latencies), len(self.wrapped_packets_fs))
        self.assertEqual(len(self.time_sync_data.offsets), len(self.wrapped_packets_fs))
        self.assertEqual(self.time_sync_data.best_latency, 69664.0)
        self.assertEqual(self.time_sync_data.best_latency_index, 0)

    def test_get_latency_mean(self):
        self.assertAlmostEqual(self.time_sync_data.get_latency_mean(), 118049.66, 2)
        self.time_sync_data.best_latency = None
        self.assertEqual(self.time_sync_data.get_latency_mean(), None)

    def test_get_latency_std_dev(self):
        self.assertAlmostEqual(self.time_sync_data.get_latency_std_dev(), 84458.71, 2)
        self.time_sync_data.best_latency = None
        self.assertEqual(self.time_sync_data.get_latency_std_dev(), None)

    def test_get_valid_latencies(self):
        valid_latencies = self.time_sync_data.get_valid_latencies()
        self.assertEqual(len(valid_latencies), len(self.wrapped_packets_fs))
        self.assertEqual(69664.0, valid_latencies[0])
        latency_array = [1, 2, 3, 4, 0, 0, 6, 216]
        valid_latencies = self.time_sync_data.get_valid_latencies(latency_array)
        self.assertEqual(6, len(valid_latencies))
        self.assertEqual(6, valid_latencies[4])

    def test_get_offset_mean(self):
        self.assertAlmostEqual(self.time_sync_data.get_offset_mean(), -22903096.02, 2)
        old_best_latency = self.time_sync_data.best_latency
        self.time_sync_data.best_latency = None
        self.assertEqual(self.time_sync_data.get_offset_mean(), 0.0)
        self.time_sync_data.best_latency = old_best_latency
        self.time_sync_data.best_offset = 0.0
        self.assertEqual(self.time_sync_data.get_offset_mean(), 0.0)

    def test_get_offset_std_dev(self):
        self.assertAlmostEqual(self.time_sync_data.get_offset_std_dev(), 91847.39, 2)
        old_best_latency = self.time_sync_data.best_latency
        self.time_sync_data.best_latency = None
        self.assertEqual(self.time_sync_data.get_offset_std_dev(), 0.0)
        self.time_sync_data.best_latency = old_best_latency
        self.time_sync_data.best_offset = 0.0
        self.assertEqual(self.time_sync_data.get_offset_std_dev(), 0.0)

    def test_get_valid_offsets(self):
        valid_offsets = self.time_sync_data.get_valid_offsets()
        self.assertEqual(len(valid_offsets), len(self.wrapped_packets_fs))
        self.assertEqual(-22906528.0, valid_offsets[0])
        offset_array = [1, 2, 3, 4, 0, 0, 6, 216]
        valid_offsets = self.time_sync_data.get_valid_offsets(offset_array)
        self.assertEqual(6, len(valid_offsets))
        self.assertEqual(6, valid_offsets[4])

    def test_get_valid_rev_start_times(self):
        valid_starts = self.time_sync_data.get_valid_rev_start_times()
        self.assertEqual(len(valid_starts), len(self.wrapped_packets_fs))
        self.assertEqual(1532459174181472., valid_starts[0])

    def test_get_best_rev_start_time(self):
        best_start = self.time_sync_data.get_best_rev_start_time()
        self.assertEqual(1532459174181472.0, best_start)

    def test_correct_time_array(self):
        &#34;&#34;&#34; Example: A sample is taken every 0.5 seconds, and a file has 5 seconds (10 samples). Let&#39;s say we sampled
        for a total of 20 seconds (4 files, 40 samples). At the beginning of each file (every 10th sample, or every
        5 seconds), there is a start mach time and a start epoch time. Rebuild the time array
        with the packet with the lowest latency being the best start time. In this case, the best latency is 1,
        which occurs in file 2, which starts at 4 seconds.  In the end we should get 40 timestamps,
        starting at -1.0 and increasing at a rate of 0.5 seconds, and the 11th sample (idx 10) = 4 seconds. &#34;&#34;&#34;
        # the revised start times are in microseconds, but the corrected time is in seconds
        tsd_corrected = api900_timesync.TimeSyncData()
        tsd_corrected.rev_start_times = np.array([1000000, 4000000, 8000000, 13000000])
        tsd_corrected.best_latency = 1
        tsd_corrected.best_latency_index = 1
        tsd_corrected.latencies = np.array([2, 1, 2, 2])
        tsd_corrected.num_packets = 4
        tsd_corrected.sample_rate_hz = 2
        file_samples = 10  # 10 samples per file
        correct_time_array_sec = api900_timesync.update_evenly_sampled_time_array(tsd_corrected, file_samples)

        self.assertTrue(np.array_equal(np.arange(-1.0, 19.0, 0.5), correct_time_array_sec))
        self.assertEqual(4.0, correct_time_array_sec[10])
        self.assertTrue(isinstance(correct_time_array_sec, np.ndarray))

    def test_sync_packet_time(self):
        api900_timesync.sync_packet_time_900(self.wrapped_packets_fs, verbose=False)
        self.assertEqual(
            self.wrapped_packets_fs[0].magnetometer_sensor()._unevenly_sampled_channel.timestamps_microseconds_utc[0],
            1532459174286232)
        self.assertEqual(self.wrapped_packets_fs[0].microphone_sensor().first_sample_timestamp_epoch_microseconds_utc(),
                         1532459174181472)
        self.assertEqual(self.wrapped_packets_fs[0].app_file_start_timestamp_epoch_microseconds_utc(), 1532459174181472)
        self.assertEqual(self.wrapped_packets_fs[0].is_synch_corrected(), True)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>unittest.case.TestCase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.setUp"><code class="name flex">
<span>def <span class="ident">setUp</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Hook method for setting up the test fixture before exercising it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setUp(self) -&gt; None:
    data_paths: List[str] = sorted(glob.glob(os.path.join(tests.TEST_DATA_DIR, &#34;1637680001*.rdvxz&#34;)))
    self.wrapped_packets_fs: List[reader.WrappedRedvoxPacket] = list(map(lambda path: reader.read_rdvxz_file(path),
                                                                         data_paths))
    mic_channels: List[reader.MicrophoneSensor] = list(map(
        lambda wrapped_packet: wrapped_packet.microphone_sensor(), self.wrapped_packets_fs))
    self.fs: float = mic_channels[0].sample_rate_hz()
    self.time_sync_data = api900_timesync.TimeSyncData(self.wrapped_packets_fs)</code></pre>
</details>
</dd>
<dt id="redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_compute_tri_message_stats"><code class="name flex">
<span>def <span class="ident">test_compute_tri_message_stats</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_compute_tri_message_stats(self):
    self.assertEqual(self.time_sync_data.latencies[0], 69664.0)
    self.assertEqual(self.time_sync_data.offsets[0], -22906528.)</code></pre>
</details>
</dd>
<dt id="redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_correct_time_array"><code class="name flex">
<span>def <span class="ident">test_correct_time_array</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Example: A sample is taken every 0.5 seconds, and a file has 5 seconds (10 samples). Let's say we sampled
for a total of 20 seconds (4 files, 40 samples). At the beginning of each file (every 10th sample, or every
5 seconds), there is a start mach time and a start epoch time. Rebuild the time array
with the packet with the lowest latency being the best start time. In this case, the best latency is 1,
which occurs in file 2, which starts at 4 seconds.
In the end we should get 40 timestamps,
starting at -1.0 and increasing at a rate of 0.5 seconds, and the 11th sample (idx 10) = 4 seconds.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_correct_time_array(self):
    &#34;&#34;&#34; Example: A sample is taken every 0.5 seconds, and a file has 5 seconds (10 samples). Let&#39;s say we sampled
    for a total of 20 seconds (4 files, 40 samples). At the beginning of each file (every 10th sample, or every
    5 seconds), there is a start mach time and a start epoch time. Rebuild the time array
    with the packet with the lowest latency being the best start time. In this case, the best latency is 1,
    which occurs in file 2, which starts at 4 seconds.  In the end we should get 40 timestamps,
    starting at -1.0 and increasing at a rate of 0.5 seconds, and the 11th sample (idx 10) = 4 seconds. &#34;&#34;&#34;
    # the revised start times are in microseconds, but the corrected time is in seconds
    tsd_corrected = api900_timesync.TimeSyncData()
    tsd_corrected.rev_start_times = np.array([1000000, 4000000, 8000000, 13000000])
    tsd_corrected.best_latency = 1
    tsd_corrected.best_latency_index = 1
    tsd_corrected.latencies = np.array([2, 1, 2, 2])
    tsd_corrected.num_packets = 4
    tsd_corrected.sample_rate_hz = 2
    file_samples = 10  # 10 samples per file
    correct_time_array_sec = api900_timesync.update_evenly_sampled_time_array(tsd_corrected, file_samples)

    self.assertTrue(np.array_equal(np.arange(-1.0, 19.0, 0.5), correct_time_array_sec))
    self.assertEqual(4.0, correct_time_array_sec[10])
    self.assertTrue(isinstance(correct_time_array_sec, np.ndarray))</code></pre>
</details>
</dd>
<dt id="redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_evaluate_latencies_and_offsets"><code class="name flex">
<span>def <span class="ident">test_evaluate_latencies_and_offsets</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_evaluate_latencies_and_offsets(self):
    self.assertEqual(len(self.time_sync_data.latencies), len(self.wrapped_packets_fs))
    self.assertEqual(len(self.time_sync_data.offsets), len(self.wrapped_packets_fs))
    self.assertEqual(self.time_sync_data.best_latency, 69664.0)
    self.assertEqual(self.time_sync_data.best_latency_index, 0)</code></pre>
</details>
</dd>
<dt id="redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_find_bad_packets"><code class="name flex">
<span>def <span class="ident">test_find_bad_packets</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_find_bad_packets(self):
    self.assertEqual(len(self.time_sync_data.bad_packets), 0)</code></pre>
</details>
</dd>
<dt id="redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_find_bad_packets_ratio"><code class="name flex">
<span>def <span class="ident">test_find_bad_packets_ratio</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_find_bad_packets_ratio(self):
    self.assertEqual(self.time_sync_data.get_ratio_bad_packets(), 0)</code></pre>
</details>
</dd>
<dt id="redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_get_best_rev_start_time"><code class="name flex">
<span>def <span class="ident">test_get_best_rev_start_time</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_best_rev_start_time(self):
    best_start = self.time_sync_data.get_best_rev_start_time()
    self.assertEqual(1532459174181472.0, best_start)</code></pre>
</details>
</dd>
<dt id="redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_get_latency_mean"><code class="name flex">
<span>def <span class="ident">test_get_latency_mean</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_latency_mean(self):
    self.assertAlmostEqual(self.time_sync_data.get_latency_mean(), 118049.66, 2)
    self.time_sync_data.best_latency = None
    self.assertEqual(self.time_sync_data.get_latency_mean(), None)</code></pre>
</details>
</dd>
<dt id="redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_get_latency_std_dev"><code class="name flex">
<span>def <span class="ident">test_get_latency_std_dev</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_latency_std_dev(self):
    self.assertAlmostEqual(self.time_sync_data.get_latency_std_dev(), 84458.71, 2)
    self.time_sync_data.best_latency = None
    self.assertEqual(self.time_sync_data.get_latency_std_dev(), None)</code></pre>
</details>
</dd>
<dt id="redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_get_offset_mean"><code class="name flex">
<span>def <span class="ident">test_get_offset_mean</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_offset_mean(self):
    self.assertAlmostEqual(self.time_sync_data.get_offset_mean(), -22903096.02, 2)
    old_best_latency = self.time_sync_data.best_latency
    self.time_sync_data.best_latency = None
    self.assertEqual(self.time_sync_data.get_offset_mean(), 0.0)
    self.time_sync_data.best_latency = old_best_latency
    self.time_sync_data.best_offset = 0.0
    self.assertEqual(self.time_sync_data.get_offset_mean(), 0.0)</code></pre>
</details>
</dd>
<dt id="redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_get_offset_std_dev"><code class="name flex">
<span>def <span class="ident">test_get_offset_std_dev</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_offset_std_dev(self):
    self.assertAlmostEqual(self.time_sync_data.get_offset_std_dev(), 91847.39, 2)
    old_best_latency = self.time_sync_data.best_latency
    self.time_sync_data.best_latency = None
    self.assertEqual(self.time_sync_data.get_offset_std_dev(), 0.0)
    self.time_sync_data.best_latency = old_best_latency
    self.time_sync_data.best_offset = 0.0
    self.assertEqual(self.time_sync_data.get_offset_std_dev(), 0.0)</code></pre>
</details>
</dd>
<dt id="redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_get_time_sync_data"><code class="name flex">
<span>def <span class="ident">test_get_time_sync_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_time_sync_data(self):
    self.assertEqual(len(self.time_sync_data.rev_start_times), len(self.wrapped_packets_fs))
    self.assertEqual(len(self.time_sync_data.latencies), len(self.wrapped_packets_fs))
    self.assertEqual(len(self.time_sync_data.offsets), len(self.wrapped_packets_fs))
    self.assertEqual(self.time_sync_data.best_latency, 69664.0)</code></pre>
</details>
</dd>
<dt id="redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_get_valid_latencies"><code class="name flex">
<span>def <span class="ident">test_get_valid_latencies</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_valid_latencies(self):
    valid_latencies = self.time_sync_data.get_valid_latencies()
    self.assertEqual(len(valid_latencies), len(self.wrapped_packets_fs))
    self.assertEqual(69664.0, valid_latencies[0])
    latency_array = [1, 2, 3, 4, 0, 0, 6, 216]
    valid_latencies = self.time_sync_data.get_valid_latencies(latency_array)
    self.assertEqual(6, len(valid_latencies))
    self.assertEqual(6, valid_latencies[4])</code></pre>
</details>
</dd>
<dt id="redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_get_valid_offsets"><code class="name flex">
<span>def <span class="ident">test_get_valid_offsets</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_valid_offsets(self):
    valid_offsets = self.time_sync_data.get_valid_offsets()
    self.assertEqual(len(valid_offsets), len(self.wrapped_packets_fs))
    self.assertEqual(-22906528.0, valid_offsets[0])
    offset_array = [1, 2, 3, 4, 0, 0, 6, 216]
    valid_offsets = self.time_sync_data.get_valid_offsets(offset_array)
    self.assertEqual(6, len(valid_offsets))
    self.assertEqual(6, valid_offsets[4])</code></pre>
</details>
</dd>
<dt id="redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_get_valid_rev_start_times"><code class="name flex">
<span>def <span class="ident">test_get_valid_rev_start_times</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_valid_rev_start_times(self):
    valid_starts = self.time_sync_data.get_valid_rev_start_times()
    self.assertEqual(len(valid_starts), len(self.wrapped_packets_fs))
    self.assertEqual(1532459174181472., valid_starts[0])</code></pre>
</details>
</dd>
<dt id="redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_sync_packet_time"><code class="name flex">
<span>def <span class="ident">test_sync_packet_time</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_sync_packet_time(self):
    api900_timesync.sync_packet_time_900(self.wrapped_packets_fs, verbose=False)
    self.assertEqual(
        self.wrapped_packets_fs[0].magnetometer_sensor()._unevenly_sampled_channel.timestamps_microseconds_utc[0],
        1532459174286232)
    self.assertEqual(self.wrapped_packets_fs[0].microphone_sensor().first_sample_timestamp_epoch_microseconds_utc(),
                     1532459174181472)
    self.assertEqual(self.wrapped_packets_fs[0].app_file_start_timestamp_epoch_microseconds_utc(), 1532459174181472)
    self.assertEqual(self.wrapped_packets_fs[0].is_synch_corrected(), True)</code></pre>
</details>
</dd>
<dt id="redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_validate_sensors"><code class="name flex">
<span>def <span class="ident">test_validate_sensors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_validate_sensors(self):
    valid_sensor_settings = api900_timesync.validate_sensors(self.wrapped_packets_fs)
    self.assertTrue(valid_sensor_settings)
    one_packet = self.wrapped_packets_fs[0]
    valid_one_sensor = api900_timesync.validate_sensors([one_packet])
    self.assertTrue(valid_one_sensor)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="redvox.tests.api900.timesync" href="index.html">redvox.tests.api900.timesync</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests" href="#redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests">RedVoxTimesyncTests</a></code></h4>
<ul class="">
<li><code><a title="redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.setUp" href="#redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.setUp">setUp</a></code></li>
<li><code><a title="redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_compute_tri_message_stats" href="#redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_compute_tri_message_stats">test_compute_tri_message_stats</a></code></li>
<li><code><a title="redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_correct_time_array" href="#redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_correct_time_array">test_correct_time_array</a></code></li>
<li><code><a title="redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_evaluate_latencies_and_offsets" href="#redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_evaluate_latencies_and_offsets">test_evaluate_latencies_and_offsets</a></code></li>
<li><code><a title="redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_find_bad_packets" href="#redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_find_bad_packets">test_find_bad_packets</a></code></li>
<li><code><a title="redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_find_bad_packets_ratio" href="#redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_find_bad_packets_ratio">test_find_bad_packets_ratio</a></code></li>
<li><code><a title="redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_get_best_rev_start_time" href="#redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_get_best_rev_start_time">test_get_best_rev_start_time</a></code></li>
<li><code><a title="redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_get_latency_mean" href="#redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_get_latency_mean">test_get_latency_mean</a></code></li>
<li><code><a title="redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_get_latency_std_dev" href="#redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_get_latency_std_dev">test_get_latency_std_dev</a></code></li>
<li><code><a title="redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_get_offset_mean" href="#redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_get_offset_mean">test_get_offset_mean</a></code></li>
<li><code><a title="redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_get_offset_std_dev" href="#redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_get_offset_std_dev">test_get_offset_std_dev</a></code></li>
<li><code><a title="redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_get_time_sync_data" href="#redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_get_time_sync_data">test_get_time_sync_data</a></code></li>
<li><code><a title="redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_get_valid_latencies" href="#redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_get_valid_latencies">test_get_valid_latencies</a></code></li>
<li><code><a title="redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_get_valid_offsets" href="#redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_get_valid_offsets">test_get_valid_offsets</a></code></li>
<li><code><a title="redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_get_valid_rev_start_times" href="#redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_get_valid_rev_start_times">test_get_valid_rev_start_times</a></code></li>
<li><code><a title="redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_sync_packet_time" href="#redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_sync_packet_time">test_sync_packet_time</a></code></li>
<li><code><a title="redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_validate_sensors" href="#redvox.tests.api900.timesync.test_api900_timesync.RedVoxTimesyncTests.test_validate_sensors">test_validate_sensors</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>