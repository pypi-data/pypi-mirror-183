# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_HuckelSolver.ipynb.

# %% auto 0
__all__ = ['norm', 'mapper', 'generate_smiles', 'Huckel_solve', 'MO_plot', 'Huckel']

# %% ../nbs/00_HuckelSolver.ipynb 3
#| echo: false
from rdkit import Chem
from rdkit.Chem.Draw import rdMolDraw2D
from rdkit.Chem.Draw import IPythonConsole
from rdkit.Chem import Draw
from IPython.display import SVG, Image
import numpy as np
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.cm as cm

# %% ../nbs/00_HuckelSolver.ipynb 4
IPythonConsole.ipython_useSVG=True  #< set this to False if you want PNGs instead of SVGs
IPythonConsole.drawOptions.addAtomIndices = True
norm = matplotlib.colors.Normalize(vmin=-1, vmax=1, clip=True)
mapper = cm.ScalarMappable(norm=norm, cmap='coolwarm')

# %% ../nbs/00_HuckelSolver.ipynb 5
def generate_smiles(type, n):
    """
    generate the smiles of either a straight chain or ring polyene, with n atoms.
    All carbons will be sp2 hybridised.
    For linear molecules with an odd number of atoms it will return the anion
    For rings with 4n+1 atoms it will return the anion eg C5H5-    
    For rings with 4n+3 atoms it will return the cation eg C7H7+   
    """
    unit = 'C=C'# the base 2 carbon double bond unit
    if n<3: type = 'linear' #ring needs at least 3 atoms
    if n <=1: 
        raise Exception("More than 1 Carbon atoms is needed")
    if not isinstance(n, int): 
        raise Exception("An integer number of atoms is needed")
    if type == 'linear':
        repeats = n//2 # repeats of the base unit of 2 carbons
        terminal = n%2 # whether or not a terminal carbon is needed
        output = repeats*unit +terminal*"[CH2+]"
    if type == 'ring':
        repeats = n//2 # repeats of the base unit of 2 carbons
        cation_terminal = 1 if n%4==3 else 0 # if 4n+3 carbon atoms: cation eg C7H7+
        anion_terminal = 1 if n%4==1 else 0 # if 4n+3 carbon atoms: cation eg C5H5-
        output = "C1=C" +(repeats-1)*unit +anion_terminal*"[CH-]"+cation_terminal*"[CH+]"+"1"
    return(output)

# %% ../nbs/00_HuckelSolver.ipynb 6
def Huckel_solve(SMILES):
    """
    From a SMILES input, create an adjacency matrix, and use that to solve the for the Huckel pi system
    Returns a dictionary of energy levels with the associated (possibly degenerate) wavefunctions and the RDKit molecule
    This only considers 1 sort of p orbital and treats alpha =0 and beta = -1
    """
    molecule = Chem.MolFromSmiles(SMILES)
    mat = -Chem.GetAdjacencyMatrix(molecule)
    vals, vecs = np.linalg.eig(mat)
    # create dictionary where each eigenvalue has a list of the associated eigenvectors
    energy_dict = {}
    for i, val in enumerate(vals):
        # pythons eigenvalues sometimes produce rounding errors at the 14th dp: eg eigenvalues for benzene being 1.0 and 0.9999999999999998
        # similarly, trivial imaginary parts are occasionally produced: on the order of 10^-16 i
        val = round(np.real(val), 3)
        if val in energy_dict:energy_dict[val].append(vecs[:,i])
        else: energy_dict[val]=[vecs[:,i]]
    return molecule, energy_dict

# %% ../nbs/00_HuckelSolver.ipynb 7
def MO_plot(dict):
    """
    Plots an MO diagram based on a dictionary of energy levels and associated wavefunctions
    """
    fig, ax = plt.subplots()
    plt.tick_params(
    axis='x',          # changes apply to the x-axis
    which='both',      # both major and minor ticks are affected
    bottom=False,      # ticks along the bottom edge are off
    top=False,         # ticks along the top edge are off
    labelbottom=False) # labels along the bottom edge are off
    for level in dict:
        degeneracy = len(dict[level])
        x = np.arange(-(0.5*(degeneracy - 1)),(0.5*(degeneracy)), 1)
        y = [level]*(degeneracy)
        ax.scatter(x, y, s =900, marker = '_', linewidth = 3)
    plt.show

# %% ../nbs/00_HuckelSolver.ipynb 8
class Huckel:
    """The solution to the Huckel equation for a molecule given as SMILES"""
    def __init__(self, SMILES:"str"="c1ccccc1"):
        self.smiles = SMILES
        self.molecule, self.energy_dict = Huckel_solve(SMILES)
    def plot(self):
        MO_plot(self.energy_dict)
    def __str__(self):
        string = 'Huckel Energies (degeneracy) for ' +self.smiles +':'
        for level in dict(sorted(self.energy_dict.items())): #this sorts the energy levels in order from lowest to highest
            degeneracy = len(self.energy_dict[level])
            string = string + " [%.3f (%d)] " % (level, degeneracy)
        return (string)
