Metadata-Version: 2.1
Name: lifeomic-chatbot-tools
Version: 5.1.3
Summary: Utilities for machine learning, web services, and cloud infrastructure.
License: MIT
Author: LifeOmic Development
Author-email: development@lifeomic.com
Requires-Python: >=3.8,<3.11
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Provides-Extra: aws
Provides-Extra: ml
Requires-Dist: boto3 (>=1.21.7,<2.0.0) ; extra == "aws"
Requires-Dist: fastapi (>=0.63.0,<1.0.0)
Requires-Dist: httpx (>=0.23.1,<0.24.0)
Requires-Dist: loguru (>=0.5.1,<1.0.0)
Requires-Dist: networkx (>=2.5.1,<3.0.0) ; extra == "ml"
Requires-Dist: numpy (>=1.19.2,<2.0.0) ; extra == "ml"
Requires-Dist: pydantic (>=1.7.3,<1.9.0)
Requires-Dist: requests (>=2.21.0,<3.0.0)
Requires-Dist: scikit-learn (>=0.24.2,<2.0.0) ; extra == "ml"
Description-Content-Type: text/markdown

# lifeomic-chatbot-tools

Python utilities for machine learning, web services, and cloud infrastructure.
Includes classes and methods for:

1. ML model serialization/deserialization
2. ML model evaluation utilities
3. Data structures/models related to chatbots
4. ML model artifact persistence and version management
5. And more

The data structures in this package can all be found in the
`lifeomic_chatbot_tools.types` sub-package, and are all
[Pydantic](https://pydantic-docs.helpmanual.io/) data models. For example the
`lifeomic_chatbot_tools.types.agent.AgentConfig` class represents a chatbot's
configuration and training data.

## Getting Started

To begin using the package, use your favorite package manager to install it from PyPi.
For example, using pip:

```
pip install lifeomic-chatbot-tools
```

Some of the features in this repo require more heavy weight dependencies, like AWS
related utilities, or utilities specific to machine learning. If you try to import
those features, they will tell you if you do not have the correct package extra
installed. For example, many of the features in the `lifeomic_chatbot_tools.ml`
sub-package require the `ml` extra. To install `lifeomic-chatbot-tools` with that
extra:

```
pip install lifeomic-chatbot-tools[ml]
```

You can then begin using any package features that require ML dependencies.

## Developing Locally

Before making any new commits or pull requests, please complete these steps.

1. Install the Poetry package manager for Python if you do not already have it.
   Installation instructions can be found
   [here](https://python-poetry.org/docs/#installation). You must have at least
   version 1.2 of Poetry.
2. Clone the project.
3. From the root directory of the repo, install the dependencies, including all dev
   dependencies and extras:
   ```
   poetry install --extras "aws ml"
   ```
4. Install the pre-commit hooks, so they will run before each local commit. This
   includes linting, auto-formatting, and import sorting:
   ```
   pre-commit install
   ```
   **Note**: pre-commit is a dev dependency of the project, and is managed by Poetry.
   In order to use those dependencies from the terminal, you must be in a Poetry shell.
   This can be accomplished by first running `poetry shell` in your terminal.

## Testing Locally

With Yarn, Docker, and docker-compose installed, run this command from the project
root:

```
yarn ci-test
```

This will build the project, lint it, and run the unit tests and integration tests.
All those steps can be run individually as well. See the scripts in the `package.json`
file for the command names.

## Releasing The Package

Releasing the package is automatically handled by CI, but three steps must be taken
to trigger a successful release:

1. Use Poetry's [`version` command](https://python-poetry.org/docs/cli/#version) to
   bump the package's version.
2. Update the [CHANGELOG](./CHANGELOG.md) file with the latest changes added under the new version.
3. Open a PR. When it's merged to `master`, the release will happen automatically.

CI will then build and release the package to pypi with that version once the PR is
merged to `master`.

