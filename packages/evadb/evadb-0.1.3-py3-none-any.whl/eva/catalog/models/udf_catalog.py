# coding=utf-8
# Copyright 2018-2022 EVA
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from sqlalchemy import Column, String
from sqlalchemy.orm import relationship

from eva.catalog.models.base_model import BaseModel


class UdfCatalog(BaseModel):
    """The `UdfCatalog` catalog stores information about the user-defined functions (UDFs) in the system. It maintains the following information for each UDF
    `_row_id:` an autogenerated identifier
    `_impl_file_path: ` the path to the implementation script for the UDF
    `_type:` an optional tag associated with the UDF (useful for grouping similar UDFs, such as multiple object detection UDFs)
    """

    __tablename__ = "udf_catalog"

    _name = Column("name", String(100), unique=True)
    _impl_file_path = Column("impl_file_path", String(128))
    _type = Column("type", String(100))

    # UdfIOCatalog stroing the input/output attributes of the udf
    _attributes = relationship(
        "UdfIOCatalog", back_populates="_udf", cascade="all, delete, delete-orphan"
    )

    def __init__(self, name: str, impl_file_path: str, type: str):
        self._name = name
        self._impl_file_path = impl_file_path
        self._type = type

    @property
    def row_id(self):
        return self._row_id

    @property
    def name(self):
        return self._name

    @property
    def impl_file_path(self):
        return self._impl_file_path

    @property
    def type(self):
        return self._type

    def display_format(self):
        inputs = []
        outputs = []
        for col in self._attributes:
            col_display = col.display_format()
            col_string = f"{col_display['name']} {col_display['data_type']}"
            if col.is_input:
                inputs.append(col_string)
            else:
                outputs.append(col_string)
        return {
            "name": self.name,
            "inputs": inputs,
            "outputs": outputs,
            "type": self.type,
            "impl": self.impl_file_path,
        }

    def __str__(self):
        udf_str = "udf: ({}, {}, {})\n".format(
            self.name, self.impl_file_path, self.type
        )
        return udf_str

    def __eq__(self, other):
        return (
            self.row_id == other.row_id
            and self.impl_file_path == other.impl_file_path
            and self.name == other.name
            and self.type == other.type
        )

    def __hash__(self) -> int:
        return hash((self.row_id, self.name, self.impl_file_path, self.type))
