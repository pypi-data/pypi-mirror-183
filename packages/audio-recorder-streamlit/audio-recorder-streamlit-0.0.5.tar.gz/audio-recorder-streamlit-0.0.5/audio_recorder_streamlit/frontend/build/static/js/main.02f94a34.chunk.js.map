{"version":3,"sources":["RecordButton.js","AudioRecorder.tsx","index.tsx"],"names":["RecordButton","onClick","fillColor","color","radius","width","height","viewBox","fill","xmlns","cx","cy","r","clipPath","d","id","transform","AudioRecorder","state","stream","AudioContext","window","webkitAudioContext","type","sampleRate","phrase_buffer_count","pause_buffer_count","pause_count","pause_threshold","energy_threshold","stage","volume","audioInput","analyser","recorder","recording","leftchannel","rightchannel","leftBuffer","rightBuffer","recordingLength","tested","getStream","navigator","mediaDevices","getUserMedia","audio","video","setupMic","console","log","startRecording","closeMic","getAudioTracks","forEach","track","stop","disconnect","writeUTFBytes","view","offset","string","lng","length","i","setUint8","charCodeAt","mergeBuffers","channelBuffer","result","Float32Array","buffer","set","interleave","leftChannel","rightChannel","inputIndex","index","context","seconds_per_buffer","Math","ceil","createGain","createMediaStreamSource","createAnalyser","connect","createScriptProcessor","destination","self","onaudioprocess","e","left","inputBuffer","getChannelData","right","reduce","a","b","getTracks","close","energy","sqrt","map","x","push","start","setState","interleaved","ArrayBuffer","DataView","setUint32","setUint16","setInt16","blob","Blob","audioUrl","URL","createObjectURL","onStop","url","render","props","theme","text","args","onClicked","data","arrayBuffer","json_string","JSON","stringify","Array","from","Uint8Array","Streamlit","setComponentValue","StreamlitComponentBase","withStreamlitConnection","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.02f94a34.chunk.js","sourcesContent":["import React from \"react\"\n\nexport const RecordButton = ({\n  onClick,\n  fillColor = \"white\",\n  color = \"#6416FF\",\n  radius = \"0\",\n}) => {\n  return (\n    <svg\n      width=\"97\"\n      height=\"97\"\n      viewBox=\"0 0 97 97\"\n      fill=\"none\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n    >\n      <circle cx=\"48.5\" cy=\"48.5\" r={radius} fill=\"#DCDCDC\" />\n      <circle cx=\"49\" cy=\"49\" r=\"33\" fill={color} onClick={onClick} />\n      <g clipPath=\"url(#clip0)\">\n        <path\n          onClick={onClick}\n          d=\"M49 57.2066C53.4997 57.2066 57.1474 53.5324 57.1474 49V35.3224C57.1474 30.7899 53.4997 27.1158 49 27.1158C44.5003 27.1158 40.8526 30.7899 40.8526 35.3224V49C40.8526 53.5324 44.5003 57.2066 49 57.2066ZM62.579 43.5289H61.2211C60.4708 43.5289 59.8632 44.141 59.8632 44.8967V49C59.8632 55.3943 54.39 60.5251 47.9145 59.8891C42.2708 59.3343 38.1369 54.224 38.1369 48.5127V44.8967C38.1369 44.141 37.5292 43.5289 36.779 43.5289H35.4211C34.6708 43.5289 34.0632 44.141 34.0632 44.8967V48.3298C34.0632 55.9927 39.4922 62.8238 46.9632 63.8616V66.7809H42.2105C41.4603 66.7809 40.8526 67.393 40.8526 68.1487V69.5164C40.8526 70.2721 41.4603 70.8842 42.2105 70.8842H55.7895C56.5397 70.8842 57.1474 70.2721 57.1474 69.5164V68.1487C57.1474 67.393 56.5397 66.7809 55.7895 66.7809H51.0369V63.8941C58.3109 62.8888 63.9369 56.5996 63.9369 49V44.8967C63.9369 44.141 63.3292 43.5289 62.579 43.5289Z\"\n          fill={fillColor}\n        />\n      </g>\n      <defs>\n        <clipPath id=\"clip0\">\n          <rect\n            width=\"29.8737\"\n            height=\"43.7684\"\n            fill=\"white\"\n            transform=\"translate(34.0632 27.1158)\"\n          />\n        </clipPath>\n      </defs>\n    </svg>\n  )\n}\n\nexport default RecordButton\n","import React, { ReactNode } from \"react\"\nimport {\n  Streamlit,\n  StreamlitComponentBase,\n  withStreamlitConnection\n} from \"streamlit-component-lib\"\nimport RecordButton from \"./RecordButton\"\n\ninterface State {\n  color: string\n}\n\ninterface AudioData {\n  blob: Blob\n  url: string\n  type: string\n}\n\nconst NEUTRAL_COLOR = \"#303030\";\nconst RECORDING_COLOR = \"#de1212\";\nclass AudioRecorder extends StreamlitComponentBase<State> {\n  public state = { color: NEUTRAL_COLOR }\n\n  stream: MediaStream | null = null;\n  AudioContext = window.AudioContext || window.webkitAudioContext;\n  type: string = \"audio/wav\";\n  sampleRate: number | null = null;\n  phrase_buffer_count: number | null = null;\n  pause_buffer_count: number | null = null;\n  pause_count: number = 0;\n  pause_threshold: number = 0.8;\n  energy_threshold: number = 0.01;\n  stage: string | null = null;\n  volume: any = null;\n  audioInput: any = null;\n  analyser: any = null;\n  recorder: any = null;\n  recording: boolean = false;\n  leftchannel: Float32Array[] = [];\n  rightchannel: Float32Array[] = [];\n  leftBuffer: Float32Array | null = null;\n  rightBuffer: Float32Array | null = null;\n  recordingLength: number = 0;\n  tested: boolean = false;\n\n  //get mic stream\n  getStream = (): Promise<MediaStream> => {\n    return navigator.mediaDevices.getUserMedia({ audio: true, video: false });\n  };\n\n  setupMic = async () => {\n    try {\n      window.stream = this.stream = await this.getStream();\n    } catch (err) {\n      console.log(\"Error: Issue getting mic\", err);\n    }\n\n    this.startRecording();\n  };\n\n  closeMic = () => {\n    this.stream!.getAudioTracks().forEach((track) => {\n      track.stop();\n    });\n    this.audioInput.disconnect(0);\n    this.analyser.disconnect(0);\n    this.recorder.disconnect(0);\n  };\n\n  writeUTFBytes = (view: DataView, offset: number, string: string) => {\n    let lng = string.length;\n    for (let i = 0; i < lng; i++) {\n      view.setUint8(offset + i, string.charCodeAt(i));\n    }\n  };\n\n  mergeBuffers = (channelBuffer: Float32Array[], recordingLength: number) => {\n    let result = new Float32Array(recordingLength);\n    let offset = 0;\n    let lng = channelBuffer.length;\n    for (let i = 0; i < lng; i++) {\n      let buffer = channelBuffer[i];\n      result.set(buffer, offset);\n      offset += buffer.length;\n    }\n    return result;\n  };\n\n  interleave = (leftChannel: Float32Array, rightChannel: Float32Array) => {\n    let length = leftChannel.length + rightChannel.length;\n    let result = new Float32Array(length);\n\n    let inputIndex = 0;\n\n    for (let index = 0; index < length; ) {\n      result[index++] = leftChannel[inputIndex];\n      result[index++] = rightChannel[inputIndex];\n      inputIndex++;\n    }\n    return result;\n  };\n\n  startRecording = () => {\n    this.context = new this.AudioContext();\n    this.sampleRate = this.context.sampleRate;\n\n    // create buffer states counts\n    let bufferSize = 2048;\n    let seconds_per_buffer = bufferSize / this.sampleRate!;\n    this.pause_buffer_count = Math.ceil(\n      this.pause_threshold / seconds_per_buffer\n    );\n    this.pause_count = 0;\n    this.stage = \"start\";\n\n    // creates a gain node\n    this.volume = this.context.createGain();\n\n    // creates an audio node from teh microphone incoming stream\n    this.audioInput = this.context.createMediaStreamSource(this.stream);\n\n    // Create analyser\n    this.analyser = this.context.createAnalyser();\n\n    // connect audio input to the analyser\n    this.audioInput.connect(this.analyser);\n\n    // connect analyser to the volume control\n    // analyser.connect(volume);\n\n    this.recorder = this.context.createScriptProcessor(bufferSize, 2, 2);\n\n    // we connect the volume control to the processor\n    // volume.connect(recorder);\n\n    this.analyser.connect(this.recorder);\n\n    // finally connect the processor to the output\n    this.recorder.connect(this.context.destination);\n\n    const self = this;  // to reference component from inside the function\n    this.recorder.onaudioprocess = function (e: any) {\n      // Check\n      if (!self.recording) return;\n      // Do something with the data, i.e Convert this to WAV\n      let left = e.inputBuffer.getChannelData(0);\n      let right = e.inputBuffer.getChannelData(1);\n      if (!self.tested) {\n        self.tested = true;\n        // if this reduces to 0 we are not getting any sound\n        if (!left.reduce((a: number, b: number) => a + b)) {\n          console.log(\"Error: There seems to be an issue with your Mic\");\n          // clean up;\n          self.stop();\n          self.stream!.getTracks().forEach(function (track: any) {\n            track.stop();\n          });\n          self.context.close();\n        }\n      }\n      // Check energy level\n      let energy = Math.sqrt(\n        left.map((x: number) => x * x).reduce((a: number, b: number) => a + b) / left.length\n      );\n      if (self.stage === \"start\" && energy > self.energy_threshold) {\n        self.stage = \"speaking\";\n      } else if (self.stage === \"speaking\") {\n        if (energy > self.energy_threshold) {\n          self.pause_count = 0;\n        } else {\n          self.pause_count += 1;\n          if (self.pause_count > self.pause_buffer_count!) {\n            self.stop();\n          }\n        }\n      }\n      // let radius = 33.0 + Math.sqrt(1000.0 * energy);\n      // this.props.setRadius(radius.toString());\n\n      // we clone the samples\n      self.leftchannel.push(new Float32Array(left));\n      self.rightchannel.push(new Float32Array(right));\n      self.recordingLength += bufferSize;\n    };\n    // this.visualize();\n  };\n\n  start = async () => {\n    this.recording = true;\n    this.setState({\n      color: RECORDING_COLOR\n    })\n    await this.setupMic();\n    // reset the buffers for the new recording\n    this.leftchannel.length = this.rightchannel.length = 0;\n    this.recordingLength = 0;\n  };\n\n  stop = async () => {\n    this.recording = false;\n    this.setState({\n      color: NEUTRAL_COLOR\n    })\n    this.closeMic();\n    console.log(this.recordingLength);\n\n    // we flat the left and right channels down\n    this.leftBuffer = this.mergeBuffers(this.leftchannel, this.recordingLength);\n    this.rightBuffer = this.mergeBuffers(\n      this.rightchannel,\n      this.recordingLength\n    );\n    // we interleave both channels together\n    let interleaved = this.interleave(this.leftBuffer, this.rightBuffer);\n\n    ///////////// WAV Encode /////////////////\n    // from http://typedarray.org/from-microphone-to-wav-with-getusermedia-and-web-audio/\n    //\n\n    // we create our wav file\n    let buffer = new ArrayBuffer(44 + interleaved.length * 2);\n    let view = new DataView(buffer);\n\n    // RIFF chunk descriptor\n    this.writeUTFBytes(view, 0, \"RIFF\");\n    view.setUint32(4, 44 + interleaved.length * 2, true);\n    this.writeUTFBytes(view, 8, \"WAVE\");\n    // FMT sub-chunk\n    this.writeUTFBytes(view, 12, \"fmt \");\n    view.setUint32(16, 16, true);\n    view.setUint16(20, 1, true);\n    // stereo (2 channels)\n    view.setUint16(22, 2, true);\n    view.setUint32(24, this.sampleRate!, true);\n    view.setUint32(28, this.sampleRate! * 4, true);\n    view.setUint16(32, 4, true);\n    view.setUint16(34, 16, true);\n    // data sub-chunk\n    this.writeUTFBytes(view, 36, \"data\");\n    view.setUint32(40, interleaved.length * 2, true);\n\n    // write the PCM samples\n    let lng = interleaved.length;\n    let index = 44;\n    let volume = 1;\n    for (let i = 0; i < lng; i++) {\n      view.setInt16(index, interleaved[i] * (0x7fff * volume), true);\n      index += 2;\n    }\n\n    // our final binary blob\n    const blob = new Blob([view], { type: this.type });\n    const audioUrl = URL.createObjectURL(blob);\n\n\n    await this.onStop({\n      blob: blob,\n      url: audioUrl,\n      type: this.type,\n    });\n  };\n\n  public render = (): ReactNode => {\n    const { theme } = this.props\n    const text = this.props.args[\"text\"]\n    this.pause_threshold = this.props.args[\"pause_threshold\"]\n    this.energy_threshold = this.props.args[\"energy_threshold\"]\n\n    if (theme) {\n      // Maintain compatibility with older versions of Streamlit that don't send\n      // a theme object.\n    }\n\n    return (\n      <span>\n        {text} &nbsp;\n        <RecordButton onClick={this.onClicked} color=\"white\" fillColor={this.state.color}></RecordButton>\n      </span>\n    )\n  }\n\n  private onClicked = async () => {\n    if (!this.recording){\n      await this.start()\n    } else {\n      await this.stop()\n    }\n\n  }\n\n  private onStop = async (data: AudioData) => {\n    var buffer = await data.blob.arrayBuffer();\n    var json_string = JSON.stringify(Array.from(new Uint8Array(buffer)));\n    Streamlit.setComponentValue(json_string);\n  }\n\n}\n\nexport default withStreamlitConnection(AudioRecorder)\n","import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport AudioRecorder from \"./AudioRecorder\"\n\nReactDOM.render(\n  <React.StrictMode>\n    <AudioRecorder />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n)\n"],"sourceRoot":""}