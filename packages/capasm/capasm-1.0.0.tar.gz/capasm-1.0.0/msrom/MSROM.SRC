!Ole Anderson + Andy Rood ... April 1979
!This contains the floppy-disk control routines.
!The ERS for this ROM is contained in file OASUMM.
!Table of contents at end of rom using KARMA.
!Released as DARO23 19-Feb-1980.
!Later re-released as DARO40.
!For expected new release modified 11July1980
! to fix TIMEOUT,IOP, & INITIALIZE,COPY bugs.
         ABS 60000             ! ROM START ADDRESS
CTLBAS   DAD 177512            ! BASE ADDRESS FOR CTRL REGS
DATBAS   DAD 177513            ! BASE FOR DATA REGS
INTRSC   DAD 177500            ! INTERRUPTING S.C. ADDRESS

LOADEX   DAD 24374
SECNA+   DAD 26425
SREAD+   DAD 26454
CREAT+   DAD 26564
TREAD.   DAD 30055
ALL1.S   DAD 27045
TAPEX-   DAD 21763
REDRN*   DAD 24621
GET#1+   DAD 27570
!**111111111111111111111111111111111111111***
!   HEADER BLOCK                            *
!********************************************
MYROM#   EQU 320
MSROM2   EQU 321
!Steps for creating EROMs and ROMS:
! 1. Change MYROM# to 320, compliment to 57.
! 2. Enable JZR CKSMOK code, disable JMP CKSMOK.
IOROM#   EQU 300
BASE     VAL MYROM#            !   ROM NUMBER
         BYT 57                !   COMPLEMENTED ROM NUMBER
         DEF RUNTIM            !   ADDRESS OF LIST OF RUN
!                                    ROUTINES' ADDRESSES
         DEF TOKENS            !   ROM RESERVED WORD
!                                    (TOKEN) TABLE
         DEF PARSES            !   PARSE ROUTINES' TABLE
!                                    OF ADDRESSES
         DEF ERMESS            !   ERROR MESSAGE TABLE
RUNTIM   DEF INITIT            !   ADDRESS OF INITIALIZ-
!                                    ATION ROUTINE
!**222222222222222222222222222222222222222***
!   FOLLOWING IS A TABLE OF ADDRESSES       *
!   OF THE RUNTIME ROUTINES.                *
!********************************************
         DEF ASSIG.            ! 1. ASSIGN FILE MSUS
         DEF MSCAT.            ! 2. PRINT CATALOG
         DEF CHKOF.            ! 3. ERROR CHECKING OFF
         DEF CHECK.            ! 4. ERROR CHECKING READ
!        DEF TRANS.              ! 5. TRANSLATE BETWEEN ROMS
         DEF ERREP.            ! 5. translate moved to rom2
         DEF MSCPY.            ! 6. COPY FILE
COPYTK   EQU 6                 !for copy/create speedup
         DEF MSCRE.            ! 7. CREATE A NEW FILE
         DEF INITI.            ! 8. INITIALIZE A MEDIUM
         DEF MSCHA.            ! 9.  LOAD AND GO
         DEF MSLDB.            ! 10. LOAD BINARY ROUTINE
         DEF MSLOD.            ! 11. LOAD FILE
         DEF MASSS.            ! 12. ASSIGN DEFAULT MSUS
         DEF PRINT.            ! 13. PRINT VALUE ON FILE
         DEF MSSEC.            ! 14. PROTECT A FILE
         DEF MSUNS.            ! 15. REMOVE FILE PROTECT
         DEF MSPUR.            ! 16. REMOVE FILE FROM
!                                       DIRECTORY
         DEF READ.             ! 17. READ FROM A FILE
         DEF MSREN.            ! 18. CHANGE FILE NAME
         DEF MSSTB.            ! 19. SAVE BINARY ROUTINE
         DEF MSSTO.            ! 20. SAVE CAPR FILE
         DEF PACK.             ! 21. PACK A MEDIUM
         DEF VOLUM.            ! 22. ASSIGN VOLUME NAME
         DEF GLOAD.            ! 23. GLOAD RUNTIME
         DEF GSTOR.            ! 24. GSTORE RUNTIME
         DEF ERROM.            ! 25. ERROM RUNTIME
         DEF ERRSC.            ! 26. ERRSC RUNTIME
         DEF TYP.              ! 27. TYPE OF NEXT DATA
         DEF IS.               ! 28. 'IS' RUNTIME
         DEF TO.               ! 29. DUMMY PLACEHOLDER
         DEF TO.               ! 30.'TO' RUN ROUTINE
!THE FOLLOWING TOKENS RESULT FROM PARSING
! PRINT# (PR---.) AND READ# (RD---.).
!      ARR stands for ARRAY
!      NUM   "     "  NUMBER
!      STR   "     "  STRING
!      EOL   "     "  END OF LINE, FOR PRINT# ONLY.
RDNTOK   EQU 31D               ! 31. READ NUMERIC
         DEF RDNUM.  
PRATOK   EQU 32D
         DEF PRARR.            ! 32. PRINT ARRAY
RDSTOK   EQU 33D
         DEF RDSTR.            ! 33. READ STRING
PRNTOK   EQU 34D
         DEF PRNUM.            ! 34 PRINT NUMERIC
PREOL    EQU 35D               ! 35. PRINT EOL
         DEF PREOL.  
PRSTOK   EQU 36D               ! 36 PRINT STRING
         DEF PRSTR.            ! 36. PRINT STRING
RDATOK   EQU 37D               ! 37. READ ARRAY
PARSES   DEF RDARR.  
!NOTE! PRINT tokens must be even to force a comma
!      (not a semi) when listed.
!---------------------------------------------------------
!**333333333333333333333333333333333333333***
!   FOLLOWING IS A TABLE OF ADDRESSES OF    *
!   THE PARSING ROUTINES                    *
!********************************************
         DEF ASSIGN            ! 1. PARSE AN ASSIGN
         DEF CAT               ! 2.PARSE CAT
         DEF CHKOF             ! 3. PARSE CHECKREADOFF
         DEF CHECKR            ! 4. PARSE CHECKREAD
         DEF TRANSL            ! 5. PARSE TRANSLATE
         DEF COPY              ! 6. PARSE COPY
         DEF CREATE            ! 7. PARSE CREATE
         DEF INITIA            ! 8. PARSE INITIALIZE
         DEF CHAIN             ! 9.  PARSE CHAIN
         DEF LOADBI            ! 10. PARSE LOADBIN
         DEF LOAD              ! 11. PARSE LOAD
         DEF MASSST            ! 12.PARSE MASSSTORAGEIS
         DEF PRINT#            ! 13.PARSE PRINT#
         DEF SECURE            ! 14.PARSE SECURE
         DEF UNSECU            ! 15. .PARSE UNSECURE
         DEF PURGE             ! 16. PARSE PURGE
         DEF READ#             ! 17. PARSE READ#
         DEF RENAME            ! 18. PARSE RENAME
         DEF STOREB            ! 19.PARSE STOREBIN
         DEF STORE             ! 20. PARSE STORE
         DEF PACK              ! 21. PARSE PACK
         DEF VOLUME            ! 22. PARSE VOLUME
         DEF GLOAD             ! 23. PARSE GLOAD
         DEF GSTORE            ! 24. PARSE GSTORE
!  DUMMY ROUTINES
         BYT 1,51              ! BINARY INFIX OPERATOR
IS.      BSZ 0
TO.      RTN 
!**444444444444444444444444444444444444444***
!   FOLLOWING IS A LIST OF TOKENS DEFINED   *
!   BY THIS ROM.  EACH ASCII REPRESENTATION *
!   HAS THE HIGH BIT (BIT 7) OF ITS LAST    *
!   CHARACTER SET. (E.G. OF ASSIGN, N (116) *
!   BECOMES (316)).                         *
!                                           *
!   TOKENS AFTER THE 377 (END OF TOKEN      *
!   LIST) ARE USED FOR DECOMPILING BUT ARE  *
!   NOT PARSED BY THE SYSTEM                *
!********************************************
TOKENS   ASP "ASSIGN#"          ! TOKEN 1


         ASP "CAT"              ! TOKEN 2
         ASP "CHECK READ OFF#"  !TOKEN 3




         ASP "CHECK READ#"      ! TOKEN 4



         ASP "TRANSLATE"        ! TOKEN 5


         ASP "COPY"             ! TOKEN 6 

         ASP "CREATE"           ! TOKEN 7

         ASP "INITIALIZE"       ! TOKEN 8



         ASP "CHAIN"            ! TOKEN 9

         ASP "LOADBIN"          ! TOKEN 10


         ASP "LOAD"             ! TOKEN 11

         ASP "MASS STORAGE IS"  !TOKEN 12




         ASP "PRINT#"           ! TOKEN 13 

         ASP "SECURE"           ! TOKEN 14 

         ASP "UNSECURE"        ! TOKEN 15 


         ASP "PURGE"            ! TOKEN 16 

         ASP "READ#"            ! TOKEN 17 

         ASP "RENAME"           ! TOKEN 18 

         ASP "STOREBIN"        ! TOKEN 19


         ASP "STORE"            ! TOKEN 20

         ASP "PACK"             ! TOKEN 21 

         ASP "VOLUME"           ! TOKEN 22 

         ASP "GLOAD"            ! #24

         ASP "GSTORE"           ! #25

         ASP "ERROM"            ! #26

         ASP "ERRSC"            ! #27

         ASP "TYP"              ! #28
ISTOK    EQU 28D               ! 'IS' PARSES THIS ROM
         ASC " IS"              ! TOKEN #28D 
         BYT 240               ! BIASED BLANK
         BYT 377               ! #29:END OF TOKENS MARKER
!
! FOLLOWING ARE TOKENS WHICH LIST AND EXECUTE,
! BUT DON'T PARSE (IN THIS ROM)
!
RTOTOK   EQU 30D               ! ROM TOKEN # 30 DECIMAL
         ASC " TO" 
         BYT 240               !BIASED BLANK
! MASSPARSE.MASROM
!LOC!         LOC 60505
!---------- INITIALIZE PARSE ROUTINE
!--
INITIA   BSZ 0
         PUBD R43,+R6          ! SAVE 'INITIALIZE' TOKEN
         JSB =ROMJSB  
         DEF STREX+            ! CK FOR ANY PARAMS
         BYT 0
         JEZ GOINDO            ! JIF NO PARAMS
         CMB R14,=COMMA        ! CK FOR COMMA
         JNZ GOINDO            ! NO COMMA,NO MORE PARAMS
         JSB =GETSTR           ! GET A STRING
         CMB R14,=COMMA        ! CK FOR COMMA
         JNZ GOINDO            ! NO MORE PARAMS
         JSB =GETNUM           ! GET A NUMBER
         CMB R14,=COMMA        ! CK FOR COMMA
         JNZ GOINDO            ! NO MORE PARAMS
         JMP CHCK+             ! ELSE GETNUM
!---------- END OF INITIALIZE PARSING
!
!
!
!
!
!
!
!
!
!
!---------- CAT PARSE ROUTINE
!--
!--
CAT      BSZ 0
PACK     BSZ 0
         PUBD R43,+R6          ! PUSH ROM TOKEN
         JSB =ROMJSB  
         DEF STREX+            ! GET A STRING
         BYT 0
GOINDO   JMP IND6    
!---------- END OF CAT PARSE ROUTINE
!---------- CREATE PARSE ROUTINE
!--
CREATE   BSZ 0
         PUBD R43,+R6          ! SAVE 'CREATE' TOKEN
         JSB =ROMJSB  
         DEF G$N+NN            ! GET STRING & 1 OR 2
!                                 NUMERICS
         BYT 0
         JMP PURPAR            ! RESTORE TOKEN&GEN.CODE
!---------- END OF CREATE PARSE ROUTINE
!
!
!
!
!
!
!
!
!
!
!---------- PARSE <COMMAND> strex
!-- WHERE <COMMAND> IS ONE OF:
!--   LOAD,LOADBIN,STORE,STOREBIN,
!--   CHAIN,MASS STORAGE IS,
!--   GSTORE,GLOAD
!--
CHAIN    BSZ 0
GLOAD    BSZ 0
GSTORE   BSZ 0
LOAD     BSZ 0                 ! parses in ROM2
LOADBI   BSZ 0                 ! parses & runs in ROM2
STORE    BSZ 0                 ! parses & runs in ROM2
STOREB   BSZ 0                 ! parses & runs in ROM2
MASSST   BSZ 0
         PUBD R43,+R6
         JSB =GETSTR           ! GET A STRING
         JMP IND6    
!----------  END OF <COMMAND> strex PARSING
!----------  CHECKR PARSE ROUTINE
!--  check read [off] now parses and runs in
!--       ******** ROM2 ***************
CHKOF    BSZ 0
CHECKR   BSZ 0
         PUBD R43,+R6          ! SAVE ROM TOKEN
CHCK+    JSB =GETNUM  
         JMP IND6    
!----------   END OF CHECKR PARSE ROUTINE
!
!
!
!
!
!
!
!
!
!
!---------- SECURE (UNSECURE) PARSE ROUTINE
!--
!--
SECURE   BSZ 0
UNSECU   BSZ 0
         PUBD R43,+R6          ! PUSH ROM TOKEN
         JSB =GETSTR           ! GET A STRING
         JSB =GETCOM           ! GET A COMMA
         JSB =GETSTR           ! GET A STRING
         JSB =GETCOM           ! GET A COMMA
         JMP CHCK+             ! RESTORE TOK & GEN. CODE
!---------- END OF SECURE PARSING
!
!
!
!
!
!
!
!
!
!
!---------- PURGE PARSE ROUTINE
!--
PURGE    BSZ 0
         PUBD R43,+R6          ! SAVE 'PURGE' TOKEN
         JSB =ROMJSB  
         DEF GET$N?            ! GET STRING [& 1 NUM]
         BYT 0
PURPAR   DCM R12               !  UNDO AUTO TOKEN GEN.
IND6     JMP IND7              ! RESTORE TOK & GEN CODE
!---------- END OF PURGE PARSE ROUTINE
!---------- READ# PARSE ROUTINE
!--
READ#    BSZ 0
!PARSE READ# ROUTINE
         PUBD R43,+R6          ! SAVE READ# TOKEN
         JSB =ROMJSB  
         DEF G1OR2N            ! GET 1 OR 2 PARAMS
         BYT 0
         DCM R12               ! UNDO G- AUTO CODE GEN
         POBD R53,-R6          ! RESTORE TOKEN INFO
         JSB =PSHROM           ! GENERATE READ# CODE
         CMB R14,=SEMI         ! SEMICOLON SEPARATOR?
         JZR GOTSEM            ! JIF YES
DEMND2   CMB R34,=2            ! NO SEMI, NEED 2 PARAMS
         JNZ ER22D             ! BUFFER/RECORD ERROR
         JMP GORRTN            ! LEAVE ROM
ER22D    JSB =SYSER+           ! SYS ERROR IN PARSING
         BYT 91D               ! MISSING PARAM
!----------
!SEMI SEEN,GET <READ#-LIST>
GOTSEM   JSB =ROMJSB  
         DEF PUSH1A            ! PUSH SEMI AND SCAN
         BYT 0
!SEMI IS PUSHED FOR DECOMPILER ONLY
RD#LST   JSB =RD#ITM           ! GET <READ#-ITEM>
         JEZ ERR23D            !  PARAMETER LIST ERROR
         JSB =ROMJSB  
         DEF GETCM?            !MORE TO BE FOUND?
         BYT 0
         JEN RD#LST            ! MORE IN READLIST
         JMP GORRTN            ! LEAVE ROM
!----------
ERR23D   JSB =SYSER+  
         BYT 92D               ! SYNTAX ERROR
!----------
RD#ITM   BSZ 0                 ! PARSE <READ#-ITEM>
!<FORMAL-ARRAY>?
         JSB =ROMJSB  
         DEF FORMAR            !FIND FORMAL ARRAY
         BYT 0
         LDB R53,=RDATOK       ! GET ARRAY RD TOK
         JEN PUSHRD            ! GEN CODE IF ARRAY FOUND
!<STRING-REFERENCE>?
         JSB =ROMJSB  
         DEF STRREF            !STRING REFERENCE?
         BYT 0
         LDB R53,=RDSTOK       ! GET STRING RD TOK
         JEN PUSHRD            ! GEN CODE IF STR FOUND
!<NUMERIC-VALUE>?
         JSB =ROMJSB  
         DEF REFNUM            !NUMERIC?
         BYT 0
         JEZ REDRTN            ! JIF NOT NUMERIC
         LDB R53,=RDNTOK       ! GET NUMERIC RD TOK
PUSHRD   BSZ 0                 ! GENERATE ROM TOK CODE
PSHROM   LDM R76,=370          ! THE 'CALL-ROM' TOKEN
         VAL MYROM#            ! LDM R76,=370,MYROM#
         PUMD R76,+R12         ! CALL MASS STO. ROM CODE
         PUBD R53,+R12         ! MASS STO. TOKEN
REDRTN   RTN 
!----------  END OF READ# PARSING
!
! *************************************
! translate now parses and runs in ROM2
!
TRANSL   PUBD R43,+R6          !SAVE ROM TOKEN
         JSB =ROMJSB  
         DEF SCAN              !SCAN PAST TOKEN
         BYT 0
IND7     POBD R53,-R6          !RESTORE ROM TOKEN
PUSHIT   JSB =PSHROM           !GEN ROM CODE
GORRTN   GTO ROMRTN            !LEAVE ROM

!---------- PRINT# PARSE ROUTINE
!--
PRINT#   BSZ 0
!
! PARSE PRINT#
!
         PUBD R43,+R6          !PUSH ROM TOKEN
         JSB =ROMJSB  
         DEF G1OR2N            !GET 1 OR 2 NUMERICS
         BYT 0
         DCM R12               !UNDO AUTO. CODE GEN
         POBD R53,-R6          !RESTORE ROM TOKEN
         JSB =PSHROM           !GENERATE PRINT# CODE
         CMB R14,=SEMI         !SEMI SEPARATOR?
         JNZ DEMND2            !IF NOT, NEED 2 PARAMS
         JSB =ROMJSB  
         DEF PUSH1A            !PUSH SEMI & SCAN
         BYT 0
! GET <PRINT#-LIST>
PR#LST   JSB =PR#ITM           !GET <PRINT#-ITEM>
         JEZ ERR23D            ! PARAMETER ERROR
         JSB =ROMJSB  
         DEF GETCM?            !MORE TO BE FOUND?
         BYT 0
         JEN PR#LST            !YES, MORE PARAMETERS
         LDB R53,=PREOL        !GET EOL TOK
         JMP PUSHIT            !GEN CODE & DONE
!----------
PR#ITM   BSZ 0                 !GETS A <PRINT#-ITEM>
!ARRAY?
         JSB =ROMJSB  
         DEF FORMAR            !<FORMAL-ARRAY>?
         BYT 0
         LDB R53,=PRATOK       !ARRAY PRINT TOKEN
         JEN PUSHRD            !GENERATE CODE
!NUMERIC?
         JSB =ROMJSB  
         DEF NUMVAL            !<NUMERIC-VALUE>?
         BYT 0
         LDB R53,=PRNTOK       !NUMERIC PRINT TOKEN
         JEN PUSHRD            !GENERATE CODE
!STRING?
         JSB =ROMJSB  
         DEF STREXP            !<STRING-VALUE>?
         BYT 0
         LDB R53,=PRSTOK       !STRING PRINT TOKEN
         JEN PUSHRD            !GENERATE CODE
         RTN 
!---------- END OF PRINT# PARSING
RENAME   BSZ 0
         PUBD R43,+R6          !SAVE ROM TOKEN
         JSB =GETSTR           !GET A STRING
COPY+    JSB =GETTO            !GET 'TO'
         JSB =GETSTR           !GET 2ND STRING
         JMP TO+TOK            !OUTPUT TO + COMMAND TOKS
!-----------
COPY     BSZ 0
         PUBD R43,+R6          !SAVE ROM TOKEN
         JSB =ROMJSB  
         DEF STREX+            !STRING EXISTS?
         BYT 0
         JEN COPY+             !YES-MSROM COPY
         POBD R43,-R6          !DELETE MS TOKEN
         LDB R43,=174          !SYSTEM SCREEN COPY
         PUBD R43,+R12         !GENERATE CODE
         JMP GORRTN            !RETURN
!----------  ASSIGN PARSE ROUTINE
!--
ASSIGN   BSZ 0                 !PARSE ASSIGN
         PUBD R43,+R6          !SAVE ROM TOKEN
         JSB =GETNUM           !GET A NUM
         JSB =GETTO            !GET 'TO'
         CMB R20,=STAR         !IS NEXT CHAR A STAR?
!                                I.E. ASSIGN - TO * ?
         JZR CLOSF             !JIF SO
         JSB =GETSTR           !GET A STRING
         CMB R14,=100          !@ FOLLOWS ASSIGN# ?
         JNZ TO+TOK            !NOPE
         TSB R16               !CALC MODE?
         JEV TO+TOK            !NOPEd CALC --> ERROR!
!DONT ALLOW ANYTHING AFTER ASSIGN# IN CALC MODE!
         JSB =DMNDCR           !DEMAND CR OR !
         POBD R#,-R6           !POP TOKEN
         RTN 
TO+TOK   LDB R53,=RTOTOK       !GET 'TO' TOK
IS+TOK   JSB =PSHROM           !OUTPUT IT
         POBD R53,-R6          !COMMAND TOKEN
         GTO PUSHIT            !GENERATE CODE

!----------
CLOSF    LDM R45,=6,1,52       !UNQUOTED STRING

         PUMD R45,+R12         !OUTPUT THE CODE
         JSB =ROMJSB  
         DEF SCAN+             !ADVANCE PAST *
         BYT 0
         JMP TO+TOK  
!----------
!
!
!
!
!
!
!
!
!
!
!
VOLUME   BSZ 0
         PUBD R43,+R6          !SAVE ROM TOKEN
         JSB =GETSTR           !GET A STRING
         CMB R43,=ISTOK        !FIND IS
         JZR VOK               !JIF IS FOUND
         JSB =ER91D+           !MISSING TO/IS
VOK      JSB =GETSTR           !GET 2ND STRING
         LDB R53,=ISTOK        !GET IS TOKEN
         JMP IS+TOK  
! MASSRUN1.MASROM
GETMSU   LDM R26,R12           !HOW MANY PARAMETERS?
         SBMD R26,=TOS         !IF R12-TOS=0 THEN NONE
         JZR NOPAR             !MUST HAVE NO PARAMS
         LDB R40,=2            !ALLOW MSUS ONLY
DCDFIL   JSB =DECODE  
DCD+     STMD R44,X14,ACTMSU   !NEW ACTIVE MSUS

         RTN 
NOPAR    LDMD R44,X14,DEFMSU   !GET DEFAULT MSUS

         JMP DCD+    
!-------------------------------------------------------------------
TCAT     JSB =ROMJSB  
         DEF CAT.              !TAPE CATALOG
         BYT 0
         RTN 
         BYT 241
MSCAT.   BSZ 0
         JSB =MSIN             !RUNTIME INIT
         JSB =GETMSU           !INIT & GET MSUS
         JZR TCAT              !TAPE CATALOG
!DO A CATALOG OF DISC ADDRESSED R45,46,47
!PRINT VOLUME LABEL
         JSB =GETDIR           !GET VOL.LAB,1ST DIR.ENTRY
         STM R14,R26           !PRTBUF OFFSET ZERO
         JSB =PSHVOL  
!        DRP !42
!        ARP !26
         LDMD R#,=VLHD#2       !VOLUME HEADING
         PUMD R#,+R#           !PUSH IT
         LDMD R#,X14,SPECIF    !GET VOL.NAME

         PUMD R#,+R26          !PUSH VOLUME NAME
         LDB R#,=15            !CARRIAGE RETURN
         PUBD R#,+R26          !OUTPUT IT TOO
         LDM R36,=19D,0        !VOLHED LENGTH

         JSB =DRIVER           !OUTPUT IT
!MOVE HEADING FROM ROM TO RAM FOR OUTPUT
         LDM R24,=CATHED       !ROM SOURCE

         LDM R26,R14           !PRTBUF OFFSET ZERO
         LDM R22,=31D,0        !30 BYTES

         JSB =MOVUP            !MOVE ROM TO RAM
!PRINT HEADING
         JSB =DRIVE-           !OUTPUT BUFFER
         JSB =RBUF36           !RESTORE DIR.PTR
!NOW OUTPUT EACH CAT ENTRY
CATLOP   BSZ 0
         LDMD R26,=SVCWRD      !EXIT IF KEY PRESSED

         JOD CATDON  
         LDM R26,R14           !PRTBUF OFFSET ZERO
!PRINT OUT TYPE,BYTES/LREC,LRECS
         JSB =GETTYP           !GET FILE TYPE
         CLM R56               !CLEAR 57 FOR TYPE INDEXING
         LDB R56,R30           !FILE TYPE
!
!Summary of disk file types and type-table lookup:
!  type=377 --> next available file
!  type=0   --> empty (hole) file
!  type bit set (msb7 to lsb0)
!   2       --> **** extended file type(GRAF,ASCI,etc.)
!   3       --> BPGM
!   4       --> DATA
!   5       --> PROG
!
         CMB R56,=377          !LAST FILE?
         JZR CATDON            !'TWAS
         LDMD R43,=BLANKS      !BLANKS IF EMPTY

         STM R43,R63           !(OR LIST SECURED)
         TSB R56               !CHECK DATA SECURED
         JOD BLDUN             !JIF SECURED
         JZR NULL              !JIF EMPTY
         LDMD R43,R36          !GET THE NAME
         LDMD R63,X36,SEC1/2   !2ND 1/2 NAME

         JMP BLDUN   
NULL     LDB R50,=100          !SET NULL BIT FOR TYPE CHK
         ORB R56,R50           !(FOR TYPE TABLE)
BLDUN    PUMD R43,+R26         !NAME TO PRTBUF
         PUMD R63,+R26         !2ND HALF NAME
         LDMD R42,=BLANKS      !R42,3:=BLANK

         LRB R56               !NULL->40,ALL->2
         LRB R56               !NULL->20,ALL->1
         JEV NOTEXT            !JIF NOT EXTENDED
!For interchange files must create BYTES/LOG.REC
!field for CAT 'Bytes' and 'Recs' to be correct
         LDM R56,=0,1          !256 BYTES/REC
         STMD R56,X36,D.B/RC   !INTO CAT ENTRY

         CLM R56               !CATALOG '****'
NOTEXT   JLN DNSHFT            !JIF NULL
         LRB R56               !PROG->4,ALL->0
         LLB R56               !PROG->10,ALL->0
         LLB R56               !PROG->20,ALL->0
         JLZ DNSHFT            !JIF DATA,BPGM,ALL
         LDB R56,=14           !FORCE PROG TYPE
DNSHFT   LDMD R44,X56,CATTAB   !GET TYPE

         PUMD R42,+R26         !TYPE TO PRTBUF
         PUMD R36,+R6          !SAVE DIR PTR
         LDMD R36,X36,D.B/RC   !BYTES/REC

         JSB =NM2ASC           !NUM->ASCII
         POMD R36,-R6          !RESTORE DIR PTR
         JSB =LOGREC           !COMPUTE LOG.RECS
         LDM R26,R30           !ASCII GOES HERE
         JSB =NM2ASC           ! NUM->ASCII
         JSB =DRIVE-           !OUTPUT BUFFER
         JSB =NXTENT           !GET NXT DIR.ENTRY
         JEZ CATLOP  
CATDON   RTN 
!---------------------------------------------------------
T.ASCI   EQU 4D                !FOR SAVE/GET INTERCHANGE
T.GRAF   EQU 4D                !FOR GLOAD, GSAVE
!ALL EXTENTED TYPES ARE THE SAME. THIS MEANS COPY
!MUST MAP DIFFERENT TAPE EXTENDED TYPES TO ONE BYTE
!OF DISC TYPE WITH ONE BIT EXTENDED.
!---------------------------------------------------------
DRIVE-   LDM R36,=31D,0        !SEND OUTPUT

DRIVER   BSZ 0                 !CALL SYSTEM OUTPUT DRIVER
         LDM R26,R14           !PRTBUF OFFSET ZERO
         JSB =ROMJSB  
         DEF DISP.             !INITIALIZE DRIVER
         BYT 0
         JSB =ROMJSB  
         DEF DRV12.            !DO OUTPUT
         BYT 0
         JSB =INIT14           !DRIVER DESTROYS R14
         RTN 
!-----------------------------------------------------------
GETTYP   BSZ 0
!CONVERTS 2-BYTE INTERCHANGE DISC TYPE TO
!1-BYTE DISC TYPE.
!THERE ARE 3 SPECIAL CASES:
! 1: 0 MEANS PURGED FILE, STAYS 0
! 2: 1 MEANS ASCII FILE, BECOMES T.ASCI
! 3: -1 MEANS NEXT-AVAIL FILE, STAYS -1
!NOTE: -16001 <= INTERCHANGE CAPR TYPES <= -20000 (octal)
!       i.e. CAPR FILE TYPE - 20000 --> INTERCHANGE CAPR TYPE
         LDMD R30,X36,D.FTYP   !GET INTERCHANGE TYPE

         STB R31,R77           !SWAP BYTES
         LDB R31,R30
         LDB R30,R77           !SWAP DONE
         TSM R30
         JZR GETLST            !JIF PURGED FILE
         CMM R30,=377,377      !NEXT-AVAIL FILE?
         JZR GETLST            !JIF YES
         CMM R30,=1,0          !ASCI FILE?
         JNZ GETCAP            !JIF REGULAR FILE
         LDB R30,=T.ASCI       !INTERCHNG ASCII --> CAPR ASCI
GETLST   TSB R#                !R30
         RTN 
GETCAP   ADM R#,=CVDOFF        !INTERCHNG CAPR --> CAPR CAPR
CVDOFF   DAD 20000             !CORVALLIS DIV OFFSET
         RTN 
!----------------------------------------------------------
PUTTYP   BSZ 0
!REVERSE OF GETTYP
         CLB R31               !FOR INTERCHANGE CONVERSION
         TSB R30               !WHAT KIND CAPR FILE?
         JZR PUTLST            !JIF PURGED FILE
         ICB R30               !NEXT-AVAIL FILE?
         JZR PUTNXT            !JIF SO
         DCB R30               !RESTORE TYPE
         CMB R30,=T.ASCI       !ASCII FILE TYPE?
         JZR PUTASC            !YES
!ITS A REGULAR CAPR FILE TYPE:
         SBM R30,=CVDOFF       !CONVERT CAPR TO INTERCHANGE
         JMP PUTLST  
PUTASC   LDB R#,=2             !ASCII + 1
PUTNXT   DCM R#                !ASCII-->1,NEXT-AV-->-1
PUTLST   STB R#,R32            !SWAP R30,R31
         LDB R#,R31
         STB R32,R31
         STMD R30,X36,D.FTYP   !READY FOR INTERCHANGE DISC

         RTN 
!----------------------------------------------------------
NM2ASC   BSZ 0
         JSB =ROMJSB           !TRANSLATE INTEGER R36
         DEF CATCO-            !TO ASCII STR ADDR R26
         BYT 0
         RTN 
!---------------------------------------------------------
LOGREC   BSZ 0
!COMPUT LOG REC COUNT
         DRP R46
         JSB =LDRECS  
         LDMD R32,X36,D.B/RC   !BYTES/REC

LOGRE+   CLB R45               !SEE ABOVE
         CLB R34
         JSB =COMLO+           !COMPUTE LOG.RECS.
         RTN 
!-----------------------------------------------------------
!VOLHED  ASC 8D,Volume:
!VOL HEADING HAS BEEN MOVED TO ERROR MSG TABLE IN CRUNCH
CATHED   ASC "Name        Type  Bytes   Recs"
         BYT 15                !CARRIAGE RETURN
!SECTOR OFFSETS FOR DISC INITIALIZATION
!VOLUME OFFSETS
V.ID     EQU 0                 !DISC ID
V.LABL   EQU 2                 !VOLUME LABEL
V.DBEG   EQU 10D               !START OF DIRECTORY
V.DLEN   EQU 18D               !LENGTH OF DIRECTORY
V.1000   EQU 12D               !SYSTEM 3000 CONSTANT !?!
!DIRECTORY OFFSETS (<=32D)
D.FTYP   EQU 10D               !FILE TYPE IN DIR. ENTRY
D.RECS   EQU 18D               !FILE LENGTH IN SECTORS
D.BYTS   EQU 28D               !FILE LENGTH IN BYTES
D.FBEG   EQU 14D               !START OF FILE (SECTOR#)
D.B/RC   EQU 30D               !BYTES/LOGICAL RECORD
D.VOL    EQU 26D               !      ENTIRE FILE IN THIS VOLUME
!
         BYT 241
INITI.   BSZ 0
         JSB =MSIN             !      RUNTIME INIT
         LDMD R44,X14,DEFMSU   !DEFAULT IF NO MSUS

         STMD R44,X14,ACTMSU  
!PREPARE VOLLAB TEMPLATE W/DEFAULTS
         JSB =CLRSEC           !ZERO SECTOR
         JSB =RBUF36           !BUFFER BASE
         LDB R52,=200          !THE VOLUME ID
         STBD R52,R36          !SINCE V.ID=0
         LDMD R52,=BLANKS      !DEF VOL.NAME
         STMD R52,X36,V.LABL  
         LDM R55,=0,2,20       !DEF DIR. START SECTOR#

!NOTE! ^this is 2D  in INTERCHANGE format (ie swapped)
         STMD R55,X36,V.DBEG  
         LDM R56,=0,14D        !INTCHNG DEF DIRLEN

         STMD R56,X36,V.DLEN   !...INTO VOLUME LABEL
         LDM R56,=14D,0        !CAPR FORMAT DEF DIRLEN
         PUMD R56,+R6          !FOR DIR.INIT.LOOP
         LDB R56,=5            !DEFAULT INTERLEAVE FACTOR
         PUMD R56,+R6          !SAVE FOR FORMAT
!HOW MANY PARAMS?
         LDM R32,R12
         SBMD R32,=TOS         !# BYTES ON STACK
         CMB R32,=17D          !interleave factor?
         JPS ISINTL            !JIF SO
         CMB R32,=9D           !directory sectors?
         JPS ISENT             !JIF SO
         CMB R32,=5D           !msus?
         JPS ISMSUS            !JIF SO
         TSB R32               !volume label?
         JNZ VOLLON            !JIF SO
         JMP INIDSK            !OTHERWISE NO PARAMS
!
ISINTL   JSB =ONEB             !GET INTEGER
         POMD R36,-R6          !POP DEFAULT INTERLEAVE
         PUMD R46,+R6          !SAVE USER SUPPLIED
ISENT    JSB =ONEB             !GET INTEGER
         JNZ ENTSOK  
INVAL    JSB =ER89D            !INVALID PARAM
ENTSOK   POMD R54,-R6          !REPLACE 2ND PARAM ON STAK)
         STM R46,R54           !REPLACE ENTRIES PARAM
         PUMD R54,+R6          !NOW SWITCHED, PUSH BOTH PARAMS
ISMSUS   CLB R40               !ALLOW ANY MSUS
         JSB =DCDFIL           !DECODE MSUS
!       TSB R44           !TAPE OR DISC?
         JNZ VOLLON            !JIF DISC
ER18D+   JSB =ER18D            !TAPE NOT ALLOWED
!
VOLLON   BSZ 0
         JSB =GETNA!           !6-CH NAME BLANKFILLED
         POMD R54,-R6          !54:=ENTRIES,56:=INTLV
         PUMD R54,+R6          !BACK FOR LOOPS
!SWAP R54 ENTRIES INTO R56
         STB R54,R57
         STB R55,R56           !SWAP DONE
         CMB R42,=PERIOD       ! 1st char '.'?
         JZR INVAL             ! jif yes invalid param
         CMB R42,=COLON        ! 1st char ':'?
         JZR INVAL             ! jif yes invalid param
         JSB =SETDIR           ! save vol label & dir len
!        JSB =RBUF36
!        STMD R42,X36,V.LABL    !SAVE VOLUME LABEL
!        STMD R56,X36,V.DLEN    !SAVE DIR LENGTH
!
!LOC!         LOC 62317
INIDSK   BSZ 0                 !INITIALIZE A DISC
         LDBD R30,X14,ACTMSU   ! test for active msus

         JZR ER18D+            ! jif no disc active
         POMD R30,-R6          !POP INTERLEAVE
         JSB =HLFMT            !FORMAT THE DISC (ACT.MSUS)
         CLM R32
!-----------------------------------------------------------
         JSB =MAK2             ! create first 2 sectors
!        JSB =PUTBUF            !OUTPUT VOLUME LABEL
!CREATE,WRITE NULL DIRECTORY
!        JSB =CLRSEC            !CLEAR SECTOR
!OUTPUT ONE RECORD OF 0's FOR INTERCHANGE
!        JSB =PUTBU+            !THE 2ND SECTOR
!NULL DIRECTORY CREATION
         LDB R47,=8D           !8 ENTRIES/SECTOR COUNT
         JSB =RBUF36           !SECTOR BASE
         CLM R56               !EACH FILE FLAGGED LAST
         DCM R56
         LDM R66,=177,377      !AND HAS INFINITE LENGTH

!LOC!         LOC 62355
!Note: ^ this is INTERCHANGE for MAXINT
ILOP1    STMD R56,X36,D.FTYP   !MAKE 'LAST' FILE

         DRP R66
         JSB =STRECS  
         ADM R36,=32D,0        !BUMP DIR PTR

         DCB R47               !COUNTER
         JNZ ILOP1             !DO FOR EACH ENTRY
!WRITE 'entries' OF THESE EMPTY SECTORS
ILOP2    JSB =PUTBU+           !WRITE ONE DIR SECTOR
         POMD R36,-R6          !RESTORE COUNTER
         DCM R36
         PUMD R36,+R6          !AND SAVE IT
         JNZ ILOP2             !REPEAT FOR entries SECTORS
         POMD R36,-R6          !DELETE COUNTER
         RTN 
         BYT 241
MSCHA.   BSZ 0
         ARP R0
         JSB =SYSJSB           !INTERCEPT TAPE
         JSB =ROMJSB  
         DEF SETTR1            !RESET TRACE INFO
         BYT 0
         LDMD R56,=FWPRGM  

         STMD R56,=FWCURR  
         JSB =CALTAP           ! GO LOAD IT
         JSB =ROMJSB  
         DEF CHAIN+            !TAPE CHAIN POST-PROCESSING
         BYT 0
SECQUI   RTN 
         BYT 241
MSSTB.   BSZ 0
         JSB =ROMJSB  
         DEF MSSTB+            ! ROM2 storebinary
         VAL MSROM2  
         RTN 
MSSTB+   DAD 61161             ! DON'T HAVE SOLID ADDR YET
! INITFIXES.MASROM
MAK2     BSZ 0                 ! CREATE FIRST 2 SECTORS
         JSB =PUTBUF           ! OUTPUT VOLUME LABEL
         JSB =CLRSEC           ! CLEAR SECTOR
         JSB =PUTBU+           !    THE SECOND SECTOR
         RTN 
!-----------------------------------------------------------
SETDIR   BSZ 0                 ! SET VOLUME NAME & DIR LEN
         JSB =RBUF36           ! GET SECTOR BASE ADDR
         STMD R42,X36,V.LABL   ! SAVE VOLUME NAME

         STMD R56,X36,V.DLEN   ! SAVE DIR LEN

         RTN 
! MKROM2.MASROM
MKROM2   BSZ 0                 ! MAKES ROOM IN HLSEEK FOR
         JSB =LLINIT           ! HOOK ARP FLAG
         JSB =SEEK    
         RTN 
!MASSTORE.MASROM
!LOC!         LOC 62514
         BYT 141
MSSTO.   BSZ 0
         JSB =ROMJSB           ! store moved to
         DEF MSSTO2            ! second rom
         VAL MSROM2  
         RTN 
MSSTO2   DAD 61056             ! DON'T HAVE SOLID ADDR YET
! IOPFIXES.MASROM
REDCCR   BSZ 0
         LDBD R46,R76          !TRASH IB
         LDB R46,=60
         STBD R46,R76          ! SEND COMMAND
         LDB R46,=2
         STBD R46,R26          ! RESET INT=0 AND COM=1
         RTN 
!-------------------------------------------------------
REDPSR   BSZ 0
         LDBD R47,R26          !READ PSR
         ANM R47,=10
         RTN 
!------------------------------------------------------
INIT57   BSZ 0
         LDB R57,=1
         STBD R#,=GINTEN  
         RTN 
! DONAME.MASROM
DONAME   BSZ 0
         ADM R12,=10,0

         PUMD R32,+R12
         PUMD R34,+R12
         JSB =GETNA!  
         RTN 
! HOOK.MASROM
HOOK     BSZ 0
         SAD                   ! SAVE ARP FLAG ON STACK
         JSB X14,MSLOW         ! JMP TO SYS HOOK

         PAD                   ! IF RTN CLEAR STACK
         RTN                   ! RTN TO ROUTINE
! MASSRUN2.MASROM
!LOC!         LOC 62600
NREPO-   JSB =INIVAR           !ALLOC GOOD,INIT VARS
NREPOR   LDMD R56,=FWCURR      !START OF PGM

         LDBD R56,X56,P.TYPE   !CHECK FOR COMMON

         JPS NOCOMN  
         JSB =ROMJSB  
         DEF FXDIR             !DEALLOC PGMS WITH COMMON
         BYT 0
         LDMD R12,=NXTMEM  

NOCOMN   STMD R12,=STSIZE  

         JSB =RELMEM           !RELEASE TEMP MEM
!(such as in LOAD A$&B$)
         LDM R#,R#             !R56:=FWCURR
         LDMD R76,X56,P.LEN    !GET PROGRAM LENGTH

         BIN                   !FOR ADDS THAT FOLLOW
         ADM R76,R56           !COMPUTE LAST DATA ADDR
         LDBD R67,X56,P.TYPE  

         ANM R67,=40           !ALLOCATION BIT
         JZR STRB-             !JIF NOT ALLOCATED
         ADMD R76,R76          ! GET DATA LENGTTH
STRB-    JSB =INIT14           !AFTER SYSTEM STUFF
STORB-   STMD R76,=LSTDAT  

         STMD R56,=NXTDAT      !SET 1ST WORD TO STORE

         JSB =FILOK?           !SCAN FILE,CK TYPE,LEN
DO.BUF   JSB =GETBU!           !GET SOME PROG
         JEZ NOBUFR            !DONE IF E=0
         LDM R30,R56           !DATA ADDR
         JSB =PUTSE+           !TO DISC
         JMP DO.BUF  
NOBUFR   RTN 
! MASSRUN3.MASROM
!---------------------------------------------------
!Does a disk file exist? If so, is it of correct
!type and length for writing onto?
! Incorrect type-->causes error 68 wrong file type
! Soft wrt.protect-->error 60, soft w/protect
!If file exists but required length is too small,
!old entry is purged and new file created. Required
!length is obtained from routine GETCNT.
!SEEK is performed to ready file data writes.
!For update of old, new file creation:
! D.RECS from GETCNT routine
! D.TYPE from FILTYP
! D.BYTS from LSTDAT-NXTDAT
! D.B/RC is   256
! name   from FNAM,FNAM+5(x14)
FILOK?   JSB =DIRSCN           !SCAN DIR. FOR NAME
         JEZ GOTNAM            !FOUND NAME
         JSB =MTSCAN           !LOOK FOR EMPTYS
         JMP MT?               !EMPTY OR MARK?
BADLEN   LDMD R45,X14,DENTRY   !GET OLD DIR INFO

         STMD R45,R14          !KEEP OLD DENTRY,DADDR
         JSB =MTSCAN           !LOOK FOR EMPTYS
         JSB =WRTDIR           !SAVE NEW(UPDATED)DIR
         LDMD R45,X14,DENTRY   !GET NEW DIR INFO

         PUMD R45,+R6          !SAVE IT
         LDMD R45,R14          !RESTORE OLD DIR INFO
         STMD R45,X14,DENTRY   !END RESTORE
         LDM R32,R46           !GET SECTOR# DADDR
         JSB =GETBUF           !RESTORE OLD DIRECTORY
         JSB =PURFIL           !PURGE OLD FILE
         POMD R45,-R6          !RESTORE NEW DIR INFO
         STMD R45,X14,DENTRY  

         STM R46,R32           !GETSEC TARGET SECTOR
         JSB =GETBUF           !RESTORE NEW DIRECTORY
MT?      JSB =DIRPTR           !R36:=DIR PTR(DENTRY,DADDR)
         STM R#,R34            !FOR PUSHING NAME
         LDMD R43,X14,FNAM     !NAME 1ST HALF

         PUMD R43,+R34         !TO DIRECTORY
         LDMD R43,X14,FNAM+5   !NAME 2ND HALF

         PUMD R43,+R34         !TO DIR
         LDBD R30,=FILTYP      !GET FILE TYPE

         JSB =PUTTYP           !UPDATE FILE TYPE
         JMP TYPOK             !NOW WRITE FILE AND DIR.
!********************************************
GOTNAM   JSB =GETTYP           !DO TYPE CHECK
         LRB R#                !CHECK SOFT W/PROTECT
         JOD ER60D   
         LLB R#                !SHIFT BACK FOR AND
         LDB R33,R30           !FOR 'ANM'
         ANMD R33,=FILTYP      !PROGRAM TYPE FILE?
         JNZ TYPOK   
ER68D    JSB =MSERR+           !SYSTEM ERROR
         BYT 68D               !WRONG FILE TYPE
ER60D    JSB =MSERR+           !SOFT W/PROTECT
         BYT 60D
TYPOK    BSZ 0
         JSB =GETCNT           !GET PROG LENGTH
         DRP R34
         JSB =LDRECS  
         SBM R#,R32            !FILE BIG ENOUGH?
         JNC BADLEN  
         LDMD R32,=LSTDAT      !END ADDRESS

         SBMD R32,=NXTDAT      !BEG ADDR OF PROG
         STMD R32,X36,D.BYTS   !UPDATE PROG LENGTH

         LDM R32,=0,1          !256B/LOG.REC.
         STMD R32,X36,D.B/RC   !UPDATE LOG.REC.LEN.
         JSB =LDFBEG  
         PUMD R32,+R6          !STASH SEEK ADDR
         JSB =WRTDIR           !REWRITE DIR
         POMD R30,-R6          !RESTORE SEEK ADDR
         JSB =HLSEEK           !  GO TO IT
         RTN 
DIRSCN   BSZ 0
!SCAN DIRECTORY OF ACTIVE MSUS FOR NAME IN
! FNAM,FNAM+5               RETURNS:
!               E=0 IF NAME FOUND
!               E=1 IF NAME NOT FOUND
!               R36 IS DIR. POINTER IF E=0
         JSB =GETDIR           !GET 1ST DIR SECTR
         CLE                   !FOUND FLAG
DLOOP    JSB =GETTYP           !FILE TYPE
         JZR NXTPAS            !JIF NULL FILE
         ICB R#                !TEST FOR LAST FILE
         JZR DDONE             !NO MORE FILES
         LDMD R43,R36          !LOAD 1ST 1/2 NAME
         LDMD R53,X14,FNAM     !SAME SO FAR?

         CMM R53,R43           !SAME SO FAR?
         JNZ NXTPAS            !DIFFRENT FIRST HALVES
         LDMD R43,X36,SEC1/2   !LOAD 2ND HALF

         LDMD R53,X14,FNAM+5   !SAME THRU-OUT?

         CMM R53,R43           !SAME THRU-OUT?
         JZR DFOUND            !NAME MATCH
NXTPAS   JSB =NXTENT           !GET NEXT DIR ENTRY
         JEZ DLOOP             !JIF NOT DIR.END
DDONE    ICE                   !FLAG FAILURE
DFOUND   RTN 
!------------------------------------------------------
!FIND THE 1ST HOLE--USED IN PACK
HOLE#1   CLM R30               !0-SZ HOLE FOR MTSCAN
         STMD R#,=CR.CNT       !FOR FILE SIZE
         LDB R#,=DATATY  
         STBD R#,=FILTYP  
!FALL THRU TO MTSCAN
MTSCAN   BSZ 0
!SCAN DIR OF ACTIVE MSUS TO FIND A HOLE BIG ENUF
!FOR A STORE. ERROR EXIT IF NO HOLE BIG ENUF.
         JSB =GETDIR           !FIRST DIR ENTRY
NXTONE   BSZ 0
         LDMD R20,X14,CUMREC   !CUMMUL.REC.CNT

         DRP R22
         JSB =LDRECS  
         JSB =GETCNT           !R32:=NEC FILE SIZE
         JSB =GETTYP           !    FILE TYPE
         ICB R#                !    LAST FILE?
         JZR LASTFI            !    YES
         DCB R#                !    HOLE FILE?
         JNZ NEMPTY            !    NOT A HOLE
         CMM R22,R32           !    FILE LEN. - PROG LEN.
         JCY DFOUND            !    HOLE BIG ENUF
NEMPTY   BSZ 0
         ADM R20,R22           !    CUMREC:=CUMREC+FILE LEN
         STMD R20,X14,CUMREC  

         JSB =NXTENT           !    NXT DIR ENTRY
         JEZ NXTONE            !    JIF NOT DIR.END
         JSB =MSERR   
         BYT 24D               !    DIR OVERFLOW
!MAKE SURE ENTIRE FILE WILL FIT IN THIS DISC VOLUME
LASTFI   BSZ 0
         DRP R32               !    FILERECS:=NEC FILE SIZE
         JSB =STRECS  
         DRP R20               !    FILEORG:=CUMREC
         JSB =STFBEG  
         ADM R#,R32            !BEG NEW FILE + FILE SIZE
         JNC CKDISK            !CHECK DISK SIZE
         JMP ER28D             !DEFINITE SIZE PROBLEM!
CKDISK   PUMD R#,+R6           !SAVE FROM TOID
         JSB =TOID    
         POMD R34,-R6          !RESTORE AFTER TOID
         CMM R46,R34           !MEDIUM SIZE - END NEW FILE
         JCY DIRPTR            !     IT FITS. RESTORE DIR PTR
ER28D    JSB =MSERR   
         BYT 28D               !    DISC SIZE TOO SMALL
!--------------------------------------------------------
GETDIR   BSZ 0
!GETS 1ST SECTOR OF DIR. OF ACTIVE MSUS
!DIR POINTER (X14)DENTRY POINTS AT 1ST DIR ENTRY
!Note! Performs INTERCHANGE-->CAPR conversion for
!V.DBEG and V.DLEN in volume label.
         CLM R32               ! SECTOR#0
         JSB =GETD+            !READ VOL LABEL
GETDR+   BSZ 0
         JSB =RBUF36           !VOL LABEL BASE
         LDMD R42,X36,V.LABL   !GET VOL NAME

         STMD R42,X14,SPECIF   !STASH FOR CAT

         LDMD R46,X36,V.DBEG   !WHERE DIR STARTS

         STB R46,R77           !SWAP 46,47
         LDB R46,R47
         STB R77,R47           !SWAP COMPLETE
         CLB R45               !INIT DENTRY
         STMD R45,X14,DENTRY   !MARK IT

         LDM R32,R46           !FIRST DIR SECTOR
         LDMD R30,X36,V.DLEN   !FIND END OF DIRECTORY

         STB R30,R77
         LDB R30,R31
         STB R77,R31           !SWAP COMPLETE
         ADM R30,R46           ! NEXT FILE ORIGIN
         STMD R30,X14,CUMREC   !(FOR MTSCAN)

         STMD R30,X14,LSTDIR   !DIR.END FOR NXTENT
GETD+    JSB =GETBUF           !GET 1ST DIR.SECTOR
RBUF36   LDM R36,=RECBUF       !POINT AT DIR

         RTN 
!------------------------------------------------------
NXTENT   BSZ 0
!Advances to next entry (if one exists then E:=0
!else E:=1).
!Directory scanning must follow the sequence:
!  GETDIR
!  zero or more NXTENTs
!  read/write any directory info
!  zero or more NXTENTs
!  WRTDIR
         CLE                   !DIR.END REACHED IF E=1
         JSB =DIRPTR           !R36:=DIR PTR
!MOVES DIR POINTER TO NEXT DIR ENTRY
         LDMD R45,X14,DENTRY   !GET PTR

         ADB R45,=32D          !BUMP TO NEXT ENTRY
         STBD R45,X14,DENTRY   !UPDATE
         JNZ NXTFIN            !DONT NEED NEW SECTOR
         ICM R46               !DADDR
         STMD R46,X14,DADDR   
         LDMD R30,X14,LSTDIR   !LAST DIR SECTOR

         CMM R30,R46           !PASSED IT?
         JZR ENDDIR            !YES: LSTDIR=DENTRY
         LDM R32,R46           !NEXT DIR SECTOR
         JSB =GETBUF           !ANOTHER DIR SECTOR
         CLE                   !AFTER LOW-LEVEL
NXTFIN   BSZ 0
DIRPTR   CLM R36
         LDBD R36,X14,DENTRY   !DIR ENTRY

         ADM R36,=RECBUF       !DIR BASE
         RTN 
!-------------------------------------------------
ENDDIR   ICE 
         RTN 
!-------------------------------------------------
!The following routines swap 2 bytes before storing/
!after reading in order to perform INTERCHANGE<-->CAPR
!conversion. (Interchange format calls for most
!significant byte to precede least.)
STFBEG   BSZ 0                 !SWAP-STORE R#,X36,D.FBEG
         JSB =SWAP+   
         STMD R#,X36,D.FBEG    !R# NOW SWAPPED

         JMP SWAP+             !UNSWAP R#
!------------
!------------
LDFBEG   SAD                   !SWAP-LOAD R#,X36,D.FBEG
         LDMD R#,X36,D.FBEG  

         JMP SWAP1   
STRECS   JSB =SWAP+            !SWAP STORE R#,X36,D.RECS
         STMD R#,X36,D.RECS  

SWAP+    SAD 
SWAP1    STM R#,R70
         STB R#,R77            !SWAP R70,R71
         LDB R70,R71
         STB R77,R71           !SWAP COMPLETE
         PAD 
         LDM R#,R70
         RTN 
!------------
LDRECS   SAD                   !SWAP-LOAD R#,X36,D.RECS
         LDMD R#,X36,D.RECS  

         JMP SWAP1   
         BYT 241
MSLDB.   BSZ 0
         JSB =ROMJSB  
         DEF MSLDB+            ! ROM2 load binary
         VAL MSROM2  
         RTN 
MSLDB+   DAD 61237             ! DON'T HAVE SOLID ADDR YET
! CKHPIB.MASROM
CKHPIB   BSZ 0
         LDB R60,=1            ! DISC FLAG
         CLB R63               ! DUMMY UNIT(0)
         LDM R44,R60
         JSB =PUTMSU  
         BIN                   ! SET UP FOR DATA INFO
         LDM R66,R14           ! GET DATA BUFFER ADDRESS
         ADM R66,=DATAB   
         JSB =SETCCR  
         STMD R76,=INCRA       ! SAVE CCR ADDRESS

         STM R46,R22
         LDM R0,=300,10

         CLB R46
         JSB =CKANSW  
         CMB R#,=1
         RTN 
! VOLHED#2.MASROM
VLHED2   ASC "[ Volu"           ! 1ST PART OF HEADER

VLHD#2   ASC "me ]: "           ! 2ND PART OF HEADER

! MASSRUN4.MASROM
!LOC!         LOC 63677
         BYT 141
MSLOD.   BSZ 0
         ARP R10
         JSB =SYSJSB           !INTERCEPT TAPE
         LDB R36,=5            !ROMINI #5
         STBD R36,=ROMFL   
         JSB =ROMJSB  
         DEF SCRA.-            !STORE AND SCRATCH
         BYT 0
         JSB =INIT14           !SYSTEM DESTROYS!
!AUTOST STMD R6,=SAVER6     FOR AUTOST
!(NO PROVISION FOR DISC AUTOSTART)
         ICB R16               !FOR ERRORS
         JSB =LOAD+            !FOR ERROR INTERCEPT
         CLB R16
LDCOM!   JSB =ROMJSB           !LOAD POST PROCESSING
         DEF LDCOMN            !SYSTEM
         BYT 0
         RTN 
!-------------------------------------------------------
CALTAP   BSZ 0                 !FOR CHAIN
         JSB =LOAD+   
         JMP LDCOM!  
!--------------------------------------------------------
LOAD+    LDB R56,=CAPRTY       !SET FILE TYPE
         STBD R56,=FILTYP  
         LDMD R56,=LAVAIL      !SET LOAD LIMIT
         STMD R56,=LSTDAT  
         LDMD R56,=FWCURR      !SET LOAD ADDRESS
LOADB+   STMD R#,=NXTDAT  
LOADBR   STMD R6,=SAVER6       !FOR ERRORS IN LOAD,CHAIN

!in case failure occurs in LOAD,CHAIN, or LOADBIN
!report error then return to CALLING routine (not
!system) to do corrective SCRATCH, or delete binary
!NOW LOAD MEM. BOUNDED BY NXTDAT<LSTDAT FROM DISC
         JSB =GETFIL           !DIR.SCAN,TYPE CK,SEEK
         JSB =BYTES            !#BYTES LAST REC,#RECS
         PUMD R#,+R6           !3 BYTES @ R45
         LDMD R32,=LSTDAT      !UPPER MEM LIMIT

         SBMD R32,=NXTDAT      !-LOWER-->SPACE AVAIL
         SBM R32,R76           !-PROG SIZE
         JNG MEMOVF            !NOT ENUF SPACE!
         TSM R76               !D.BYTS=0-->BAD FILE(E.G.COPY)
         JNZ OKFILE            ! #BYTES IN FILE SENSIBLE
         JSB =MSERR+           ! SYSTEM TAPE ERROR
         BYT 64D               !EMPTY FILE!
OKFILE   LDB R#,=1             !  FROM NOW ON...
         STBD R#,=SCRTYP       !ITS A SCRATCH ERROR
NXTREC   POBD R32,-R6          !R32:= GET SECTOR CNT
         DCB R#                !  UPDATE IT
         JZR LSTREC            ! DO LAST REC
         PUBD R#,+R6           !SAVE FOR NXT PASS
         LDMD R30,=NXTDAT      ! DATA ADDR.

         JSB =GETSE+           ! READ A CHUNK
         LDMD R30,=NXTDAT      ! UPDATE...

         ADM R30,=0,1          !256 BYTES TRANSFERRED
         STMD R30,=NXTDAT      !.. DATA ADDR
         JMP NXTREC            !DO SOME MORE
!BUFFER (PORTION OF) LAST SECTOR BEFORE TRANSFERRING
LSTREC   JSB =GETBU+           !LAST SECTOR
         LDMD R26,=NXTDAT      !DEST

         STM R26,R30           !FOR NXTDAT UPDATE
         LDM R24,=RECBUF       !SOURCE

         POMD R22,-R6          !BYTE COUNT LST.REC
         ADM R30,R22           ! UPDATE NXTDAT
         STMD R30,=NXTDAT      !& STORE
         JSB =MOVUP            !FROM BUFFER TO PROG
!
!LOAD NOW COMPLETED--CLEAN UP AFTER
!
!??REMOVE NXT LINE IF MOVUP KILLS 26
         JSB =LOADEX           !SET R12,NXTMEM IF LOAD,CHAIN
         RTN 
!
MEMOVF   BSZ 0                 !CLEAN BYTES OFF STACK
         JSB =MSERR+  
         BYT 19D               !MEMORY OVERFLOW
GETFIL   JSB =DIRSCN           !NAME IN DIR?
         JEZ LNAME             !LOAD NAME EXISTS
         JSB =ER67D            !SYS.FILE NOT FOUND
LNAME    JSB =GETTYP           !FILE TYPE CHECK
         STB R#,R47            !FOR 'ANM'
         ANM R47,=374          !TRASH 2 LOWER BITS
         CMMD R47,=FILTYP  
         JZR TYPOK2            !TYPE MATCHES
         JSB =ER68D            !WRONG FILE TYPE
TYPOK2   PUMD R36,+R6          !SAVE DIR.PTR.
         DRP R30
         JSB =LDFBEG  
         JSB =HLSEEK           !GO THERE
         POMD R36,-R6          !RESTORE DIR.PTR.
         RTN 
         BYT 241
MASSS.   BSZ 0
         JSB =MSIN             !RUNTIME INIT
         LDB R40,=2            !ALLOW MSUS ONLY
         JSB =DCDFIL           !DECODE MSUS
         STMD R44,X14,DEFMSU   !NEW DEFAULT MSUS

         RTN 
         BYT 241
MSSEC.   BSZ 0
         ARP R12
         JSB =SECJSB           !INTERCEPT TAPE
         JSB =DISCOP           !READ DIR, ETC
         JCY NAMESC            !NAME SECURE
P/BTYP   EQU 50                !BINARY OR PROGRAM TYPE
!add binary program security
         ANM R33,=P/BTYP       !PGM OR BINARY FILE?
         JZR ERR22D            ! JIF NO
         JSB =SREADR           !READ RECORD
         JNZ ERR22D            ! JIF ALREADY SECURED
         JSB =SBYTE            !BUILD SECURE BYTE
STFLAG   STBD R#,X56,P.SFLG    ! SET FLAG

         LDMD R30,=SECURN      !LOAD SECURE CODE

         STMD R30,X56,P.SCOD   !SET SECURE NAME
         LDMD R32,=CURREC      !SECTOR # ON DISC

         JSB =PUTBUF           !REWRITE 1ST FILE SECTOR
SECEXT   RTN 
NAMESC   ORB R33,R47           !ADD BITS
         JMP NAME+   
NAMEUN   NCB R47               !COMPLIMENT MASK
         ANM R33,R47           !TAKE OUT BIT
NAME+    STB R33,R30           !FILE TYPE FOR PUTTYP
         GTO PURGE+            !REWRITE DIR WITH SECURITY

!------------------------------------------------------
ERR22D   JSB =MSERR+  
         BYT 22D               !SECURITY
!-------------------------------------------------
         BYT 141
MSUNS.   BSZ 0
         ARP R14
         JSB =SECJSB           !INTERCEPT TAPE
         JSB =DISCOP           ! DIR,ETC
         JCY NAMEUN            !UNSECURE IF 2,3
         ANM R33,=P/BTYP       !PRGM OR BINARY TYPE?
         JZR ERR22D            !JIF NO
         JSB =SREADR           !READ RECORD
         JZR SECEXT            !ALREADY UNSECURED
         LDMD R32,X#,P.SCOD    !CHECK SECURE CODE

         CMMD R32,=SECURN      !SAME?
         JNZ ERR22D            !JIF NO
         JSB =SBYTE            !BUILD SECURE BYTE
         NCB R#
         ANM R#,R30            !DROP BIT(S)
         JMP STFLAG  
!---------------------------------------------------
SECURC   JSB =ONEB             !GET SECURE #
         ANM R46,=3,0          !ISOLATE 3 BITS

         STBD R46,=SEC#        !SAVE EM
         JSB =GETNA!           !POP SECURE CODE
         LDM R36,R42           !USE 1ST TWO
         NCM R36               !SCRAMBLE THE CODE
         LLM R36               !LEFT ROTATE
         JNC SHIFTD            ! THE
         ICM R36               ! BITS
SHIFTD   STMD R#,=SECURN       !SAVE EM
         JSB =TAPDS-           !TAPE INTERCEPT?
         RTN 
!-----------------------------------------------
DISCOP   JSB =DIRSCN           !LOOK FOR FILE
         JEZ SECNAM  
         JSB =ER67D            !NO NAME FOUND
SECNAM   JSB =GETTYP           !FILE TYPE TO R30
         STB R30,R33
         JSB =LDFBEG  
         STMD R#,=CURREC       !SAVE FOR I/O
         GTO SECNA+            !USE SYSTEM ROUTINE

!---------------------------------------------------
SREADR   LDMD R32,=CURREC      !1ST FILE SECTOR

         JSB =GETBUF           !READ 1ST SECTOR
         GTO SREAD+            !USE SYSTEM ROUTINE

         BYT 241
MSPUR.   BSZ 0
         JSB =MSIN             !RUNTIME INIT
         LDB R46,=1            !FLAG NO PURGE CODE
         LDM R26,R12           !CHECK FOR PURGE CODE
         SBMD R26,=TOS     
         CMB R26,=5            !4 IS STRING ONLY
         JNG NOPARM            !-1 IF STRING ONLY
         JSB =ONEB             !GET PURGE CODE
NOPARM   STBD R46,=MTFLAG      !DISC PURGE CODE

         JSB =TAPDS-           !TAPE INTERCEPT
         JEZ PURDSK            !JIF DISC
         LDMD R12,R14          !RESTORE PARAM STACK
         JSB =ROMJSB  
         DEF PURGE.            !TAPE PURGE ENTRY
         BYT 0
         RTN 
!PURGE A DISC FILE
PURDSK   JSB =DIRSCN           !FIND THE FILE
         JEZ PURCOD            !JIF NAME FOUND
ER67D    JSB =MSERR+  
         BYT 67D               !SYSTEM FILE NOT FOUND
!
PURCOD   LDBD R30,=MTFLAG      ! PURGE REMAINING(=0)?

         JNZ PURFIL            !NOPE
PUR+     BSZ 0
         LDM R30,=377,177      !LARGEST INT

         JSB =STRECS  
         LDB R30,=377          !'LAST' FILE TYPE
PUR+++   DAD 64604
         JSB =PUR+++           !REWRITE DIRECTORY
         JSB =NXTENT           !FOR ALL REMAINING FILES
         JSB =GETTYP           !FILE TYPE
         ICB R#                !LAST FILE?
         JZR PURDUN            !JIF LAST FILE
         JEZ PUR+              !JIF MORE FILES
PURDUN   RTN 
!
PURFIL   BSZ 0
!PURGE THE CURRENT FILE:
! DADDR - DISC DIR. SECTOR
! DENTRY - OFFSET FOR ENTRY IN THIS SECTOR
         JSB =DIRPTR           !R36:=DIR PTR(DENTRY,DADDR)
         CLB R30               !NULL FILE TYPE
PURGE+   JSB =PUTTYP           !UPDATE FILE TYPE
PURG++   JSB =WRTDIR           !REWRITE DIRECTORY
         RTN 
         BYT 241
MSREN.   BSZ 0
         JSB =MSIN             !RUNTIME INIT
         LDB R40,=1            !ALLOW NEW FILENAME ONLY
         JSB =DCDFIL           !GET FILENAME
         LDMD R43,X14,FNAM     !GET 2ND NAME

         STMD R43,X14,GNAM     !AND SAVE IT
         LDMD R43,X14,FNAM+5   !& REMAINDER
         STMD R43,X14,GNAM+5  
         JSB =TAPDS-           !TAPE INTERCEPT
         JEZ RENDSK            !JIF DISC
         JSB =PSHFIL           !PUSH 2ND FILE LEN,ADDR
         POMD R36,-R12         !WRONG ADDR!
         ADM R36,=NAMLEN       !ADJUST BY NAME LENGTH
         PUMD R36,+R12         !NOW CORRECTED
         JSB =ROMJSB  
         DEF RENAM.            !TAPE RENAME ENTRY
         BYT 0
         RTN 
RENDSK   BSZ 0
!DONT ALLOW RENAMING A FILE SO 2 WOULD HAVE SAME NAME
         LDMD R12,R14          !RESTORE PARAMS
         JSB =DECODE           !FNAM:=NEW FILENAME, ACTMSUS SAME
         JSB =DIRSCN           !NEW NAME REALLY NEW?
         JEN NODUPE            !ITS NEW
         JSB =MSERR+           !SYSTEM ERROR
         BYT 63D               !DUPE NAME
NODUPE   JSB =TAPDS-           !FNAM:=OLD FILESPECIFIER
!RENAME A DISC FILE
         JSB =DIRSCN           ! SEARCH FILE NAMES
         JEZ RENFIL            ! JIF FILE FOUND
         JSB =ER67D            ! FILE NOT FOUND
RENFIL   LDMD R43,X14,GNAM     !1ST HALF

         PUMD R43,+R36         !..REPLACED
         LDMD R43,X14,GNAM+5   !2ND HALF

         PUMD R43,+R36         !..REPLACED
         JMP PURG++            !REWRITE DIR
         BYT 141
TRANS.   BSZ 0                 ! old translate was here
ERREP.   BSZ 0
         JSB =MSERR+           ! ILLEGAL ROM TOKEN
         BYT 15D
! ASTORE"MASSPART2.MASROM"
PR#FST   BSZ 0
         LDMD R22,=DATLEN      ! DATA LENGTH

         JZR PR#RTN  
         JSB =MOVTST           ! TEST FOR FAST MOVE
         JCY PR#BYT            ! JIF CAN'T MOVE FAST
!        DRP !24
         LDMD R#,=RESDAT       ! R24=>SOURCE
         JSB =MOVUP   
PR#RTN   DRP R26               ! FOR WREOR
         RTN 
PR#BYT   BSZ 0
         DCM R22
         STMD R22,=DATLEN  
         LDMD R22,=RESDAT  
         POBD R32,+R22
         STMD R22,=RESDAT  

         JSB =WT+ADV  
         LDMD R22,=DATLEN  

         JNZ PR#BYT  
         DRP R26               ! FOR WREOR
         RTN 
! RD#FST.MASROM
RD#FST   BSZ 0
         LDMD R22,=DATLEN      ! LOAD DATA LEN FOR TST

         JSB =MOVTST           ! TEST FOR QUICK READ
         JCY RD#BYT            ! JIF SLOW READ ONLY
         STM R26,R24           ! R24=>SOURCE
         LDMD R26,=RESDAT      ! R26=>SINK
         JSB =MOVUP            ! QUICK MOVE
         RTN 
RD#BYT   BSZ 0
         JSB =RD+ADV  
         LDMD R26,=RESDAT  

         PUBD R32,+R26
         STMD R26,=RESDAT  

         LDMD R26,=DATLEN  
         DCM R26
         STMD R26,=DATLEN  
         JNZ RD#BYT  
         RTN 
! TSTNUL.MASROM
TSTNUL   BSZ 0
         LDMD R32,=DATLEN  

         CMM R32,=3,0
         RTN 
! ASTORE"MASSRUN5.MASROM"
!LOC!         LOC 65107
         BYT 0,55
ERROM.   LDBD R36,=ERROM#  

         JMP RESULT  
!---------------------------------------------------------------
         BYT 0,55
ERRSC.   LDBD R36,=ERRSC   

         JMP RESULT  
         BYT 20,55
TYP.     JSB =MSIN             !RUNTIME INIT
         JSB =GET#             !GET BUFFER #
         JNZ TYPOPN            !JIF FILE OPEN
         JSB =ER66D            !FILE NOT OPEN
TYPOPN   BSZ 0                 !NUMBER TYPE
         JSB =ONEBC!           !SETUP FILE POINTERS
         LDBD R#,R#            !D32,A66
         ICB R#                !ADJUST RIGHT DIGIT
         JRZ ITSA$             !JIF ITS A STRING
         LDB R36,=1            !ITS A NUMBER
RESULT   CLB R37               !TO SAVE BYTES BELOW
         JSB =CONBIN           !R36 TO R40 REAL
         PUMD R40,+R12         !ONTO RESULT STACK
         RTN 
ITSA$    JNZ TRY340  
         LDB R36,=3            !377 MEANS EOF
         JMP RESULT  
TRY340   CMB R#,=340           !ENTIRE STRING?
         JNZ NENTIR  
         LDB R36,=2            !ENTIRE STRING
         JMP RESULT  
NENTIR   CMB R#,=320           !START STRING?
         JNZ NSTART  
         LDB R36,=8D           !START STRING
         JMP RESULT  
NSTART   CMB R#,=200           !MIDDLE STRING?
         JNZ NMIDDL  
         LDB R36,=9D           !MIDDLE STRING
         JMP RESULT  
NMIDDL   TSB R#                !END STRING?
         JNG NEND$   
         LDB R36,=10D          !END STRING
         JMP RESULT  
NEND$    LDB R36,=4            !EOR TYP VALUE
         JMP RESULT  
!------------------------------------------------------------
GET#     JSB =ROMJSB  
         DEF GET#1             !GET BUFFER#
         BYT 0
         RTN                   !ROMJSB NEEDED FOR ERRORS!
         BYT 241
MSCRE.   BSZ 0
         JSB =MSIN             !RUNTIME INIT
MSCRE+   STMD R12,=INCRA       !FOR TAPE TRANSFER

!USE INCRA (NOT R14) BECAUSE COPY USES R14
!MSCRE+ CALLED FROM COPY
         LDM R46,=0,1          !DEFAULT 256 B/REC

         STMD R46,=B/REC   
         JSB =ONEB             !GET FIRST PARAM
         JEN ER89D             !JIF PARAM OVERFLOW
         LDM R26,R12           !1 OR 2 PARAMS?
         SBMD R26,=TOS     
         CMM R26,=5,0          !STRING TAKES 4 BYTES
         JNG JSTREC            !JIF #RECORDS ONLY
         STMD R46,=B/REC       !1ST OF 2 PARAMS

         JSB =ONEB             !GET # RECORDS
         JEN ER89D             !JIF PARAM OVRFLO
JSTREC   BSZ 0                 !SAVE #RECORDS
         STMD R46,=R/FILE      !REALLY save it!

         JSB =TAPDS-           !TAPE INTERCEPT
         JEZ CREDSK            !JIF DISC
         LDMD R12,=INCRA       !RESTORE TAPE PARAMS

         JSB =TINIT!           !CRT OFF, TAPE ON
         JSB =ROMJSB  
         DEF CREAT+            ! TAPE CREATE
         BYT 0
         RTN 
!CREATE A DISC FILE
CREDSK   LDMD R46,=R/FILE      !GET RECS BACK

         JZR ER89D             !0 RECORDS IS ERROR
         JNG ER89D             ! - IS ERROR
         STM R46,R66           !SET FOR INTMUL
         LDMD R76,=B/REC       !GET BYTES PER REC

         JNG ER89D             ! - IS ERROR
         CMM R76,=4,0          !<4 BYTES/REC IS ERROR
         JCY MULTIP  
ER89D    JSB =MSERR+  
         BYT 89D               !INVALID PARAMS
MULTIP   JSB =INTMUL  
         TSB R54               !MAKE RESULT MULT OF 256
         JZR R55OK   
         ICM R55
R55OK    TSB R57               !JIF TOO MANY
         JNZ ER89D   
         LDM R66,R55           !MOVE 2 BYTE
         JNG ER89D             !JIF TOO MANY
         JZR ER89D             ! INCREMENT TO ZERO?
         STMD R66,=CR.CNT      !COUNT FOR GETBU!
         JSB =DIRSCN  
         JEN LIKNAM            !NAME FOUND IS ERROR
         JSB =MSERR+  
         BYT 63D               !DUPE FILE NAME
LIKNAM   LDB R41,=DATATY       !SET TYPE FOR GETCNT
         STBD R41,=FILTYP      !  IN MTSCAN
         JSB =MTSCAN           !FIND EMPTY OR NXTAVAIL
!DIR ENTRY IS BIG ENUF:UPDATE & REWRITE IT
         LDMD R30,=B/REC       !LOG.BYTES/REC

         STMD R30,X36,D.B/RC  

         JSB =LDRECS  
         PUMD R#,+R6           !STASH FOR DATAFILE INIT
         JSB =LDFBEG  
!***********************************************
         PUMD R#,+R6           !STSH FOR LOOP
         LDB R#,=DATATY        !ITS DATA FILE
         JSB =PUTTYP           ! INTO DIRECTORY
         LDM R34,R36           ! TRANSFER NAME
         LDMD R43,X14,FNAM     !1ST HALF

         PUMD R43,+R34         !DONE
         LDMD R43,X14,FNAM+5   !2ND HALF

         PUMD R43,+R34         !DONE
         JSB =WRTDIR           !REWRITE DIRECTORY
!INIT DATA FILE WITH ALL EOF (377)
         POMD R30,-R6          !FIRST SECTOR OF FILE
!COPY speedup: if COPY calls CREATE dont bother
! doing data file init (fill with 377s):
         POBD R20,-R10         !LAST RUN TOKEN
         PUBD R20,+R10         !RESTORE BASIC P.C.
         CMB R20,=COPYTK       !COPY OR CREATE?
         JZR NOTDAT            !COPY: NO DATA INIT
         JSB =HLSEEK           !  GO THERE
         JSB =FIL377           !  SYS: RECBUF := ALL 377s
LOP377   POMD R30,-R6          !  RECORD COUNT
         JZR EX_-_N            !LAST REC
         DCM R30
         PUMD R30,+R6          !  RESTORE SECTOR COUNT
         JSB =PUTBU+           !  WRITE NEXT RECORD
         JMP LOP377  
!************************
NOTDAT   POMD R#,-R6           ! JUNK REC COUNT
EX_-_N   RTN 
!  ASNTBL IS A 20 BYTE TABLE OF RELATIVE
!  ADDRESSES REFERENCED TO RTNSTK,POINTING
!  TO EACH ASSIGNED FILE'S TABLE AND BUFFER.
!
!    2 BYTES = 0 IF CLOSED
! OR 2 BYTES REL. ADDRESS(SEE ABOVE) IF OPEN
!
!  THE FORMAT OF THE TAPE ASSIGNMENT TABLE IS:
!
!    2 BYTES  -  FWCURR OF PGM WHO OPENED
! A.PGMU 2    -  FWCURR OF CURRENT USING PGM
! A.PEND 4    -  BUFFER PENDING FLAG (FOR STORE
! A.FILE 5    -  PHYSICAL FILE #
! A.ERFL 6    -  OVF OR ERROR FLAG
! A.PPTR 7    -  PHYSICAL POINTER
! A.PREC 10   -  PHYSICAL RECORD #
! A.LPTR 12   -  LOGICAL POINTER
! A.LREC 14   -  LOGICAL RECORD #
! A.#R/F 16   -  # RECORDS / FILE
! A.#B/R 20   -  # BYTES / RECORD
! A.MSUS 22   -  MASS STORAGE UNIT SPEC.
!   23-33     -  NOT USED
! A.DATA 34   -  256 BYTES OF DATA
! A.RESL 434
! ASNLEN 12  (10 DECIMAL FILES ALLOWED)
!*************************************************
!  DISC DATA BUFFER POINTER ALLOCATION
!
!*************************************************
! CURLOC 0    -  FWCURR OF PGM WHO OPENED
! A.PGMU 2    -  FWCURR OF CURRENT USING PGM
! A.PEND 4    -  BUFFER PENDING FLAG
!?A.HEAD 5    -  DISC HEAD # THIS SECTOR
! A.ERFL 6    -  OVF,ERROR FLAG
! A.PPTR 7    -  PHYSICAL POINTER
! A.PREC 10   -  PHYSICAL RECORD # (LOCAL TO FILE)
! A.LPTR 12   -  LOGICAL POINTER
! A.LREC 14   -  LOGICAL RECORD #
! A.#R/F 16   -  # LOG.RECORDS / FILE
! A.#B/R 20   -  # LOG.BYTES / RECORD
! A.MSUS 22   -  MASS STORAGE UNIT SPEC.
A.BSEC   EQU 26                ! 1ST SECTOR OF DISC FILE
A.CHEK   EQU 30                !CHECK READ [OFF] FLAG
! A.DATA 34   -  256 BYTES DATA
!***********************************************
! A.RESL 434
! ASNLEN 12 ( 10 FILES ALLOWED)
!***********************************************
         BYT 241
ASSIG.   BSZ 0
         JSB =MSIN    
!CHECK FOR FILENAME="*" WHICH MEANS CLOSE
         POMD R34,-R12         !FILENAME STR ADDR
         POMD R32,-R12         !STR LENGTH
         CMM R32,=1,0          !LENGTH(FILENAME)=1?
         JNZ NOT*              !JIF NOT
         LDBD R32,R34          !GET THE SINGLE CHAR
         CMB R32,=STAR         !IS IT * ?
         JNZ NOT*              !JIF NOT
!ITS A CLOSE: ASSIGN# buffer no TO *
         JSB =GET#             !GET BUFF#
         JNZ CLOS1             !JIF FILE OPEN
         JSB =WARN    
         BYT 66D               !FILE NOT OPEN
EXASIN   RTN                   !BUFFER WASNT OPEN
CLOS1    LDBD R44,X26,A.MSUS   !TAPE DISC FLAG

         JNZ DOCLOS            !JIF DISC
         JSB =ROMJSB           !TAPE CLOSE
         DEF TAPCLO  
         BYT 0
         RTN 
DOCLOS   JSB =WRTDA-           !DUMP THE BUFFER
         JSB =ROMJSB  
         DEF CLOSE+            !(TAPE)BUFFER POST PROCESS
         BYT 0
         RTN 
!
NOT*     BSZ 0
         LDMD R12,R14          !  RESTORE PARAMS
         ARP R16
         JSB =SYSJSB           !INTERCEPT TAPE
         JSB =DIRSCN           !FIND THE NAME
         JEZ ASNNAM            !E=0 --> NAME FOUND
         JSB =ER67D            !FILE NAME
ASNNAM   STMD R36,=CURCAT      !SAVE CUR. CAT. LOC.

         JSB =GETTYP           !GET FILE TYPE
         LDB R47,R30
         STBD R47,=DTAWPR      !SAVE FOR SOFT PTCT
         ANM R47,=DATATY  
         JNZ OKSOFR  
         JSB =ER68D            !WRONG FILE TYPE
OKSOFR   JSB =GET#             !POP STACK VALUE
         JZR ITSCLS            !ZERO IF CLOSED
         JSB =SAVACM           !CLOSE IT&save actmsus
         STMD R6,=SAVER6       !RESET SAVER6

!********************************************************
!*****      SORRY FOLKS IF YOU ENTER  AFTER THE     *****
!****     LABEL 'ITSCLS' 'CAUSE I HAD TO MOVE IT     ****
!***      TO MAKE ROOM FOR FIXES AND ENHANCEMENTS     ***
!****     NOW THE FOLLOWING COMMENTED CODE IS IN     ****
!*****       THE ELECTRONIC DISC ROM. OH WELL!      *****
!********************************************************
! ITSCLS   LDMD R36,=CURCAT       !LOAD DIRECTORY LOC.
!        LDM R56,=A.RESL        !256 + HEADER BYTES
!        JSB =ASIGNL            !COMPUTE FWA ASSIGN BUFFS
!        SBMD R22,=LAVAIL
!        JSB =GETMEM            !MOVE ROUTINE
!        JEN EXASIN
!        STMD R26,=CURLOC       !STORE ABSOLUTE ADDR.
!        LDMD R46,=CURASN       !LOAD INDEX
!        LDMD R76,=RTNSTK
!        SBM R76,R26
!        STMD R76,R46           !STORE REL. ADDRESS
!        LDMD R40,=FWCURR       !MAKE ASSIGN ENTRIES
!        LDM R42,R40            !OPENER IS USER
!        CLM R44
!        LDBD R45,=DTAWPR       ! CHECK SOFT PROTECT
!        LRB R#
!        LRB R#                 !SHIFT BIT TO CARRY
!        SAD                    !SAVE BIT
!        CLB R#
!        PAD                    !RESTORE BIT
!        ERB R#                 !CARRY TO MSB
!        STMD R40,R26           !1ST EIGHT BYTES
!        CLM R40
!        LDMD R44,X14,ACTMSU    !ACT.MSUS THIS FILE
!        STMD R44,X26,A.MSUS    !INTO TABLE
!        CLM R44
!        ICB R44                !LOGICAL RECORD=1
!        STMD R40,X26,A.PREC
!        STMD R46,=CURREC       !CURRENT RECORD #
!        LDMD R36,=CURCAT       !GET CUR CAT LOC FOR INDEX
!        DRP R30
!        JSB =LDFBEG
!        STMD R#,X26,A.BSEC     !INTO TABLE
!        JSB =LOGREC            !COMPUTE RECS PER FILE
!        STMD R36,X26,A.#R/F    !SET RECS/FILE
!        STMD R32,X26,A.#B/R    !SET BYTES PER REC
!        CLB R#                 !CHECKREADOFF DEFAULT
!        STBD R#,X26,A.CHEK
ITSCLS   BSZ 0
         JSB =ROMJSB           ! LET ROM2 HANDLE IT
         DEF ASSIG+  
         VAL MSROM2  
ASSIG+   DAD 61350
         JSB =SETFER           !SET FILE ERROR
         JSB =RDATA            !INITIALIZE DATA BUFFER
         JSB =CLRERF           !SYS CLEAR ERROR FLAG
         RTN 
FORMFX   BSZ 0
         JSB =OPSU#3           ! SEND 5 DATA BYTES
         LDM R46,=360,0        ! WAIT 15 MINUTES!

CYLRTN   RTN 
CYLFIX   BSZ 0
         CMM R30,R56           ! SECTOR MOD SECTOR/CYLINDER
         JNC CYLRTN            ! RTN IF GOT MOD
         SBM R30,R56           ! SUBTRACT ONE SECTORS WORTH
         ICM R46               ! CYLINDER COUNT
         JMP CYLFIX            ! ANOTHER ROUND
!-----------------------------------------------------------
VRFLAG   EQU 91D
VERSEC   BSZ 0
         LDB R45,R23           ! UNIT
         LDBD R57,X14,VRFLAG   ! NEED LARGER SEC CNT?

         JZR VERRTN            ! RTN IF NOT
         LDB R46,=225
VERRTN   RTN 
!LOC!         LOC 66121
!The following two routines perform the disk data
!buffer i/o. Verification is performed for WRITE.
RDATA    JSB =R/WPRM           !PUTSEC PARAMS
         JSB =GETSEC  
WRTRTN   RTN 
!--------------------------------------------------------
WDATA    JSB =R/WPRM           !GETSEC PARAMS
         JSB =PUTSEC  
         JSB =R/WPRM           !INCASE VERIFY
         LDBD R#,X26,A.CHEK    !NEED READ VERIFY?

         JZR WRTRTN            !JIF CHECKREAD OFF
         JSB =GETBUF           !REREAD THE DATA
         JSB =R/WPRM           !REMAKE DATA BUFF ADDR
         LDM R32,=RECBUF       !FOR VERIFY

         LDM R34,=0,1          !256 BYTES TO CHECK

!FALL INTO DATA VERIFICATION ROUTINE
!--------------------------------------------------
!VERIFY THAT R30,R32 CONTAIN THE SAME # BYTES
!(IN R34) OF IDENTICAL DATA. ERROR IF NOT.
CKDAT?   POBD R40,+R30         !ARE THESE 2 BYTES...
         POBD R50,+R32         !...IDENTICAL?
         CMB R40,R50
         JNZ DATDIF            !JIF NOT SAME DATA
         DCM R34               !BYTE COUNT
         JNZ CKDAT?            !CHECK 1 BYTE MORE
         RTN                   !ALL BYTES VERIFIED!
DATDIF   JSB =MSERR   
         BYT 27D               !READ VERIFY ERROR
!---------------------------------------------
!Set up for disk i/o:
! R30 := data buffer address
! R32 := disk sector #
! R26 := ASSIGN# table base address
R/WPRM   LDMD R26,=CURLOC      ! CURRENT BUFFER TABLE

         STM R26,R30           !RAM TARGET ADDR
         LDMD R32,X30,A.BSEC   !0-TH SECTOR

         ADMD R32,=CURREC      !PHY.REC.OFFSET
         ADM R30,=A.DATA       ! DATA IN TABLE

         LDMD R44,X26,A.MSUS   !CURRENT BUFFER'S MSUS

         STMD R44,X14,ACTMSU   !FOR THE DISC

         RTN 
! ASTORE"MASSRUN6.MASROM"
!WRTDA- STMD R6,=SAVER6  !SO CLOSE RETURNS
WRTDA-   BSZ 0
!                         TO RELEASE MEM.
WRTDAT   JSB =SETF#   
         LDMD R#,X#,A.PREC     !AND RECORD#
         STMD R#,=CURREC  
         LDBD R#,X#,A.PEND     !BUFFER PENDING?
         JZR SERIAL            !JIF NO TO EXIT
         JEZ NOSPTC            !JIF NOT SOFT PTCT
         JSB =ERR22D           !SOFT WRITE PROTECT
NOSPTC   LDBD R#,X#,A.ERFL     !CHECK ERROR FLAG
         JPS NPTCT             !JIF NO FILE ERROR
         JSB =ER72D   
NPTCT    JSB =SETFER           !SET FILE ERROR
         JSB =WDATA            !WRITE DATA BUFFER
         JSB =NPTC+5           !CLEAR FILE,PENDING BITS
SERIAL   RTN 
!**********READ # ATTRIBUTES TABLE***************
         BYT 241
!************************************************
PRINT.   BSZ 0
READ.    JSB =MSIN             !RUNTIME INIT
         CLB R26
         STBD R26,=RANDOM      !SET TO SERIAL
         DCB R26               !SET INTERCEPT
         STBD R26,=SCT+7   
         LDBD R26,=CRTWRS      !SET CRT OFF
         STBD R26,=CRTONT  
         LDM R26,R12           !SERIAL OR RANDOM?
         SBMD R26,=TOS     
         TSB R26               !CAN BE 10 OR 20
         JLN RNDPR#            !20  = 2 VALS = RND
         JSB =TOTAP?           !GET ASSIGN #
         LDBD R36,X26,A.ERFL   !CURRENT REC# VALID?

         JPS NOFERR            !NO FILE ERROR
FILERR   JSB =ER72D            !FILE ERROR
NOFERR   LRB R#                !CHECK FILE OVF
         JOD FILERR            !JIF FILE OVF
         JSB =CLRERF           !CLEAR ERROR FLAG
!FOR DISC IO: active msus:= msus of current buffer
         RTN 
RNDPR#   JSB =ONEB             !GET REC#
         STM R46,R24           !SAVE IT
         JNZ GORND   
         JSB =ER89D            ! RANDOM READ TO 0 ERROR
GORND    JSB =TOTAP?           !GET ASSIGN #
         LDB R36,=1            ! SET RANDOM <>0
         STBD R36,=RANDOM  
         LDBD R36,X#,A.ERFL    !ZERO ERFL IF NO FILE
         JPS CLEARE            ! -RECORD ERROR
         LDBD R36,X#,A.PEND    !DATA PENDING?
         JNZ CLEARE            !JIF YES, TRY WRITING AGAIN
         CLM R36               !SET INVALID PHYS. REC#
         DCM R36
         STMD R36,X#,A.PREC    !FORCE RE-READ OF REC
CLEARE   CLB R#
         STBD R#,X#,A.ERFL     ! CLEAR
         LDM R#,R24            !MOVE FOR OUTLR
         JMP OUTLR+  
!
! COMMENTS:  SERIAL PRNT#. AND READ#. CRASH
!            ON HARD FILE ERRORS (ERFL NEG.).
!
!            SERIAL ACCESS CRASHES ON FILE OVF
!
TOTAP?   BSZ 0
         JSB =GET#             !GET ASSIGN #
         JNZ ITSOPN            !BUFFER OPENED
ER66D    JSB =MSERR+  
         BYT 66D               !FILE CLOSED
ITSOPN   JSB =CKMSUS           !DISC OR TAPE CALL?
         JEZ NOTTAP            !JIF DISC
         POMD R12,-R6          !CLEAR EXTRA JSB
         LDMD R12,R14          !RESTORE PARAM STACK
         JSB =ROMJSB  
         DEF TREAD.            !SYSTEM TAPE READ.
         BYT 0
NOTTAP   RTN 
!            RANDOM ACCESS CLEARS THE LSB OF ERFL
!
WT+ADV   JSB =ONEBC!           !CHECK ERROR,COMPUTE ADDRESS
         STBD R#,R#            !R32,R66
         LDB R#,=1             !SET PENDING FLAG
         STBD R#,X26,A.PEND  

         JMP ADVANC  
!
RD+ADV   JSB =ONEBC!           !CHECK ERROR,COMPUTE ADDRESS
         LDBD R#,R#            !R32,R66
         STBD R#,=DATUM        !SAVE TILL EXIT
ADVANC   LDBD R#,X26,A.PPTR    !INCR. PHYS PTR

         ICB R#
         JNZ NOPOVF            !JIF NO PHYS OVF
         JSB =WRTDAT           !WRITE IF NECESSARY
NOPOVF   LDMD R36,X26,A.#B/R   !BYTES/RECORD

         LDMD R66,X26,A.LPTR   !INCR. LOG PTR

         ICM R66
         CMM R66,R36           !OVF LOG RECORD?
         JCY OUTLR             !JIF OUTSIDE L.RECORD
RSPTR    STM R66,R64
         LDMD R66,X26,A.LREC  

         JMP LROK+   
!
OUTLR    LDBD R46,=RANDOM  

         STBD R46,X26,A.ERFL   !0 IF SERIAL,1 IF RANDOM

REDNXT   LDMD R26,=CURLOC      !MUST SET R26

         LDMD R36,X26,A.LREC   !INCR. LOG REC#

         ICM R36
OUTLR+   LDMD R66,X26,A.#R/F   !COMPARE TO RECS/FILE

         CMM R66,R36
         JCY LROK              !JIF NO OVF FILE
         LDB R66,=2            !NOTE FILE OVF
         STBD R66,X26,A.ERFL   !ADD FILE OVF TO ERFL

         JMP REST32  
!
LROK     CLM R64               ! 0 LPTR
         LDM R66,R36           !MOVE LREC
LROK+    STMD R64,X26,A.LPTR   !SET LPTR,LREC

         DCM R66               !FOR INTMUL
         LDMD R76,X26,A.#B/R  

         JSB =INTMUL  
         LDMD R26,=CURLOC  

         LDMD R64,X26,A.LPTR   !ADD LPTR OFFSET

         CLM R66
         ADM R54,R64           !INTO PHYS RECORD
         LDMD R66,X26,A.PREC   !SAME PRECORD?

         CMM R66,R55
         DRP R54
         JZR NOR/W             !NO NEED TO ADVANCE
         PUMD R54,+R6          !SAVE POINTERS
         JSB =WRTDAT           !WRT CUR PREC IF NECESSARY
         POBD R55,-R6          !TRASH MSBYTE
         POMD R55,-R6          !RESTORE POINTERS
         STMD R55,X26,A.PPTR   !R55=PREC POINTER

         STMD R56,=CURREC      !R56,57=PHYS REC#

         JSB =SETF#            !SET FILE #
         JSB =RDATA            !READ DATA BUFFER
         JSB =CLFBIT           !CLEAR ERROR BIT
         RTN 
NOR/W    STBD R#,X26,A.PPTR    !SET PPTR

REST32   LDBD R32,=DATUM       !RESTORE R32 FOR READS

         RTN 
!-------------------------------------------------
ONEBC!   JSB =ROMJSB  
         DEF ONEBCM  
         BYT 0
         RTN 
ENTIR$   EQU 337
START$   EQU 317
MIDDL$   EQU 177
END$     EQU 157
EOR      EQU 357
         BYT 36
PRSTR.   BSZ 0
         POMD R44,-R12         !POP STR LENGTH, ADDR
PRSTR+   ARP R0
         JSB =I/OJSB           ! INTERCEPT TAPE
         BIN 
         STMD R46,=RESDAT      !R44=LEN,R46=ADDR ON ENTRY

         ADM R46,R44           !COMPUTE EODATA
         STMD R46,=RESEND  
         LDB R46,=ENTIR$  
         STBD R46,=DATYPE      !INIT HEADER TYPE
         LDM R46,R44
DOCHK    ADM R#,=3,0           !ADD FOR HEADER BYTES
         STMD R#,=DATLEN  
         JSB =LENCHK           !OVF LREC?
         JCY INBND$  
         SBM R#,R76            !AMT DATA WHICH FITS
         STMD R#,=DATLEN  
         CMM R#,=4,0           !SHOULD I EVEN START?
         JCY ITFITS            !JIF YES
RDNXT$   JSB =REDNXT           !ADVANCE TO NXT LREC
         LDMD R26,=CURLOC      !BUFFER LOC

         LDBD R26,X26,A.ERFL   !FILE OVF?

         JZR DOBUMP            !JIF NO
         JSB =ER72D            !OVF,NEED RECORD#
ITFITS   LDBD R32,=DATYPE  

         CMB R32,=ENTIR$       !1ST TIME SET START
         JZR USTART            !USE START
         LDB R32,=MIDDL$       !ELSE SET MIDDLE STRING
         JMP OVER    
USTART   LDB R#,=START$  
OVER     STBD R#,=DATYPE  
         JSB =USEHOL           !WRITE TYPE,STRING
DOBUMP   LDMD R46,=RESEND      !COMPUTE REMAINDER

         SBMD R46,=RESDAT  
         JMP DOCHK   
INBND$   JNZ GETBYT            ! JIF NOT ON BOUNDARY
         JSB =TSTNUL           ! TEST FOR NULL $ ONBOUNDARY
         JZR RDNXT$            ! JIF YES, READ NEXT RECORD
GETBYT   JSB =BYTYP            ! GET HEADER
!LOC!         LOC 67116
USEHOL   JSB =WT+ADV           !WRITE TYPE
         LDMD R#,=RESEND       !WRITE LENGTH
         SBMD R#,=RESDAT  
         PUBD R33,+R6          !SAVE SECOND HALF
         JSB =WT+ADV  
         POBD R#,-R6           !RESTORE SEC HALF
         JSB =WT+ADV  
         LDMD R26,=DATLEN      !LENGTH=LENGTH-3 NOW

         SBM R26,=3,0
         STMD R26,=DATLEN  
WSTRNG   JSB =PR#FST  
         JMP WREOR!  
! SAVACM.MASROM
SAVACM   BSZ 0
         LDMD R44,X14,ACTMSU   ! SAVE OLD ACTIVE MSUS

         STMD R44,X14,SRCMSU  
         JSB =CLOS1            ! DO CLOSE
         LDMD R44,X14,SRCMSU   ! RESTORE ACTIVE MSUS

         STMD R44,X14,ACTMSU  
         RTN 
! MASSRUN7.MASROM
!LOC!         LOC 67205
         BYT 36
PRNUM.   BSZ 0
         JSB =ONER             !POP ONE REAL
         ARP R2
         JSB =I/OJSB           !INTERCEPT TAPE
PR#DSK   BIN 
         LDM R56,=10,0         !RESERVE 10 BYTES

         STMD R56,=DATLEN      !SAVE DATA LENGTH
         LDM R56,=NBUFF        !TEMP DATA LOC
         STMD R56,=RESDAT      !SAVE LOC
NBUFF    DAD 101740
RD=17    STMD R40,R56          !PUT THE DATA THERE
         ICB R40               !DONT LET STRING FLAG THRU
         JRZ RD=17             !JIF "STRING FLAG"
         JSB =LENCHK           !CHECK FOR OVF LOG. REC.
         JCY WSTRNG  
         CMM R#,=10,0          !WILL IT FIT EVER?
         JNC R#ER              !JIF NO
         JSB =REDNXT           ! READ THE NEXT REC.
         JMP WSTRNG  
!
!
WREOR!   JSB =WREOR   
         RTN 
R#ER     JSB =ER72D            ! OVF,NEED REC #
         BYT 44
RDNUM.   BSZ 0
         ARP R4
         JSB =I/OJSB  
         JMP RD#DSK  
EORN     JSB =OUTLR   
RD#DSK   JSB =R#COM!           !COMMON TO READN/$
         JRN ITSDAT  
         CMB R32,=360          !EOR?
         JZR EORN              !YES, ADVANCE TO NXT REC
ER33D    JSB =MSERR+  
         BYT 33D               !BAD DATA TYPE
ITSDAT   LDM R56,=10,0         !SET DATA LEN

         STMD R12,=RESDAT      !SET PUSH ADDRESS

         ADM R12,R56           !BUMP FOR SYSTEM
         JSB =GETDAT           !GET 8 BYTES
         JSB =ROMJSB           !GIVE TO SYSTEM
         DEF STOSV   
         BYT 0
         RTN 
!
GETDAT   STMD R56,=DATLEN      !STORE DATA LENGTH

         JZR EORERN            !JIF NULL STRING
         JSB =LENCHK  
         JCY INBNDR            !SPAN LRECORD?
         SBM R36,R76           !YES IMPLIES STRING
         STMD R36,=DATLEN  
         JSB =INBNDR           !READ SEGMENT OF DATA
         JSB =S$HDR            !HANDLE STRING HEADER
         JMP GETDAT  
INBNDR   JSB =RD#FST           ! READ FAST TEST
         RTN 
! BYTYP.MASROM
BYTYP    BSZ 0                 ! SET STRING HEADER TYPE
         LDBD R32,=DATYPE  

         CMB R32,=ENTIR$  
         JZR BYTRTN  
         LDB R32,=END$    
BYTRTN   RTN 
! CKCLLR.MASROM
CKCLLR   BSZ 0
!        DRP !46
         LDB R#,=5
         JSB =CKANSW           ! ASK QUESTION
!        DRP !46
         LLB R#
         LLB R#
         TSB R#
!        RTN                   ! ON NEXT PAGE
! MASSRUN8.MASROM
!LOC!         LOC 67423
EORERN   RTN 
S$HDR    JSB =RD+ADV           !SKIP STRING TYPE
         JSB =RD+ADV           !GET STRING LENGTH
         PUBD R#,+R6           !SAVE LOW ORDER BYT
         JSB =RD+ADV           !GET HIGH ORDER BYTE
         STB R#,R57            !MOVE R32 TO R57
         POBD R56,-R6          !POP LOW ORDER BYTE
         RTN 
         BYT 44
RDSTR.   BSZ 0
         ARP R6
         JSB =I/OJSB           !INTERCEPT TAPE
         JMP RD#$    
EOR$     JSB =OUTLR            !ADVANCE ON EOR
RD#$     JSB =R#COM!  
         JRN ER33D             !ALL STRING TYPES GIVE RDZ
         TSB R#                !FIX POSITIVE!!
         JPS ALL$              !JIF END$ (157+1)
         CMB R#,=360
         JZR EOR$              !ADVANCE ON EOR
         CMB R#,=340           !ENTIRE STRING?
         JZR ALL$              ! JIF YES
         LDBD R#,=RANDOM       !CHECK RANDOM
         JZR ALL$              !JIF NOT RANDOM
         JSB =ER69D            !RANDOM OVF
ALL$     LDMD R40,X26,A.LPTR  

         SBM R46,R40           !#BYTES/REC - LOG. PTR.
         CMM R46,=4,0          !ADVANCE ON HEADER ONLY
         JNC EOR$    
         JSB =S$HDR            !HANDLE STRING HEADER
         JSB =RSMEM-           !RESERVE SPACE FOR STRING
         JEN NOPE$             !NO ROOM FOR STRING
         PUMD R56,+R12         !PUSH STRING LENGTH
         PUMD R26,+R12         !PUSH STRING ADDRESS
         STMD R26,=RESDAT  
         JSB =GETDAT           !FETCH THE STRING
         JSB =ROMJSB           !LET SOMEONE STORE IT
         DEF STOST   
         BYT 0
         RTN 
!
NOPE$    LDMD R26,=CURLOC      !BACK UP 3 BYTES

         LDMD R66,X26,A.LPTR  

         DCM R#
         DCM R#
         DCM R#
         GTO RSPTR             !RESET POINTERS

R#COM!   JSB =ROMJSB  
         DEF R#COMN  
         BYT 0
         RTN 
!**    READ ARRAY ATTRIBUTES ***********************
         BYT 44
!************************************************
RDARR.   BSZ 0
         ARP R10
         JSB =I/OJSB  
         JSB =TRUCAL           !CALCULATE TRUE ARR SIZE
         PUMD R#,+R#           ! SAVE ADDR,NAME
         LDM R36,R44           ! MOVE ADDRESS
         PUMD R36,+R12         ! PUSH TO STACK
         LDB R36,R47           !MOVE NAME
         LLB R36
         TSB R36               !TRACE ON?
         JPS TRACOF  
         CLM R63               !5 BYTES OF 377
         DCM R63
         TSM R56               !1 DIM?
         JNG PUSHOD            !R67 IS ODD IF 1 DIM
         ICB R67               !OTHERWISE EVEN
PUSHOD   PUMD R63,+R12
TRACOF   PUMD R46,+R12         !PUSH NAME
         JSB =LENCA!           !CALC DATA LENGTH
         PUMD R36,+R6          !SAVE DATA LENGTH
         LDM R36,R56           !ARAY LENGTH
         PUMD R36,+R6          !SAVE IT
NXTELR   JSB =RD#DSK           !READ A NUMERIC
         POMD R40,-R6
         STM R40,R30
         SBM R46,R44           !DOWN COUNT LENGTH
         JZR CALOUT  
         ADM R30,R44           !NEXT ADDRESS
         STM R30,R40
         PUMD R30,+R12         !PUSH ADDRESS
         PUMD R40,+R6          !ADDR,NAME,DLEN,ARAYLENGTH
         LDM R46,R42           !MOVE NAME
         ANM R47,=277          !TRACE OFF
         PUMD R46,+R12         !PUSH NAME
         JMP NXTELR            !READ NEXT ELEMENT
LENCA!   JSB =ROMJSB  
         DEF LENCAL            !CALC DATA LEN
         BYT 0
CALOUT   RTN 
!****** PRINT ARRAY ATTRIBUTE TABLE  ****************
         BYT 36
!****************************************************
!**THIS CODE NEEDS SOMETHING FOR REMOTE VARIABLES*****
PRARR.   BSZ 0
         ARP R12
         JSB =I/OJSB           !INTERCEPT TAPE
         JSB =TRUCAL           !CALCULATE TRUE ARRAY SIZE
         PUMD R#,+R#           ! SAVE ADDR,NAME
         LDM R34,R44           !1ST ELEM ADDRESS
         JSB =LENCA!           !CALC DATA LENGTH
         PUMD R36,+R6          !SAVE DATA LENGTH
         LDM R36,R56           !MOVE ARRAY LEN
         PUMD R36,+R6          !SAVE IT
NXTELP   JSB =ROMJSB           !FETCH NUMBER (R60)
         DEF FNUM    
         BYT 0
         LDM R40,R60           !FOR PR#DSK
         JSB =PR#DSK  
         POMD R40,-R6
         STM R40,R30
         SBM R46,R44           !COUNT DOWN LENGTH
         JZR CALOUT  
         ADM R30,R44           !NEXT ADDRESS
         STM R30,R34           !ADDRESS IN R34 FOR FNUM
         STM R30,R40           !FOR NEXT LOOP
         PUMD R40,+R6          !ADDR,NAME,DLEN,ARAYLEN
         LDM R46,R42           !MOVE NAME FOR FNUM
         JMP NXTELP  
!-----------------------------------------------
!CALCULATE REDIMENSIONED ARRAY SIZE FOR READ,PRINT
TRUCAL   POMD R44,-R12         !R44=ADDR,R46=NAME
!Fix option base depending on CALCMODE, and
! PROGRAM or COMMON array variable, as in matrix ROM.
         PUBD R16,+R6          !SAVE R16
         CMM R12,R44           !PROG OR COMMON VAR?
         JNC CALCVB            !JIF CALC VARIABLE
         CLB R16
CALCVB   JSB =CUROPT           !COMPUTE CURRENT OPT BASE
         POBD R16,-R6          !RESTORE R16
!-----------END OF CURRENT OPTION BASE FIX-------------------
         PUMD R46,+R6          !SAVE FROM CALCSZ
         ANM R46,=60,0         !ISOLATE TYPE BITS
         STBD R46,=DIMFLG      !FOR CALCSZ
         POMD R72,+R44         !ARRAY LEN,ROW,COL
         JSB =CALCSZ           !R56:=TRUE SIZE
         POMD R46,-R6          !RESTORE NAME
         DRP R44               !FOR R#,R# AFTER TRUCAL CALL
         RTN 
!***  PRINT EOL ATTRIBUTES TABLE  ****************
         BYT 35
!*************************************************
PREOL.   JSB =MSIN    
         TSB R16               !CALC MODE?
         JEV BUFFEX            !EXIT IF NO
         JSB =MSDUMP           !DUMP MS BUFFERS
         JSB =ROMJSB  
         DEF BUFDMP            !DUMP TAPE BUFFERS
         BYT 0
BUFFEX   RTN 
!**888888888888888888888888888888888888888***
!   UTILITY ROUTINES USED BY THIS ROM       *
!********************************************
!THE FOLLOWING ROUTINES ARE FOR PARSING:
!**************************************************
GETNUM   BSZ 0
         JSB =ROMJSB  
         DEF NUMVA+            !GET A NUMBER
         BYT 0
ERR???   JEN BUFFEX            !FOUND NUMBER
ER91D+   JSB =SYSERP  
         BYT 88D               !MISSING PARAM
!-----------------------------------------------------
GETSTR   BSZ 0
         JSB =ROMJSB  
         DEF STREX+            !GET A STRING
         BYT 0
         JMP ERR???            !FOUND STRING
!------------------------------------------------------
TOTOK    EQU 244               !SYSTEM 'TO' TOKEN
GETTO    BSZ 0
         CMB R14,=TOTOK        !FIND 'TO'
ER???2   JZR BUFFEX            !'TO' FOUND
         JMP ER91D+  
!----------------------------------------------------------
GETCOM   BSZ 0
         CMB R14,=COMMA        !        FIND COMMA
         JMP ER???2            !COMMA FOUND
!----------------------------------------------------------
SYSERP   BSZ 0
         POMD R43,-R6          !2 RTN ADDRESS, 1 TOKEN#
         JMP SYS+1             !NOW FIX STACK
SYSER+   POMD R46,-R6          !TOKEN # AND 1 RTN ADDR
SYS+1    LDM R30,=ROMRTN       ! ERROR+ RETURNS HERE

         PUMD R30,+R6          !PUT ON RETURN STACK
         PUMD R46,+R6          !RESTORE ERROR # ADDR
         JMP ERR!              !RETURN TO ROMRTN VIA ERROR+
!------------------------------------------------------------
!THE FOLLOWING ROUTINES ARE ERROR CALLS FROM
! RUNTIME:
!-----------------------------------------------------------
ER18D    JSB =MSERR   
         BYT 23D               !DISC ONLY ALLOWED!
!--------------------------------------------
MSERR    LDBD R30,=ERRORS      !GET ERROR FLAG

         JNZ MSERR+            !SKIP IF ERROR ALREADY
         LDB R#,=MYROM#        !GET MASS STOR. ROM#
         STBD R#,=ERRROM       !FOR ERROR ROUTINE
MSERR+   JSB =TXIT             !CRT ON IF NEEDED
         POMD R36,-R6          !GET ERROR # ADDR
         LDMD R6,=SAVER6       !CAUSE QUICK EXIT

         PUMD R36,+R6          !RESTORE ERROR # ADDR
ERR!     GTO ERROR+            !RETURN TO SYSTEM

!----------------------------------------------------
!MISC. RUNTIME ROUTINES:
!----------------------------------------------------
CKMSUS   BSZ 0
!LOADS BUFFER ADDRESS IN R26 & TESTS A.MSUS
!MSUS=0 --> TAPE --> E:=1
!MSUS=1 --> DISC --> E:=0
         LDMD R26,=CURLOC      !GET ACTIVE BUFFER ADDR

         LDBD R30,X26,A.MSUS   !CHECK MSUS

         CLE                   !FLAG DISC
         JNZ TAPMSU            !JIF DISC
         ICE                   !FLAG TAPE MSUS
TAPMSU   RTN 
!------------------------------------------------------------
MSIN     BSZ 0
!called by all runtime routines for initialization
         JSB =INIT14  
         STMD R12,R14          !SAVE PARAMS PTR
         BIN                   !FOR ALL LOCAL ARITHMETIC
         CLB R30               !START OUT NOT
         STBD R30,=SCRTYP      !...NOT SCRATCH TYPE
ININIT   LDM R30,R6            !GET SP
!ININIT called by INITIT to set SAVER6, R14
!but cannot set scratchtype(=SAVNAM in tape dscan)!
         DCM R30               !ADJUST FOR EXTRA JSB
         DCM R30               !ADJUST FOR 2 BYTES
         STMD R30,=SAVER6      ! FOR ERROR RETURNS
         LDM R32,=GINTEN  

         STMD R32,=TINTEN      !FOR TAPE ERRORS
INIT14   LDMD R14,=MSBASE      !MS RAM BASE ADDR

         RTN 
!-------------------------------------------------------------
GETNA!   JSB =ROMJSB  
         DEF GETNAM  
         BYT 0
         RTN 
!-------------------------------------------------------------
CLRSEC   BSZ 0
         LDM R26,=RECBUF       !MS SECTOR ADDR

!ZERO 256 BYTES STARTING AT ADDR R30
         CLM R30               !ZERO 8 BYTES
         GTO ALL1.S            !USE SYSTEM ROUTINE

!Using the 2 tables below this routine sorts the
!system (LOAD, STORE,etc.) and I/O (PRNT#$, READ#$, etc.)
!calls into tape or disk categories. If tape the branch
!to the system is performed, otherwise the routine returns
!for disk.
I/OJSB   LDM R64,=CKMSUS       !SORT TAPEADISC DATAFILE

         DEF TAPI/O            !TAPE I/O ADDR TABLE
         JMP JSBCMN            !DO COMMON STUFF
SYSJSB   LDM R64,=TAPDS-       !SORT TAPE-DISC FILENAMES

         DEF TAPSYS            !TAPE SYS ADDR TABLE
         JMP JSBCMN  
SECJSB   LDM R64,=SECURC       !SORT TAPE/DISC SEC. FILE

         DEF TAPSYS            !TAPE SYS ADDR TABLE
JSBCMN   BSZ 0
         CLB R30
         SAD                   !SAVE ARP
         JSB =MSIN             !RUNTIME INIT
         SBM R30,=5,0          !ADJUST 1 JSB + SAD

         STMD R30,=SAVER6  
         PUMD R66,+R6          !SAVE FROM VOL2AD
         JSB X64,ZRO           !TAPE OR DISC CALL?

         POMD R66,-R6          !RESTORE TABLE ADDR
         JEZ TAPNOT            ! JIF DISC
         CLM R30               ! GET ARP BACK
         POBD R30,-R6
         POBD R30,-R6
         POBD R30,-R6
         ADM R30,R66           ! ARP OFFSET + TABLE BASE
         LDMD R0,R30           ! ADDR FROM TABLE
!When entering REGJSB parameters are:
! 2bytes for final ROMJSB return (call to MS rom)
! 2bytes for R0 restoration
! 1byte for MS rom #
!pushed onto stack in that order, and:
! R65 = new rom # = 0
! R0  = tape routine address
         LDB R65,=MYROM#  
         PUBD R65,+R6          ! FOR RETURN
         CLB R65
         LDMD R12,R14          ! RESTORE TAPE PARAMS
         GTO REGJSB            ! CALL TAPE ROUTINE!

!--------------------------------------------------
TAPNOT   PAD                   ! REMOVE ARP, ETC
         BIN                   ! INCOMING STATE BCD?
         RTN 
!All MS rom commands which have a system tape counterpart
!follow the model:
!COMMAND. ARP 2*n   indicate table entry
!         JSB =SYSJSB   intercept tape commands
!This routine returns only if the command is for disk.
!n is the entry number inthe branch table.
TAPSYS   DEF CHAIN.            ! ARP 0
         DEF STORB.            ! 2
         DEF STORE.            ! 4
         DEF LOADB.            ! 6
         DEF LOAD.             ! 8D
         DEF SECUR.            ! 10D
         DEF UNSEC.            ! 12D
         DEF ASIGN.            ! 14D
!       DEF CREAT.       ! 16D
!All MS rom i/o commands are separated similarly with:
TAPI/O   DEF PRNT#$            ! ARP 0
         DEF PRNT#N            !     2
         DEF READ#N            !     4
         DEF READ#$            !     6
         DEF R#ARAY            !     8D
         DEF P#ARAY            !     10D
!GETS A STRING OFF THE STACK AND PARSES AS A
!FILE SPECIFIER OR MSUS ADDR/VOLUME LABEL.
!RETURNS FILENAME IN FNAME AND TAPE/DISC FLAG
!AND ADDRESS IN R44-47 AS PER ROUTINE MS2AD.
!DOES AUTOMATIC VOLUME SEARCH IF SPECIFIER CONTAINS
!A VOLUME LABEL.
!RETURNS DEFAULT MSUS IF SPECIFIER CONTAINS NEITHER
!VOLUME LABEL NOR MSUS ADDRESS.
!ON INPUT R40 IS USED TO FLAG FILENAME OR MSUS:
!       0: AT LEAST 1 OF FILE NAME OR MSUS
!          NOTE ":T" GIVES ALL-BLANK FILE NAME
!       1: FILENAME ONLY (I.E. NO MSUS ALLOWED)
!       2: MSUS ONLY (I.E. NO FILENAME ALLOWED)
!
DECODE   BSZ 0
         BIN                   ! FOR ADDS
         POMD R34,-R12         ! POP STRING ADDRESS
         POMD R32,-R12         ! POP STRING LENGTH
         JNZ NAMEOK            ! CAN'T BE NULL STRING
         JSB =ER89D            !INVALID PARAM
!
NAMEOK   LDMD R43,=BLANKS      !GET 5 BLANKS

         STMD R43,X14,FNAM     ! STORE FIRST 5 OF 10

         STMD R43,X14,FNAM+5   !STORE LAST 5 OF 10
         CLE                   !SET VOL LABEL FLAG
         LDB R37,=10D          !MAX FILENAME LENGTH
         LDM R26,R14           !RAM BASE
         ADM R26,=FNAM         !STARTING ADDRESS
         ICB R32               !ADJUST ST LENGTH
NXTCH    DCB R32               !CHARACTER COUNT
         JZR ITSDEF            !JIF STRING EXHAUSTED
         POBD R30,+R34         !GET NEXT CHAR
         CMB R30,=PERIOD       !BEGIN VOL LABEL?
         JZR ITSVOL            !JIF VOL SPECIFIER
         CMB R30,=COLON        !BEGIN MSU SPECIFIER?
         JZR ITSMSU            !JIF MSU
!OTHERWISE ITS ANOTHER CHAR IN FILENAME:
         CMB R40,=2            !MSUS ONLY ALLOWED?
         JNZ FNAMOK            !JIF FILENAME OK
ERR21D   JSB =MSERR   
         BYT 26D               !MSUS EXPECTED
FNAMOK   BSZ 0
         TSB R37               !CHECK FILENAME OVERFLO
         JZR NXTCH             !TOO LONG NAMES TRUNCATED
         DCB R37               !ANOTHER CHAR TO ADD
         PUBD R30,+R26         !STORE IT
         JMP NXTCH             !NEXT CHARACTER...
!
ITSMSU   ICE                   !MSUS FLAG
ITSVOL   BSZ 0
         DCB R40               !FILENAME ONLY ALLOWED?
         JNZ MSUSOK            !JIF MSUS OK
         JSB =ER67D            ! FILE NOT FOUND
MSUSOK   BSZ 0
!MSUS STRING NOW ADDRESSED BY R34
!MSUS CHAR COUNT (+1) IN R32
         DCM R32               !ADJUST LEN COUNT
         JEN MS2AD             !JIF MSUS ADDRESS
!SYSTEM ROUTINE GETS BLANKFILLED 6-CHR STR
!*****   PUMD R32,+R12          !STR ONTO STAK
!****    PUMD R34,+R12
!***     JSB =GETNA!            !-R12 BLANKFILLED TO R42
         JSB =DONAME           ! rename fix, does the above
         PUBD R37,+R6          !SAVE WAS-MSUS FLAG
         JSB =VOL2AD           !PERFORM VOL SEARCH
         POBD R37,-R6          !RESTORE WAS-MSUS FLAG
         SBM R12,=10,0         ! part of rename fix"

         RTN 
!LOC!         LOC 70641
ITSDEF   LDMD R44,X14,DEFMSU   !DEFAULT MSUS

         RTN 
MS2AD    BSZ 0
!TAKES ASCII MSUS ADDR AND RETURNS 4 BYTES:
! R44: TAPE (0)/DISC (1) FLAG
! R45: 0<=SELECT CODE<=3
! R46: 0<=CONTROLLER ADDRESS<=7
! R47: 0<=UNIT#<=3
!EXAMPLES: "T","t" RETURN 0,X,X,X
!          "M321" RETURNS 1,0,2,1
!          "m1023"  ->    1,7,2,3
!
         CLM R44               !TAPE FLAG&DISC DEF.ADDR.
         POBD R30,+R34         ! 1ST CHAR OF MSUS ADDR
         CMB R30,=TEE          !TAPE SPECIFIER?
         JZR ISTAPE            !    YES
         CMB R#,=tee           !lower case t?
         JZR ISTAPE            !"T","t" --> it's tape!
         ICB R44               !FLAG A DISC
         SBB R32,=4            !3 DIGITS (+ 1 LETTER)?
         JZR DIG3              !YES
         DCB R32               !4 DIGITS?
         JNZ ERR21D            ! BAD MSUS
         JSB =NXTDIG           !S.C. TENS PLACE
         DCB R#                !TEST FOR TEN
         JNZ ERR21D            ! S.C.>10
         LDB R45,=10D          !LOAD TEN
DIG3     JSB =NXTDIG           !S.C. ONES PLACE
         ADB R45,R47           !TENS*10+ONES
         SBB R45,=3            !10>>7,3>>0
         JSB =NXTDIG           !CONTROLLER#
         STB R#,R46
!..FALL THRU TO NXTDIG FOR UNIT#
NXTDIG   BSZ 0
!NXTDIG GETS NEXT DIGIT AND BINARYS IT INTO R47
         POBD R47,+R34         !GET NEXT CHAR
         SBB R47,=ZERO         !CHAR < '0'
         JNG ERR21D            ! CHAR IS < '0'
         CMB R#,=10D           !CHAR ABOVE '9'?
         JPS ERR21D            ! CHAR IS > '9'
ISTAPE   RTN 
!
ZERO     EQU 48D               !ASCII '0'
TEE      EQU 84D               !ASCII 'T'
tee      EQU 116D              !ASCII 't'
TAPDS-   CLB R40               !NORMAL FILE/MSUS
!TAPE INTERCEPT ROUTINE...
!DECODE FILE SPECIFIER AND SET E=1 IF ITS
!A TAPE FILE (MSUS IS ":T" OR DEFAULT MSUS
!IS TAPE) AFTER PUSHING FILENAME LENGTH
!AND ADDR. ONTO RUNTIME STACK.
!OTHERWISE, DO A RETURN (ITS A DISC FILE).
         JSB =DCDFIL           !DECODE FILE SPECIFIER
         CLE                   !TAPE(1)/DISC(0) FLAG
         JZR ITSTAP            !JIF TAPE
         RTN                   !RETURN TO DISC ROUTINE
ITSTAP   BSZ 0                 !ITS A TAPE FILE
         ICE                   !FLAG THE TAPE
!fall thru to PSHFIL
!---------------------------------------------
PSHFIL   BSZ 0
!PUSHES FILENAME'S LENGTH AND ADDRESS
!ONTO RUNTIME STACK R12
         LDM R32,=6,0          !TRUNCATE TO 6 CHARS

         PUMD R32,+R12         !PUSH LENGTH
         LDM R30,R14           !RAM BASE ADDRESS
         ADM R30,=FNAM         !FILENAME OFFSET
         PUMD R30,+R12         !PUSH ADDRESS
         RTN 
         BYT 241
PACK.    JSB =MSIN             !RUNTIME INIT
         JSB =GETMSU           !GET MSUS
         JNZ PACKDK            !JIF DISC
         JSB =ER18D            !TAPE NOT OK!
PACKDK   BSZ 0
         STMD R44,X14,SRCMSU  

         STMD R44,X14,DSTMSU  
!1. FIND THE FIRST HOLE. ERROR IF NONE
         JSB =HOLE#1           !1ST HOLE
!2. PACK THE FILES, LEAVING DIRECTORY INTACT
PFILES   JSB =NXTENT           !NEXT DIR. ENTRY
         JEN PACKDN            !JIF ALL FILES PACKED
         JSB =GETTYP           !FILE TYPE
         JZR PFILES            !SKIP HOLE FILES
         ICB R#                !LAST FILE?
         JZR PACKDN            !JIF FILES ALL PACKED
!MOVE A FILE
         JSB =LDFBEG  
         STMD R30,X14,SRCORG   !FOR COPY

         JSB =LDRECS  
         STMD R30,X14,CPYSIZ   !FOR MVFILE ROUTINE

         LDMD R32,X14,CUMREC   !DEST. ORIGIN

         STMD R32,X14,DSTORG   !FOR COPY
         JSB =STFBEG  
         ADM R32,R30           !UPDATE CUMREC
         STMD R32,X14,CUMREC   !CUMREC:=CUMREC+CPYSIZ

         JSB =WRTDIR           !REWRITE DIR
         JSB =MVFILE           !MOVE FILE CONTENTS
!RESTORE DIR INFO FOR CALL TO NXTENT
         LDMD R32,X14,DADDR    !DIR SECTOR#

         JSB =GETBUF  
         JMP PFILES            !DO SOME MORE
!---------------------------------------------------
PACKDN   BSZ 0
!ALL FILES NOW RELOCATED--DELETE DIR. HOLES
         JSB =HOLE#1           !BACK TO 1ST HOLE
         LDMD R45,X14,DENTRY   !HOLE DIR INFO

         STMD R45,X14,DENTD    !DEST. DIR ENTRY
NEWSRC   JSB =NXTENT           !FILE TO MOVE
         LDMD R45,X14,DENTRY   !ENTRY TO BE MOVED

         STMD R45,X14,DENTS    !SOURCE DIR ENTRY
         JEN PDELET            !PURGE END HOLES
         JSB =GETTYP           !FILE TYPE
         JZR NEWSRC            !DONT COPY HOLES!
         ICB R#                !LAST FILE?
         JZR PDELET            !NOTHING TO PACK
         JSB =GETINF           !GET SOURCE DIR ENTRY
!RESTORE FIRST DEST DIR SECTOR
         LDMD R32,X14,DADDD    !DEST DIR SECTOR

         JSB =GETBUF           !GET IT
         LDMD R45,X14,DENTD    !RESTORE DIR PTRS

         STMD R45,X14,DENTRY  
         JSB =DIRPTR           !R36 FROM DENTRY,DADDR
         JSB =PUTINF           !TRANSFER DIR ENTRY
NXTTRN   JSB =NXTSRC           !NEXT SOURCE DIR ENTRY
         JSB =GETINF           !PRTBUF:=SRC DIR INFO
         JSB =NXTDST           !NEXT DEST DIR ENTRY
         JSB =PUTINF           !DST DIR INFO:=PRTBUF
         JMP NXTTRN            !LOOP TERMINATES IN NXTSRC
!----------------------------------------------
NXTSRC   LDMD R45,X14,DENTS    !RESTORE DIR PTRS

         STMD R45,X14,DENTRY  
         LDM R32,R46           !RESTORE DIR SECTOR
         JSB =GETBUF  
AD2NTF   JSB =NXTENT           !ADVANCE TO NXT FILE
         JEN PAKDON            !DIR HOLES ALL MOVED
         JSB =GETTYP           !FILE TYPE
         JZR AD2NTF            !HOLE ENTRIES NOT MOVED
         ICB R#                !LAST FILE?
         JZR PAKDON            !VALID ENTRIES ALL MOVED
!NEXT SOURCE ENTRY TO MOVE:
         LDMD R45,X14,DENTRY   !SAVE ...

         STMD R45,X14,DENTS    !... NEW SOURCE PTRS
         RTN 
PAKDON   POMD R30,-R6          !FOR EXTRA JSB
!MAKE THE LAST DEST FILE THE real LAST!
!DELETE HOLES NOW LOCATED AT END OF DIR
PDELET   JSB =HOLE#1           !FIND FIRST HOLE
         JSB =PUR+             !REMAINING ENTRIES 'LAST'ED
         RTN 
!--------------------------------------------------
NXTDST   BSZ 0                 !MOVE TO NEXT DEST DIR ENTRY
         LDMD R45,X14,DENTD    !RESTORE DEST DIR PTRS

         STMD R45,X14,DENTRY  
         LDM R32,R46
         JSB =GETBUF           !RESTORE DIR SECTOR
         JSB =NXTENT           !MOVE TO NEXT FILE
         LDMD R45,X14,DENTRY   !SAVE NEW DEST PTRS

         STMD R45,X14,DENTD   
         RTN 
!-------------------------------------------------------
GETINF   LDM R24,R36           ! SOURCE DIR TO BUFFER
         LDM R26,R14
         LDM R22,=32D,0        !32 BYTES/DIR ENTRY

         JSB =MOVUP            !PRTBUF:=SRC DIR INFO
         CLB R30               !'HOLE' FILE TYPE
         JSB =PUTTYP           !INTO DIR
         JMP PUTIN+  
!-----------------------------------------------------
PUTINF   BSZ 0                 !BUFFER TO DIRECTORY
         LDM R24,R14
         LDM R26,R36           !DEST FOR MOVE
         LDM R22,=32D,0        !32 BYTES/DIR ENTRY

         JSB =MOVUP            !DST DIR INFO:=PRTBUF
!FALL THRU TO WRTDIR
PUTIN+   BSZ 0
!------------------------------------------------
WRTDIR   BSZ 0
!REPLACES ONE DIRECTORY SECTOR
! RECBUF: CAPR ADDR OF MODIFIED SECTOR
! DADDR: DISC ADDRESS OF DIR SECTOR TO REPLACE
!Note: interchange format requires volume field
! (in each dir entry) to indicate file is
! contained entirely in this volume.
         JSB =DIRPTR           !R36:=DIR PTR
         LDM R32,=200,1        !ENTIRE FILE THIS VOLUME

         STMD R32,X36,D.VOL   

         LDMD R32,X14,DADDR    !DISC ADDRESS

         JSB =PUTBUF           !REWRITE THE DIR
         RTN 
! ASTORE"MASSPART3.MASROM"
!Depending on 'source', COPY will perform one of:
!1.Volume copy. If 'source' is an msus (i.e. filename
!  is blank), COPY will expect dest. to be an msus
!  and copy an entire medium.
!2.File copy. If 'source' is a file specifier (i.e.
!  filename non-blank), COPY will expect dest. to be
!  the same and copy only a single file.
         BYT 241
MSCPY.   JSB =MSIN             !RUNTIME INIT
         SBM R12,=4,0          !POINT AT SOURCE

         CLB R40               !ALLOW ANY OLD FILE SPEC.
         JSB =DCDFIL           !DECODE SOURCE FILE
         STMD R44,X14,SRCMSU   !STASH SRC. MSUS

         PUBD R37,+R6          !SAVE WAS-MSUS FLAG(DCDFIL)
         JSB =TINIT?           ! TAPE INIT
         POBD R37,-R6          !RESTORE WAS-MSUS FLAG
         ADM R12,=8D,0         !POINT AT DEST.

         POMD R44,-R12         !GET DEST
         LDMD R12,=TOS         !RESET R12

         PUMD R44,+R12         !REPLACE DEST
!CHECK FOR VOLUME COPY
         CMB R37,=10D          !DCDFIL: WAS-MSUS?
         JZR WASMSU            !IT WAS
         GTO NVCOPY            !ITS A FILE COPY

!ITS A VOLUME COPY
WASMSU   BSZ 0                 !R37=10D
         LDB R40,=2            !ALLOW MSUS ONLY
         JSB =DCDFIL           !PARSE 2ND MSUS
         STMD R44,X14,DSTMSU   !SAVE DEST MSUS

         JSB =TINIT?  
         LDMD R44,X14,DEFMSU   !UNTIL V-COPY COMPLETE...

         PUMD R44,+R6          !STASH DEF.MSUS
         LDMD R44,X14,DSTMSU   !FOR CREATE

         STMD R44,X14,DEFMSU   !CUZ NO MSUS USED
!GET FIRST FILE TO COPY
         LDMD R44,X14,SRCMSU   !FOR DIR SEARCH
         STMD R44,X14,ACTMSU  
!                                 TAPE OR DISC?
         JZR TAP1ST            !GET 1ST TAPE FILE
         JSB =GETDIR           !GET 1ST DISC FILE
         JSB =SKHOL+           !SKIP HOLES
         JMP ONEFI-            !CK FOR DIR.END
TAP1ST   CLB R36               !INIT TAPE DIR SEARCH
         STBD R36,=USED?       !FLAG 1ST SEG
         LDBD R36,=DIRSEG      ! IN SEGMENT 0?
         JZR GOTS0             !ALREADY THERE
         JSB =TRDOPS           !READ OPPOSITE DIRSEG
GOTS0    LDM R36,=DIRECT       !1ST TAPE DIR PTR

         JSB =HAVFIL           !SKIP HOLES
ONEFI-   JEN VCDONE            !JIF END OF DIR
ONEFIL   STMD R#,R14           !SAVE DIR INFO
         STBD R30,=FILTYP      !FOR TAPE COPY

         LDMD R44,X14,SRCMSU   !GET SOURCE

         STMD R44,X14,ACTMSU   !FOR DIR SEARCH
!COPY ONE FILE
!                                 TAPE OR DISC?
         JZR TVC               !JIF TAPE
         LDM R32,=NAMLEN       !DSK FILE LENGTH

         JMP FCOP              !DO THE FILE COPY
TVC      LDM R32,=6,0          !TAPE FILE LENGTH

FCOP     PUMD R32,+R12         !PUSH STR LENGTH
         LDM R32,R14           !BUILD STR ADDR
         ADM R32,=FNAM         !FILENAME OFFSET
         LDM R30,R32           !TDSCAN(FNAM), CREATE+(GNAM)
         ADM R30,=NAMLEN       !GNAM = FNAM + NAMLEN
         PUMD R30,+R12         !STRING LOCATED HERE
         POMD R43,+R36         !FNAM := DIR FILENAME
         PUMD R43,+R32         !HALF TRANSFERRED
         PUMD R43,+R30         !TO GNAM TOO
         POMD R43,+R36
         PUMD R43,+R32         !ALL TRANSFERRED
         PUMD R43,+R30         !GNAM TOO
         JSB =FILCPY           !PERFORM FILE COPY
         JSB =NXTFIL           !SCAN NEXT SRC FILE
         JEZ ONEFIL            !COPY ANOTHER FILE
VCDONE   POMD R44,-R6          !RESTORE OLD DEFAULT MSUS
         ARP R14               ! fix for copy
         JSB =TAPFIX  
         RTN 
!ITS A FILE COPY-----------------------------------------------
!NVCOPY  POBD R44,-R6     !  TAPE/DISC FLAG
NVCOPY   BSZ 0
!FILCPY  STBD R#,X14,CPYSIZ !FOR DUP PRTCT CK
FILCPY   BSZ 0
         LDBD R44,X14,SRCMSU   !TAPE/DISK FLAG TDSCAN

         JSB =TDSCAN           !SCAN FOR SOURCE FILE
         PUMD R24,+R6          !SAVE BYTES LAST REC
         PUMD R22,+R6          !SAVE SOURCE BYTES
         PUBD R30,+R6          !AND TYPE
         PUMD R26,+R6          !LOG BYTES/REC
         JEZ FILFND            !FILE FOUND
         JSB =ER67D            !FILENAME EXPECTED
!CREATE THE DESTINATION FILE (AS DATA FILE)
FILFND   STMD R32,X14,SRCORG   !SOURCE FILE ORIGIN

         STMD R34,X14,CPYSIZ   !RECS TO COPY

         STMD R32,=CURFIL      !FOR TAPE DUP PRTCT

         CLM R32
         STMD R32,=CURREC      !1ST TAPE FILE RECORD
!COMPUTE LOG.RECS GIVEN PHYS RECS,LOG.BYTES
         LDM R46,R34           !PHYS. RECS
         POMD R32,-R6          !LOG. BYTES/REC
         PUMD R32,+R6          !FOR 2ND CREATE PARAM
         JSB =LOGRE+           !CF CAT:R36=LOG.RECS
         JSB =CONBIN           !R36 INT TO R40 REAL
         PUMD R40,+R12         !FOR CREATE
         POMD R36,-R6          !SOURCE LOG BYTES/REC
         JSB =CONBIN           !R36 INT TO R40 REAL
         BIN 
         PUMD R40,+R12         !FOR CREATE DEST FILE
!SKIP DUPLICATION-PROTECTED PROGRAM FILES........
         POBD R47,-R6          !CK SOURCE FILE TYPE
         PUBD R47,+R6          !RESTORE FOR DIR FIX
         ANM R47,=P/BTYP       !PROGRAM OR BINARY TYPE?
         JZR DUPOK1            !NOT PROG--> DUP IS OK
         LDBD R47,X14,SRCMSU   !TAPE OR DISC?

         JZR DUPTAP            !JIF TAPE
         LDMD R32,=CURFIL      !PROG FILE ORIGIN

         JSB =GETBUF           !READ 1ST SECTOR
         JMP CKDUP   
DUPTAP   JSB =RDTAPE           !READ FIRST RECORD
CKDUP    JSB =SREAD+           !SYSTEM CK SECUR BIT
         JPS DUPOK1            !NO DUPLIC. PROTECTION
         POMD R43,-R6          !CLEAN OFF STACK
         LDMD R12,=TOS         !JUNK COPY/CREATE PARAMS

         GTO TXIT              !COPY NOT PERFORMED

!FILE NOT DUPLICATION-PROTECTED, PROCEED WITH COPY
DUPOK1   JSB =MSCRE+           !CREATE DEST. AS DATA
         JSB =INIT14           !RESTORE AFTER TAPE
         LDMD R44,X14,ACTMSU   !DEST. MSUS

         STMD R44,X14,DSTMSU   !FOR TRANSFER
         PUBD R44,+R6          !FOR TAPE/DISC CHECKS
         JSB =TINIT?           ! TAPE INIT
!GET DEST. FILE INFO
         POBD R44,-R6          !TAPE/DISC FLAG
         PUBD R44,+R6          !RESTORE IT
         JSB =TDSCAN           !FIND THE FILE
         STMD R32,X14,DSTORG   !DEST. ORIGIN

!REWRITE DIR WITH CORRECT TYPE
         POBD R44,-R6          !TAPE OR DISC?
         POBD R30,-R6          !RESTORE SOURCE TYPE
         STBD R30,=FILTYP      !FOR TAPE TRANSFERS
         POMD R22,-R6          !RESTORE SOURCE BYTES
         TSB R44               !TAPE/DISC FLAG
         JZR TAPTYP            !JIF TYPE
         STMD R22,X36,D.BYTS   !FOR PROG FILES

         JSB =PUTTYP           !TYPE INTO DISC DIR.
         JSB =WRTDIR           !WRITE IT
         JMP TYPCOM  
TAPTYP   BSZ 0
!2/15/80 disk extended-->tape extended sets only D.TYPE,
!and clears D.FIL#:
         STB R30,R31
         CLB R30
         STMD R30,X36,D.FIL#   !D.FIL#:=0;D.TYPE:=4

         LDMD R30,X36,D.#R/F   !FOR WRTRND EMPTY
         STMD R30,=R/FILE  
!2/29/80: TAPE FILES NEED EMPTY REC AT END IF SPACE ALLOWS
         JSB =DIRTAP           !REWRITE TAPE DIR
!COPY FILE FROM SOURCE TO DEST.
!FOUR CASES: T->T,D->D,T->D,D->T
TYPCOM   CLM R30               !RESET...
         STMD R30,=CURREC      !FIRST TAPE REC
         LDBD R30,X14,SRCMSU   !SOURCE

         JZR TSRC              !JIF TAPE SOURCE
!DISC IS SOURCE....................................
         LDBD R30,X14,DSTMSU   !DESTINATION
         JZR D2T               !JIF DISC->TAPE
!DISC TO DISC........................................
         POMD R30,-R6          !BECAUSE NOT D->T
!fall thru to MVFILE...
!--------------------------------------------------------------
MVFILE   CLM R32               !MOVE AN ENTIRE FILE
         STMD R32,=CURREC      !0 IS 1ST TAPE REC
!READ ONE REC FROM SOURCE
NEXTR    LDMD R32,X14,SRCORG   !SOURCE ORIGIN

         LDMD R44,X14,SRCMSU   !SOURCE MSUS

         STMD R44,X14,ACTMSU   !FOR LOW LEVEL
         ICM R32
         STMD R32,X14,SRCORG   !UPDATE SECTR CNT
         DCM R32               !READJUST
         JSB =GETBUF           !READ A SECTOR
!WRITE ONE RECORD TO DEST.
         LDMD R32,X14,DSTORG   !DEST. ORIGIN

         LDMD R44,X14,DSTMSU   !DEST MSUS

         STMD R44,X14,ACTMSU   !FOR LOW LEVEL
         ICM R32
         STMD R32,X14,DSTORG   !UPDATE SECTR CNT
         DCM R32               !READJUST
         JSB =PUTBUF           !DISC WRITE
         LDMD R32,=CURREC      !CURRENT REC#

         ICM R32
         STMD R32,=CURREC      !UPDATE IT
         JSB =MORE?   
         JNZ NEXTR             !MORE TO TRANSFER
         RTN                   !TRANSFER COMPLETE
!----------------------------------------------------------
!DISC TO TAPE...........................................
D2T      LDMD R44,X14,SRCMSU  

         STMD R44,X14,ACTMSU   !FOR LOWLEVEL
         LDMD R30,X14,SRCORG   !DISC SRC ORIGIN

         JSB =HLSEEK           !GO THERE
         LDBD R#,X14,DSTORG    !CURRENT TAPE FILE

         STBD R#,=CURFIL  
D2TLOP   JSB =GETBU+           !READ A RECORD
         JSB =MORE?            !ALL DONE?
         ICM R32               !R32:=CURREC+1
         CMM R32,R30           !CURREC+1=CPYSIZ?
         JZR D2TLST            !JIF LAST REC
         LDM R22,=0,1          !256 BYTES/FULL RECORD

         JMP D2TPR   
D2TLST   POMD R22,-R6          !#BYTES LAST REC
D2TPR    JSB =WRTAPE           !TAPE WRITE RECORD
         JSB =MORE?   
         JNZ D2TLOP            !MORE TO COPY
         JMP MTREC?            !NEED EMPTY REC?
!TAPE IS SOURCE.......................................
TSRC     POMD R22,-R6          !BECAUSE NOT D2T
         JSB =TINIT?           ! FOR VOLUME COPY
         LDBD R22,X14,DSTMSU   !DESTINATION

         JNZ T2D               !JIF TAPE->DISC
!TAPE TO TAPE.........................................
T2TLOP   LDBD R30,X14,SRCORG   !CURENT TAPE FILE

         STBD R30,=CURFIL      !FOR TAPE DRIVER
         JSB =RDTAPE           !RANDOM TAPE READ
         JSB =TAPMOR           !MORE TAPE TO READ?
         SAD                   !SAVE TAPMOR RESULT
         LDBD R56,X14,DSTORG   !CURRENT TAPE FILE

         STBD R56,=CURFIL      !FOR TAPE DRIVER
         JSB =WRTAPE           !TAPE WRITE RECORD
         PAD                   !RESTORE TAPMOR RESULT
         JNZ T2TLOP            !MORE RECS TO COPY
!EMPTY RECORD WRITE IF SPACE EXISTS:
MTREC?   BSZ 0
!WRITE ONE EMPTY REC
         JSB =ROMJSB  
         DEF TAPEX-            !RANDOM EMTPY + TAPEXT
         BYT 0
         RTN 
!TAPE TO DISC.......................................................
T2D      LDMD R30,X14,DSTORG   !DISC FILE ORIGIN

         JSB =HLSEEK           !GO THERE
         LDBD R#,X14,SRCORG    !CURRENT TAPE FILE

         STBD R#,=CURFIL       !FOR TAPE DRIVER
T2DLOP   JSB =RDTAPE           !RANDOM TAPE READ
         LDMD R30,=CURREC      !INCREMENT...

         ICM R30
         STMD R30,=CURREC      !...RECORD COUNTER
         JSB =TAPMOR           !LAST REC?
         SAD                   !SAVE TAPMOR RESULT
         JNZ T2DPR             !NOPE
         STMD R22,=GAPLEN      !SAVE FOR DISC DIR UPDATE

T2DPR    BSZ 0
         JSB =PUTBU+           !WRITE TO DISC
         PAD                   !RESTORE TAPMOR RESULT
         JNZ T2DLOP            !COPY MORE RECS
         JSB =DIRSCN           !FIX DISC DIR.
         LDMD R22,=GAPLEN      !BYTES LAST TAPE REC

         LDMD R30,=CURREC      !# RECS TRANSFERRED

         DCB R30               !REDUCE BY 1 REC
         ADB R23,R30           !#RECS*256+BYTES-LAST-REC
         STMD R22,X36,D.BYTS   !TOTAL BYTES IN FILE

         JSB =WRTDIR           !REWRITE DIR
!-----------------------------------------------------------
TXIT     JSB =ROMJSB  
         DEF TAPEXT            !CRT BACK ON
         BYT 0
         RTN 
!-----------------------------------------------------------
TDSCAN   JZR TAPDIR            !JIF TAPE DIR.SCAN
         JSB =DIRSCN           !SCAN DISC DIR.
         DRP R32
         JSB =LDFBEG           !DISC FILE ORIGIN
         LDMD R22,X36,D.BYTS   !BYTES COUNT

         DRP R34
         JSB =LDRECS           !# RECS IN FILE
!2/29: BYTES LAST REC := 256 FOR DATA FILES;
!ALSO  PROG FILE COPY LENGTH CAN BE LESS THAN FILE
!      LENGTH IF FILE CREATED IN BIGGER HOLE.
         LDM R24,=0,1          !256 BYTES LAST DATA REC

         JSB =GETTY+           !FILE TYPE & fix
         CMB R#,=DATATY        !DATA FILE?
         JZR TDSRTN            !ALREADY LOADED
         JSB =BYTES            !FOR D.BYTS FILES
         STM R#,R24            !R45,46=BYTES LAST REC
         CLM R34
         LDB R34,R47           !# SIGNIF. RECS
TDSRTN   LDMD R26,X36,D.B/RC   !LOG BYTES REC

         RTN 
TAPDIR   JSB =TINIT!           !CRT OFF ALWAYS!
!-----------------------------------------------------
!This is necessary if its a vol copy (which
!turns CRT off only once). Needed for checking
!PROG file dup prot. to read 1st rec of file.
         LDMD R42,X14,FNAM     !DISC NAME

         STMD R42,=SAVNAM      !TAPE SCAN NAME
         STBD R#,=GINTDS       !DISABLE FOR TAPE
         JSB =ROMJSB  
         DEF DSCAN             !SCAN TAPE DIR.
         BYT 0
         PUMD R36,+R6          !SAVE DIR PTR
         JSB =TAPR/W           !TAPE RECOVERY
         POMD R36,-R6          !RESTORE DIR PTR
         LDMD R34,X36,D.#R/F   !FILE LENGTH

         LDBD R30,X36,D.TYPE   !SRC FILE TYPE

         LDMD R26,X36,D.#B/R   !LOG BYTES/REC

         CLM R22               !FOR T-->D D.BYTS:=0 UNTIL COMPLETED
         JSB =FET44            !GET FILE# TO R44
         LDM R32,R44           !FILE ORIGIN(FILE#)
         JMP TAP#              !CK TAPE EXTENDED BIT
!------------------------------------------------------
MORE?    LDMD R30,X14,CPYSIZ   !RECS TO COPY

         LDMD R32,=CURREC      !CURRENT REC

         CMM R32,R30           !CURREC=CPYSIZ?
         RTN 
!-------------------------------------------------------------
!Get next directory entry for copying files.
!Returns: E=1 directory is exhausted,
!         E=0 R36 is valid directory pointer.
NXTFIL   LDMD R45,R14          !RESTORE DIR INFO
         LDMD R54,X14,SRCMSU   !RESTORE FOR GETSEC

         STMD R54,X14,ACTMSU   !...RESTORED
         JZR TAPNXT            !JIF TAPE
         STMD R45,X14,DENTRY   !..RESTORED

         STM R46,R32           !RESTORE DIR SECTOR
         JSB =GETBUF           !RESTORE DIR SEGMENT
SKHOLE   JSB =NXTENT           !SCAN NEXT FILE
         JEN NXTDR+            !NO MORE FILES!
SKHOL+   ICE                   !FLAG LAST FILE
         JSB =GETTYP           !CK FILE TYPE
         ICB R#                !LAST FILE?
         JZR NXTDR+            !JIF LAST FILE
         DCB R#                !HOLE FILE?
         JZR SKHOLE            !THEN SKIP IT!
         CLE                   !FLAG GOOD FILE
         LDMD R45,X14,DENTRY   !NEW DENTRY

NXTDR+   RTN 
!----------------------------------------------------
TAPNXT   LDBD R30,=DIRSEG      !CURRENT DIR.SEG.

         CMB R30,R45           !SAME AS OLD?
         JZR OLDCUR            !JIF SAME
         JSB =TRDOPS           !RD OPS TAPE DIR
OLDCUR   LDMD R45,R14          !RESTORE DIR INFO
         LDM R36,R46           !GET DIR PTR
BUMP     ADM R36,=14,0         !BUMP DIR PTR

         CMM R36,=DIREND       !OUT OF DIR SPACE?
         JNC HAVFIL            !HAVE A TAPE FILE
         LDBD R36,=DIRSEG      !OTHER SEG USED?
         JZR GETSEG            !NEED 2ND DIR SEG
AVALEX   CLE                   !FLAG NO MORE FILES
         ICE 
         RTN 
GETSEG   ICB R#                !FLAG 1ST SEG USED
         STBD R#,=USED?   
         JSB =TRDOPS           !RD OPS TAPE DIR
         LDM R36,=DIRECT  

HAVFIL   LDBD R30,X36,D.TYPE   !TAPE FILE TYPE

         JNG AVALEX            !ITS NEXT AVAIL
         LLB R30               !CK FOR EMPTY
         TSB R30
         JNG BUMP              !SKIP HOLES
         LRB R30               !RESTORE TYPE FOR FILTYP
         LDM R46,R36           !SAVE DIR PTR
         LDBD R45,=DIRSEG      !CURRENT DIR SEG

         CLE                   !FLAG OK FILE
!TRANSFORM TAPE EXTENDED TO DISC EXTENDED
TAP#     LDBD R77,X36,D.FIL#   !CK TAPE EXTENDED

         ANM R77,=200          !CK EXTEND BIT
         JZR EXTNOT            !JIF NOT EXTENDED
         LDB R31,=4            !TO SET DISC EXTENDED
         ORB R30,R31           !CUZ NO ORB LITERAL!!!!!
EXTNOT   BSZ 0
         DRP R45
         RTN 
!------------------------------------------------------
TRDOPS   STBD R#,=GINTDS       !DISABLE FOR TAPE
         JSB =TINIT!           !CRT OFF FOR REWIND DIR
         JSB =ROMJSB  
         DEF REDOPS            !READ OPOSITE TAPE DIR
         BYT 0
         JMP TAPR/W  
!--------------------------------------------------------
TINIT?   TSB R44               ! CRT OFF IF MSUS = TAPE
         JNZ TINRTN            !JIF DISC
TINIT!   JSB =ROMJSB           !INIT TAPE, CRT OFF
         DEF TAPINT            !CRT OFF
         BYT 0
         JMP TAPR/W  
!--------------------------------------------------------
WRTAPE   LDM R56,=RECBUF       !BUFFER ADDRESS

         STBD R#,=GINTDS       !DISABLE FOR TAPE
         JSB =ROMJSB  
         DEF WRTRND            !WRITE A RECORD
         BYT 0
TAPR/W   JSB =ROMJSB  
         DEF STOPTP            !STOP THE TAPE
         BYT 0
         JSB =INIT14           !AFTER TAPE
         STBD R#,=GINTEN       !R-ENABLE AFTER TAPE
TINRTN   RTN 
!-------------------------------------------------------------
RDTAPE   LDM R56,=RECBUF       !TAPE READ BUFFER

         STMD R56,=LOADAD      !SAVE ADDR
         STBD R56,=GINTDS      !DISABLE FOR TAPE
         JSB =ROMJSB  
         DEF REDRN*            !TAPE READ 1ST PART
         BYT 0
         JSB =READ8+           !TAPE READ 2ND PART
         JMP TAPR/W            !COMMON TAPE EXIT
!-------------------------------------------------------------
DIRTAP   JSB =ROMJSB  
         DEF FIND+W            !REWRITE TAPE DIR
         BYT 0
         JMP TAPR/W            !TAPE COMMON EXIT
!----------------------------------------------------
TAPMOR   BSZ 0
!WHEN READING FROM TAPE, IF # BYTES READ IS
! < 256 THEN DONE READING.
!RETURNS: ZR=0 --> NOT LAST REC, READ MORE!
!         ZR=1 --> LAST REC
!         R22 = BYTES READ THIS REC: >=0,<=256
         CLM R22
         JEN IMTHRU            !RDTAPE: E=1 --> EMPTY REC
         LDBD R22,=HEDAD6      !BYTES READ -1
         ICM R22               !BYTES READ
IMTHRU   BSZ 0
         CMM R22,=0,1          !256 BYTES READ?

         JNG CONT3             !<256 READ --> LAST REC
!256 EXACTLY READ. FILE LENGTH EXCEEDED?
         JSB =MORE?   
         JZR CONT3             !CURRECS = FILELENGTH
         CLB R20
         ICB R20               !ZR=0-->NOT LAST REC
         RTN 
CONT3    CLB R20               !ZR=1-->LAST REC
         RTN 
!LOC!         LOC 73321
         BYT 241
VOLUM.   JSB =MSIN             !RUNTIME INIT
         JSB =GETNA!           !GET 6-CHAR LABEL
         STMD R42,R14          ! STASH IT
         LDB R40,=2            !ALLOW MSUS ONLY
         JSB =DCDFIL           !PARSE MSUS
         JNZ VOLDSK            !JIF DISC
         JSB =ER18D            !TAPE NOT IMPLEMENTED
VOLDSK   CLM R32               !SECTOR#0
         JSB =GETBUF           !READ IT
         LDM R30,=RECBUF       !BUFFER BASE

         LDMD R42,R14          ! GET NEW VOL.LABEL
         STMD R42,X30,V.LABL   !UPDATE IT

         CLM R32               !SECTOR#0
         JSB =PUTBUF           !REPLACE IT
         RTN 
!-------------------------------------------------------
BYTES    BSZ 0
!USE D.BYTS TO COMPUTE #-OF-SIGNIFICANT-RECS,
! #-BYTES-IN-LAST-RECORD IN A FILE.
         LDMD R76,X36,D.BYTS  

         CLM R45
         LDB R45,R76
         JNZ BYT1    
         ICB R46
!NOW R45,6 = BYTES IN LAST REC
BYT1     LDB R47,R77
         TSB R76
         JZR BYT2    
         ICB R47
!NOW R47 = # SIGNIFICANT RECORDS IN FILE
BYT2     DRP R45
         RTN 
         BYT 241
CHECK.   JSB =ROMJSB           ! check read moved
         DEF CHECK2            !   to second rom
         VAL MSROM2  
         RTN 
CHECK2   DAD 61001             ! DON'T HAVE SOLID ADDR YET
! GETTY+.MASROM
GETTY+   BSZ 0
         JSB =GETTYP           ! GET FILE TYPE
         LDB R77,R30           ! TRANSFER
         ANM R77,=DATATY       ! IF DATA,STRIP SECURITY
         RTN                   ! IF NOT DATA RESULT ZERO
! PSHVOL.MASROM
PSHVOL   BSZ 0
!        ARP !26
         LDMD R42,=VLHED2      ! 1ST PART OF 2ND HEADER

         PUMD R42,+R#
         RTN 
! SD&POL.MASROM
SD&POL   BSZ 0
         JSB =S2#3    
         JSB =PPOLL            ! PPOLL WAIT FOR MSC
         RTN 
! MASSRUN10.MASROM
!LOC!         LOC 73462
         BYT 241
CHKOF.   JSB =ROMJSB           ! check read off moved
         DEF CHKOF2            !  to second rom
         VAL MSROM2  
         RTN 
CHKOF2   DAD 61043             ! DON'T HAVE SOLID ADDR YET
!LOC!         LOC 73475
         BYT 241
GLOAD.   BSZ 0
         JSB =MSIN             ! RUNTIME INIT
         JSB =GCOMN            ! INIT & PARSE FILE
         LDB R#,=T.GRAF  
         STBD R#,=FILTYP       ! FOR GETFIL
         JSB =GETFIL           ! SCAN,CK TYPE,SEEK
!NOW DO THE LOAD
         LDB R#,=24D           ! 24 RECS/SCREEN
LLOOP    STBD R#,=MTFLAG       ! FOR REC COUNT
         JSB =GETBU+  
         LDM R26,=RECBUF       ! BUFFER ADDR

         CLB R36               ! 256 BYTE COUNT
LLOOP2   JSB =CHKSTS           ! WAIT FOR CRT
         POBD R#,+R26          ! GET A BYTE FRM BUFFER
         STBD R#,=CRTDAT       ! WRITE TO CRT
         DCB R36               ! 256 COUNT
         JNZ LLOOP2            ! MORE IN BUFFER
         LDBD R#,=MTFLAG       ! 24 REC COUNT
         DCB R#
         JNZ LLOOP             ! GET MORE GRAFURE
GDSK     RTN 
!------------------------------------------------------
GCOMN    JSB =GRAPH.           !SET GRAPHICS MODE
         CLM R76
         JSB =DRAW1            !ADDRESS CRT
         JSB =TAPDS-           !TAPE FILE?
         JEZ GDSK              !JIF DISC
         POMD R44,-R12         !POP TAPE FILE NAME
         JSB =ER18D            !TAPE NOT IMPLEMENTED
!-------------------------------------------------------
         BYT 241
GSTOR.   BSZ 0
         JSB =MSIN             !RUNTIME INIT
         JSB =GCOMN            !PARSE FILE
         LDB R#,=T.GRAF        !GRAFURE FILE TYPE
         STBD R#,=FILTYP  
         CLM R44               !FOR FILE SIZE CK
         LDB R47,=24D          !SCREEN=6K=24RECS
         STMD R44,=NXTDAT      !6K-0=FILE SIZE

         JSB =FILOK?           !EXIST,TYPE,LENGTH,ETC
!NOW DO THE STORE
         LDB R#,=24D           !24 RECS/SCREEN COUNT
SLOOP    STBD R#,=MTFLAG       !FOR COUNT
         CLB R36               !256 BYTE COUNT
         LDM R26,=RECBUF       !BUFFER ADDR

SLOOP2   JSB =INCHR            !GET CHAR FROM SCREEN
         PUBD R#,+R26          !OUTPUT TO BUFFER
         DCB R36               !RECORD DONE?
         JNZ SLOOP2            !MORE IN REC
         JSB =PUTBU+           !OUTPUT TO DISC
         LDBD R#,=MTFLAG       ! 24 REC COUNT
         DCB R#
         JNZ SLOOP             !MORE RECS TO GET
         RTN 
!**999999999999999999999999999999999999999***
!   ERROR AND INITIALIZATION MESSAGES       :
!   FOLLOW.                                 *
!********************************************
ERMESS   BSZ 0
!-----------------------------------------------
!To all ROM modifiers: Please note the following
!OUTRAGEOUS code. VOLHED has been underscored and
!moved to the error msg table to save 7 bytes.
VOLHED   VAL V       
         BYT 357               !o
         BYT 354               !l
         BYT 365               !u
         BYT 355               !m
         BYT 345               !e
         BYT 272               !:
         BYT 200               !SYS DEF
         BYT 200               !SYS DEF
         BYT 200               !SYS DEF
!10D:
         ASP "I/O CARD"
!11D:
         ASP "IOP" 
!12D:
         ASP "M.S.ROM" 
!13D:
         BYT 240
!14D:
         BYT 240
!15D:
         BYT 240
!16D:
         BYT 240
!17D:
         BYT 240
!18D:
         BYT 240
!19D
         BYT 240
!20D
         BYT 240
!21D
         BYT 240
!22D
         BYT 240
!------------------------------------------------------------
!Mass Storage ROM error messages begin # 18d
!23D:
         ASP "DISC ONLY"
!24D:
         ASP "FILES"
!25D:
         ASP "VOLUME"
!26D:
         ASP "MSUS"
!27D:
         ASP "READ VFY"
!28D:
         ASP "FULL"        !NO SPACE THIS DISC 
!29D:
         ASP "MEDIUM"
!30D:
         ASP "DISC"
!31D:
         ASP "TIME-OUT"

         BYT 377
A        EQU 301
B        EQU 302
C        EQU 303
D        EQU 304
E        EQU 305
F        EQU 306
G        EQU 307
H        EQU 310
I        EQU 311
J        EQU 312
K        EQU 313
L        EQU 314
M        EQU 315
N        EQU 316
O        EQU 317
P        EQU 320
Q        EQU 321
R        EQU 322
S        EQU 323
T        EQU 324
U        EQU 325
V        EQU 326
W        EQU 327
X        EQU 330
Y        EQU 331
Z        EQU 332
!**777777777777777777777777777777777777777***
!   THE INITIALIZATION ROUTINE FOLLOWS      *
!   THE VARIOUS TYPES OF INITIALIZE         *
!   ARE DESIGNATED BY ROMFL, VIZ.:          *
!  ROMFL                                    *
!   0  POWER ON                             *
!   1  RESET                                *
!   2  SCRATCH  (DE-INITIALIZE)             *
!   3  LOAD BIN                             *
!   4  RUN, INIT                            *
!   5  LOAD (DOES SCRATCH SO DE-INIT)       *
!   6  STOP                                 *
!   7  CHAIN                                *
!   10 ALLOCATE - CLASS > 56                *
!   11 DEALLOCATE - CLASS > 56              *
!   12 DECOMPILE - CLASS > 56               *
!                                           *
!   CLASS = LEAST SIG. 6 BITS  OF ATTRIBUTE *
!   BIT 7 = BASIC/NON-BASIC   (STMT TYPE)   *
!   BIT 6 = LEGAL AFTER THEN                *
!********************************************
MSDUMP   BSZ 0
         JSB =ININIT  
!WHEN PAUSE OCCURS DUMP ALL DISC BUFFERS
!ALSO WHEN I/O OCCURS IN CALC MODE.
         LDM R46,=12,0         !TEN ENTRIES

CLRAS+   PUMD R#,+R6           !SAVE COUNTER
         JSB =GET#1+           !GET 0(CLOSED) OR CURLOC
         JZR NEXTCL            !JIF CLOSED
         LDBD R22,X26,A.MSUS   !JIF TAPE

         JZR NEXTCL            !DONT CLOSE IF TAPE
         JSB =WRTDA-           !DUMP A BUFFER TO DISC
NEXTCL   POMD R46,-R6          !POP COUNTER
         DCM R46
         JNZ CLRAS+  
         RTN 
!----------------------------------------------------
INITIT   BSZ 0
         BIN                   !FOR ADDS
         LDBD R34,=ROMFL       !WHAT KIND INIT?

         JZR YESPOW            !POWER ON IF ROMFL = 0
         CMB R34,=6
         JZR MSDUMP            !PAUSE IF ROMFL = 6
         CMB R34,=1
         JZR NOTPAU            !RESET IF ROMFL = 1
         RTN 
!***** ******* PAUSE (ROMFL = 6)
!***** ******* POWER ON (ROMFL = 0)
YESPOW   BSZ 0
         JSB =ININIT  
!Perform checksum verification:
         LDM R32,=R60K         ! START ADDR =24K

         JSB =RSUM8K           !SYSTEM CHECKSUM
         JZR CKSMOK            !CHECKSUM OK
!REMOVE * IN PRECEDING LINE FOR RELEASED ROM!!!!!!!!!
!        JMP CKSMOK             !FOR RAM ROM!!!!!!!!!!!
         JSB =MSERR   
         BYT 12D               !CHECKSUM FAIL
CKSMOK   BSZ 0
!********************************************
!POWER-ON INITIALIZATION
! GET RAM FOR MS ROM READ/WRITE VARIABLES, AND THEIR
!       RAM OFFSETS FROM THE BASE ADDRESS MSBASE:
PRTBUF   EQU 0                 !32-BYTE CAT PRINTER BUFFER
DEFMSU   EQU 32D               !4-BYTE DEFAULT MSUS
!       FILENAME: 10-CHAR FILE NAME
FNAM     EQU 36D               !ORIGIN
FNAM+5   EQU 41D               !2ND HALF
NAMLEN   EQU 10D               !FILENAME LENGTH(NOTE FNAM+NAMLEN=GNAM)
SEC1/2   EQU 5D                !NAMLEN/2
!       2ND FILENAME: ALSO 10 CHARS
GNAM     EQU 46D               !ORIGIN
GNAM+5   EQU 51D               !2ND HALFOF NAME
!       SPECIF:6-CHAR VOL LABEL/MSUS
SPECIF   EQU 56D
!       DATA BUFFER FOR TRANSLATOR LOW-LEVEL DRIVERS
!                   (10D BYTES)
DATAB    EQU 62D
DEVNO    EQU 72D
ERRORR   EQU 73D               ! BUFADR
DSJBYT   EQU 74D               !  "
NPARAM   EQU 75D               ! BUFLEN
IOBADD   EQU 76D               !(2 BYTE IO BUFFER ADDRESS FOR IND ADDR)
STATDD   EQU 78D               !4-BYTE R/W SECTOR STAT. VAR
DENTRY   EQU 82D               !1-BYTE CURRENT DIR ENTRY OFFSET
DADDR    EQU 83D               !2-BYTE CURRENT DIR SECTOR
CUMREC   EQU 85D               !2-BYTE CUMMULATIVE RECORD CNT (MTSCAN)
LSTDIR   EQU 87D               !2-BYTE LAST SECTOR OF DIRECTORY
SECTDD   EQU 89D               !(2 BYTE SECTOR VALUE (BINARY))
RWFLG    EQU 91D               !(1 BYTE READ/WRITE FLAG)
!                               VRFLAG - VERIFY # OF SECTORS
CCRTEM   EQU 92D               !(1 BYTE TEMPORAYR CCR IMAGE)
HEADCT   EQU 92D               ! # OF HEADS ON DRIVE
ACTMSU   EQU 93D               !4-BYTE ACTIVE MSUS
ACTMS2   EQU 94D               !2nd byte of ACTMSU
PARAMS   EQU 97D               !2-BYTE PARAMETER TEMP
PARAM2   EQU 99D               !2-BYTE PARAMETER TEMP
!-----------------------------------------------------
CPYSIZ   EQU 101D              !# SECTORS TO COPY
SRCORG   EQU 103D              !SOURCE FILE ORIGIN
DSTORG   EQU 105D              !DESTINATION FILE ORIGIN
DENTD    EQU 107D              !DEST FILE DIR.ENTRY#
DADDD    EQU 108D              !DEST FILE DIR.SECTOR#
DENTS    EQU 110D              !SRCE FILE DIR.ENTRY#
DADDS    EQU 111D              !SRCE FILE DIR.SECTOR#
SRCMSU   EQU 113D              !SOURCE FILE MSUS
DSTMSU   EQU 117D              !DEST FILE MSUS-4byte
!SRCTYP EQU 121D          ! SOURCE FILE TYPE
!Total bytes used so far: 121d
!********************************************
MSLOW    EQU 123D
DELAYB   EQU 123D              ! MSLOW HOOK
DELAY+   EQU 125D              !   ""  ""
PPCNT    EQU 127D              !   ""  ""
SCOUNT   EQU 131D              !   ""  ""
CCOUNT   EQU 132D              ! EDTOTL
UCOUNT   EQU 133D              ! ""  ""
TOIDFG   EQU 134D              ! EDVOL#
RTHEAD   EQU 135D              ! EDDIR#
RTWIND   EQU 136D              ! EDDIR2
SPAR#    EQU 137D
SEC##    EQU 138D              ! EDSIZE
RFMTFG   EQU 140D              ! SAVSEC
ERRRAM   EQU 141D
OCTER#   EQU 144D
FORM##   EQU 149D              ! P/SFLG
!********************************************
!
! STEP 2: OBTAIN RAM
!
!****    LDMD R#,=FWUSER        !STEAL RAM
!***     STMD R#,=MSBASE        !RAM BASE ADDRESS
!**      STM R#,R14             !MSBASE
!*       ADM R#,=150D,0         !RESERVE NEC SPACE
!**      STMD R#,=FWUSER        !RESET RAM LIMIT
!***     JSB =ROMJSB
!****    DEF SCRAT+             ! MOVE & SET PTRS
!*****   BYT 0
!*******************************************
! NEW STEP 2: FIND COMPANION ROM
!
         LDM R24,=ROMTAB       ! ADDRESS OF ROM TABLE

FNDROM   BSZ 0
         POMD R14,+R24         ! POP ROM NUMBER
         JNZ TSTROM            ! JIF NOT END OF TABLE
         JSB =MSERR+  
         BYT 21D               ! ROM MISSING
TSTROM   BSZ 0
         CMB R#,=MSROM2        ! COMPANION ROM?
         JNZ FNDROM            ! JIF NO
         LDMD R#,=MSBASE       ! LOAD RAM BASE
!LOC!         LOC 74146
!
!
!
! SET TIME-OUT DELAY FOR LOW-LEVEL

         LDBD R76,=ISRHOK      ! LOAD A RTN

COMN-    JSB =ISRHOK  
         JSB =INIT14           !SCRAT+ KILLS R14
!
! STEP 1:
!          IF (NO OTHER ROMS PRESENT) THEN
!                       ESTABLISH ISR HOOK
!                       CLEAR IOBITS AND ERRSC
!                       RESET IOPS
!          ESTABLISH ISR HOOK
!
         CMB R76,=236          !SEE IF IT'S STILL A RETURN
         JNZ DONOTR            !   IF RTN THEN DON'T RESET
         CLM R46
         STMD R46,=IOBITS      !CLEAR IOBITS AND ERRSC
         JSB =IOPRST           !RESET IOPS
DONOTR   BSZ 0
!
! SET THE INITIAL MSUS (SEARCH FOR A DISC CONTROLLER)
         JSB =VOL2AD  
RSR.A.   BSZ 0
!
!***************************************
!  This return address is used by VOL2AD
!  in a manne specific to this location
!  DO NOT use VOL2AD for initialization any other
!  place except here!
!*********************************************
!
! SET DMSUS ON RAM
!
         JSB =SETMSU  
         STMD R44,X14,DEFMSU  

!
         RTN 
!----------------------------------------
NOTPAU   BSZ 0
!
! IF (NO IO ROM) THEN ESTABLISH ISR HOOK
!                     RESET IOPS
!
!   SCAN ROMTAB FOR ROM 300
!
         JSB =ININIT  
         LDM R24,=ROMTAB  

         LDB R76,=236          !FORCE HOOK,RESET
TABSCN   BSZ 0
         POMD R30,+R24         !POP TABLE ENTRY
         JZR COMN-             !END OF TABLR IF 0 ENTRY
         CMB R30,=IOROM#       !IOP ROM NUMBER
         JNZ TABSCN            !EXIT SCAN IF IOROM
         CLB R76
!  END OF SCAN LOOP
RSETC    BSZ 0
! AND RETURN THROUGH COMMON AREA
         JMP COMN-   
!-----------------------------------------------------
IOPRST   BSZ 0
!
!  RESET IOPS
!
         LDB R30,=200
         STBD R#,=GINTDS       !GLOBAL INTERRUPT DISABLE
         LDM R26,=120,377      !CCR BASE

RSLOOP   BSZ 0
         STBD R30,R26          !WRITE RESET TO CCR
!  HOLD FOR > 7 MICSEC
         LDB R31,=10
WLOP-+   BSZ 0
         DCB R#
         JNZ WLOP-+  
! NOW RELEASE RESET LINE
         PUBD R#,+R26
         ICM R26
         CMB R26,=140
         JNC RSLOOP  
! AND ENABLE THE RESET IOP TO INTERRUPT
         JSB =RE--EN           !ENABLE IO INT, AND GLOBAL
! NOW WAIT FOR IOPS TO INTERRUPT
WAIT20   LDB R31,=20
         JSB =CNTRTR           !WAIT 20 RETRACES (>250 MILLSEC)
! AND RETURN
         RTN 
!--------------------------------------------
ISRHOK   BSZ 0                 ! establish in rom2!
!
! ESTABLISH ISR HOOK
!
!        STBD R41,=GINTDS       !DISABLE INTERRUPTS
!        BYT 251                !LDM R41,=
!        SAD
!        STBD R#,=GINTDS
!        JSB =ROMJSB
!        STMD R#,=IRQ20         !SET FIRST SEVEN BYTES OF
!                       !INTERRUPT VECTOR
!        DRP R40
!        BYT 251                !LDM R#,=
!        DEF ISR2
!        VAL MSROM2
!ISR2     DAD 77530
!        STBD R#,=GINTEN
!        PAD
!        RTN
!        STMD R#,=IRQ20+
!IRQ20+   DAD 102477
!************
!  LOAD IOP ERROR REPORT CODE IN RAM
!        LDM R43,=316           !LOAD JSB =ERROR ...
!        DEF ERROR
!        BYT 0,236
!        STMD R#,X14,ERRRAM
!
!*************
!        STBD R#,=GINTEN
         RTN 
!------------------------------------------------
! TAPFIX.MASROM
TAPFIX   BSZ 0
         STMD R#,X#,DEFMSU     ! RESTORE ACTIVE MSUS
         JSB =TXIT             ! TURN OFF TAPE, ON CRT
         RTN 
!ASTORE"SETHLI.MASROM"
SETHLI   BSZ 0
!        DRP !71
         CLB R#                ! CLEAR NO HEAD MOVES
         CLB R52               ! SET FULL PROTOCAL
         LDB R74,=10           ! RETRY COUNT
         RTN 
! ASTORE"MKROOM.MASROM"
MKROOM   BSZ 0                 ! MAKES ROOM IN HLFMT FOR
         STB R43,R50           ! HOOK ARP FLAG
         STB R44,R51
         DRP R37               ! FOR TEST AFTER RTN
         RTN 
COMHED   BSZ 0
         CLB R46
         LDBD R47,X14,HEADCT  

TRAC+    BSZ 0
         ICB R57
         SBB R25,R47
         JNC HDRTN   
         JNZ TRAC+   
HDRTN    BSZ 0
         RTN 
! MASSRUN11.MASROM
!LOC!         LOC 74360
!****************************************************
!********                                    ********
!********                                    ********
!********    LOW-LEVEL DISC DRIVERS          ********
!********                                    ********
!****************************************************
!
! THESE DRIVERS PROVIDE A RELATIVELY ERROR-RESISTANT
!   CONCEPTUALLY SIMPLE VIEW OF THE DISC AS A
!   SEQUENCE OF SECTORS WHICH CAN BE RANDOMLY, OR
!   SEQUENTIALLY ACCESSED.  THERE IS A HIGHLY
!   RESTRICTED SET OF ENTRY POINTS TO THIS SECTION.
!   THE ENTRY POINTS ARE:
!          TOID             VOL2AD
!          GETSEC           PUTSEC
!          GETBUF           PUTBUF
!          GETSE+           PUTSE+
!          HLSEEK     and   HLFMT.
!
!  LOW LEVEL DRIVERS ARE DIVIDED INTO THREE GROUPS:
!    GROUP 1 IMPLEMENT THE CAPRICORN TO
!    IO PROCESSOR PROTOCOL.  ROUTINES IN THIS
!     GROUP ARE:     CMDOUT  Command out
!                    CMDHS   Command Handshake
!                    DATOUT  Data out
!                    DATAIN  Data in
!                    BSTOUT  Burst out
!                    BSTIN   Burst in
!                    OPSU#1  Optimization # 1
!           and ISR the Interrupt service routine.
!           Additionally, there are several loop
!           routines. Every loop in the low-level
!           has a time-out count to prevent low-
!           level hangs.
!              Loop 4 (BUSY check) is in DATAIN,
!           and loop 6 (PPOLL check) is in PPOLL.
!           The other loops are in the following
!           routines*
!                    OBFCK   Check OBF and BUSY
!                    OCK     Check OBF
!                    ICK     Check IBF
!               and  SFLGCK  Check SFLG.
!
!    GROUP 2  DEALS WITH HPIB SEQUENCES USED TO
!     DRIVE THE DISC HARDWARE. THESE ROUTINES SEND
!     HPIB SEQUENCES THROUGH THE IOP, USING
!     THE 1 ROUTINES.  ROUTINES IN THIS GROUP
!     ARE:     LLINIT   Establish register env
!              EX__IT   Restore IOP EOL count
!              FORM.T   Format a disk
!              DSJ      Device specified jump
!              PP       Parallel poll
!              RDBUFF   Read-buffered
!              WRBUFF   Write-buffered.
!              TO_ID    Time-out identify.
!              STATUS   Get 2 status words.
!              SNDMTA   (& SNDMLA) Send my talk addr
!              FORMAT   Format and verify disc
!              HLTIOP   (& SRTIOP) Suspend IOPs
!              VERIFY   Check medium's integrity
!              INITZE   Mark defective track
!              REQDA    Request Disc address
!              LLPARI   Add parity to command
!        and   UNTALI   send UNTALK and UNLISTEN
!
!    THE MASS STORAGE ROM DEALS WITH PROTOCOL
!    ERRORS OVER THE HPIB IN AN OCCASIONALLY RADICAL
!    MANNER.   WHEN COMMUNICATION WITH AN IOP IS
!    BROKEN (TYPICALLY DUE TO AN INCORRECT CONTROLLER
!    ADDRESS), THEN THE MS ROM RESETS THE IOP TO
!    REGAIN CONTROL.  THIS CAUSES THE IOP TO RE-
!    ESTABLISH ITS POWER -ON STATE.  INFORMATION ABOUT
!    THE HP-IB CARD AND IO PROCESSOR PROTOCOL IS
!    FOUND IN THE "HP-IB CARD ERS"  (DAVE SWEETSER DCD).
!         ALL NORMAL HP-IB SEQUENCES ARE TERMINATED WITH
!    UNTALK AND UNLISTEN.  AT POWER-ON OF THE
!    CAPRICORN THE ROUTINE VOL2AD IS CALLED TO DETERMINE
!    WHETHER A DISC IS ON LINE.  IF ONE IS AT POWER-ON
!    THEN ITS ADDRESS IS SET AS THE DEFAULT MSUS.  IF
!    SEVERAL DISC S ARE ON-LINE THEN THE CONTROLLER
!    WITH TE LOWEST S.C. AND THEN LOWEST C.A. BECOMES
!    THE DEFAULT CONTROLLER AT POWER-ON.
!    IF THIS HAPPENS THEN THE MASS STORAGE ROM SENDS
!
!
!    GROUP 3 ARE HIGH-LEVEL ENTRY POINTS.  THESE
!     ARE ENTERED FROM THE REST OF THE MSROM TO
!     PERFORM DISC OPERATIONS. PARAMETER PASSING
!     TECHNIQUES FOR EACH ROUTINE WILL BE DISCUSSED
!     IMMEDIATELY PRIOR TO EACH. GROUP 3 CONTAINS:
!         TOID    Time-out identify with LLINIT and
!                 EX__IT
!         HLSEEK  High-level seek to conceptual
!                 sector (in R30)
!         HLFMT   High-level Format a disk (staggar
!                 in R30)
!         GETSEC  Get sector (256 bytes) from disk,
!                 Conceptual target sector in R32,
!                 data address in R30.
!         PUTSEC  Put sector (see GETSEC)
!         GETSE+  Get sector without seek (data
!                 address in R30).  Used with auto-
!                 increment for multi-sector bursts.
!         PUTSE+  Put sector without seek.
!         GETBUF  Read sector into tape buffer
!         PUTBUF  Write sector from tape buffer
!         VOL2AD  Translate Volume label into
!                 hardware msus (involves medium
!                 search).
!         HLINIT  Record entry point and incoming
!                 parameters for future retry.
!         LLERR   Low-level error recovery. 10 simple
!                 retries, then head move-retry.
!         HDMOVE  Move disc head one track in (then
!                 out) and back.
!
!
! ALL ROUTINES IN BOTH GROUPS ASSUME
! A FAIRLY RIGID REGISTER ENVIRONMENT, I.E.:
!    E       ...  SRT/HLTIOP FLAG
!    R0,1    ...  TIME-OUT COUNT
!    R14,15  ...  MSROM'S RAM BASE ADDR.
!    R20,21  ...  RETRY ADDRESS
!    R22     ...  DEVICE
!    R23     ...  UNIT
!    R24,25  ...  (WORKING REG-PAIR)
!    R26,27  ...  CCR ADDRESS
!    R30,31  ...  TARGET SECTOR (conceptual)
!                 or  ADDRESS (for R/W SECTOR)
!                 or  STAGGAR (for FORMAT)
!    R32     ...  USED TO STORE CCR IMAGE
!    R33     ...  REFORMAT FLAG (ALSO USED BY VOL2AD
!                 AND AS INPUT PARAMETER (GET+PUTBUF))
!    R34,35  ...  TIME-OUT COUNT
!    R36     ...  RD-WR TEMP FLAG
!    R37     ...  TIME-OUT IDENTIFY RSLT FLAG
!    R40     ...  TYPE OF CURRENT DISC
!    R42,47  ...  (USED FOR DATA MOVEMENT)
!    R45     ...  FORMAT TYPE
!    R46     ...  (USED FOR COMMAND BYTE)
!    R50,51  ...  DISC PARAMETERS (CYL & SEC/TRACK)
!    R52     ...  FULL/SHORT PROTOCOL FLAG
!    R54     ...  RETRY COUNT
!    R55     ...  (USED FOR NEW CCR)
!    R56     ...  TEMP IN FORMAT
!                 IOBITS IN HLT/SRTIOP
!    R57     ...  (USED TO TELL NUMBER
!                 OF BYTES TO SEND IOP)
!    R60     ...  DISC TYPE
!    R61     ...  VOL2AD S.C. COUNT
!    R62     ...  VOL2AD C.A. COUNT
!    R63     ...  VOL2AD UNIT COUNT
!    R64     ...  # OF SPARE TRACKS LEFT
!    R65     ...  SRTIOP S.C. COUNT
!    R66,67  ...  DATA TO BE TRANSFERRED ADDRESS
!    R71     ...  RETRY HEAD MOVE STATUS
!    R72,73  ...  ERROR RECOVERY
!    R74     ...  RETRY COUNT
!    R75     ...  TEMP CCR
!    R76,77  ...  IO BUFFER ADDRESS
!    R72-77  ...  TEMP USE IN VOL2AD (LLINIT FOLLOWING)
!
OUT.CO   EQU 260
OUT.DO   EQU 240
OUT.S4   EQU 104
OUT.S5   EQU 105
OUT.S6   EQU 106
OUT.EN   EQU 20
!**********************************************
!**                                         ***
!**    IO PROCESSOR PROTOCOL DRIVERS        ***
!**                                         ***
!**********************************************
!**
!**
!**  Communication with the IOP is synchronized
!** with a pair of dedicated registers (memory
!** locations).  One is an I/O buffer, and the
!** second is a control register.  The control
!** register is referred to as the Calculator-
!** Control-Register (CCR) on write operations,
!** and the Processor-Status-Register (PSR) on
!** read.  The important conceptual bitys in the
!** control register are:
!**
!**  ----------------------------------------
!**  ! reset ! d ! d ! d ! d ! CED ! COM ! INT !
!**  -------------------------------------------
!**  CCR
!**      7     6   5   4   3    2     1     0
!**  PSR
!**  ---------------------------------------------
!**  ! OBF ! d ! FD ! SFLG ! PACK ! PED ! BUSY ! IBF !
!**  -------------------------------------------------
!**     7    6    5     4      3     2      1     0
!**
! FIRST THE GROUP 1 ROUTINES
!
CMDOUT   BSZ 0
! This routine sends one command byte to the IOP.
! FIRST SEND COMMAND
         JSB =CMDHS   
! NOW LOOP UNTIL BUSY=OBF=0
!NOTE: This routine does no interrupt control I O.
!  IO protocol dealing with interrupts
! is  not implemented.
! If the IOP is busy, then the MS ROM waits.
!       FALL THROUGH!!!
! THE Utility routine OBFCK waits for BUSY + OBF
! (bits 1 and 7) both to become 0.
OBFCK    BSZ 0
         STM R0,R34
OBFLOP   BSZ 0
         JSB =OCKLOP  
         LRB R#                !BUSY IS NOW BIT 0
         JOD OBFLOP            ! LOOP IF BUSY=1
         RTN                   !OTHERWISE RETURN
CNTERR   BSZ 0
! "OUT-TO-LUNCH" IOP
!
!   1. RESET OFFENDING CARD (HOLD 50MICSECS)
!   2. TIME-OUT FOR IOP TO LOGIN INT
!+
!  NOTE: ASSUME R26 HAS CCR ADDR FOR BAD CARD
!
         LDB R46,=200          !10 000 000 PATTERN (RESET)
         STBD R#,R26           !PUT IN CCR
         LDB R#,=100
LOPW+0   DCB R#
         JNZ LOPW+0            !WAIT LOOP HOLDING RESET
         STBD R#,R#            !RELEASE RESET LINE
! NOW WAIT FOR IOP TO INTERRUPT AND LOGIN
         JSB =WAIT20  
! RESET EOL COUNT TO 2  (DEFAULT)
         LDB R#,=2
         STBD R#,X14,SPAR#   

! IF IDENTIFY THEN RETURN
!             ELSE ERROR
! THIS ROUTINE EXAMINES THE R.A. STACK (R6)
! LOOKING FOR A R.A. IN IDENTIFY.  IF FOUND THEN
! THIS ROUTINE RETURNS TO THAT ADDRESS, ELSE
! IT REPORTS A DISC-TIME-OUT ERROR.
         LDM R46,=RTNADD       !R.A. FROM IDENTIFY

         LDM R56,=RTNAD2       !R.A. FROM IDENTIFY

         STM R6,R72
         LDB R45,=5
LO.+P    POMD R24,-R72
         CMM R24,R46
         JZR IDRTN   
         CMM R24,R56
         JZR IDRTN   
         DCB R45
         JNZ LO.+P   
!*******ERROR !!!!!!!!!!!
         JSB =MSERR   
         BYT 31D               !"TIME-OUT"
!---------------------------
IDRTN    BSZ 0                 ! RETURN TO IDENTIFY
!                  FIX R6
         LDM R6,R72
O....K   BSZ 0
         PUMD R46,+R6
         ICB R37
!                     !TIME-OUT (FALSE)
         RTN                   ! AND USE IT
!---------------------------------------------
!---------------------------------------------
!
! THE ROUTINE OCK CHECKS OBF WAITING FOR THE
! OUTPUT BUFFER TO EMPTY (OBF=0)
OCK      BSZ 0
         STM R0,R34
OCKLOP   BSZ 0
         DCM R34               !DECREMENT COUNT
         JZR CNTERR            !IF COUNT EXPIRED THEN ERROR
         LDBD R75,R26          !READ PSR
         JNG OCKLOP            !LOOP IF OBF=1
         RTN 
!---------------------------------------------
!---------------------------------------------
!
! ROUTINE ICK WAITS FOR THE INPUT BUFFER TO
! FILL (I.E. FOR IBF = 1)
ICK      BSZ 0
         STM R0,R34
ICKLOP   BSZ 0
         DCM R34               !DECREMENT TIME-OUT COUNT
         JZR CNTERR            !IF COUNT EXPIRED THEN ERROR
         LDBD R75,R26          !READ PSR
         JEV ICKLOP            !LOOP IF IBF = 0
         RTN 
!----------------------------------------------
!----------------------------------------------
CMDHS    BSZ 0
! This routine sends one command byte from R46 to
! the IOP.
! MAKE SURE THE IOP IS NOT BUSY AND OBF IS EMPTY
         JSB =OBFCK   
! SET COM=1 (I.E. IS COMMAND BYTE IN OBF)
         LDB R#,=2             !BINARY 00000010
         STBD R#,R#            !STORE TO CCR
! NOW SEND COMMAND BYTE
         STBD R46,R76
         RTN 
DATOU+   BSZ 0
!  Sends one command byte to the IOP (from R46)
! and follows it with one or more data bytes
! (len in R57) This routine is used to implement
! data transfer IOP protocols, where the IOP is
! to transfer      bytes to the HPIB        .
! This routine is also used in wait for data
! commands dealing only with IOP communication.
!     R24,25 are used to store DATA BUFFER add.
! FIRST SEND THE COMMAND BYTE
         JSB =CMDHS   
! NOW LOOP UNTIL OBF=0 (OUTPUT BUFFER IS EMPTY)
         JSB =OCK              !CHECK OBF
! NOW SET COM=CED=0
         CLB R#
         STBD R#,R#            !STORE TO CCR
         LDM R24,R66
         RTN 
!************************************
DATOUT   BSZ 0
         JSB =DATOU+  
! FETCH DATA BYTE
LOP-04   BSZ 0
         POBD R46,+R24         !POP DATA BYTE
         DCB R57               !DECREMENT COUNTER
         JZR DONOUT            !IF COUNTER=0 THEN DONE
! WAIT FOR OBF=0
         JSB =OCK              !CHECK OBFBF=1
! WRITE DATA TO OUTPUT BUFFER
         STBD R46,R76          !STORE DATA TO OBUFFER
         JMP LOP-04            !GET NEXT DATA BYTE
! WAIT FOR OBF=0
DONOUT   BSZ 0
         JSB =OCK              !TIME-OUT OBF CHECK
! SET CED = 1 (CED IS BIT 2)
         LDB R#,=4             !00 000 100
         STBD R#,R#            !STORE TO CCR
! WRITE DATA
         STBD R46,R76          !STORE TO OBUFFER
! WAIT FOR OBF=BUSY=0
         JSB =OBFCK   
! RESET CED TO 0
OPLB++   BSZ 0
         CLB R57
         STBD R#,R26
         RTN 
!*********************************
!   PATH TO ERROR RECOVERY
ERR--R   BSZ 0
         GTO CNTERR  

DATAIN   BSZ 0
!  Sends one command byte to IOP
!  then accepts data bytes
!  and stores them in the RAM data buffer.
!  Assumes R57 has
!  expected number of bytes.
!     Uses R24,25 as temp DATA BUFFER address area
! FIRST SEND THE  COMMAND BYTE
         JSB =DATOU+  
! WAIT FOR IO BUFFER TO FILL
LOP-10   BSZ 0
         JSB =ICK              !TIME-OUT IBF CHECKBIT 0=0
! CHECK PED (PROCESSOR END DATA = BIT 2)
         LDBD R#,R#            !READ CCR
         LRB R#                !CCR BIT2 >>> BIT1
         LRB R#                !CCR BIT1 >>> BIT0
         JOD DONIN             !PED=1 IMPLIES DONE
! READ IB AND CHECK IF LAST BYTE DESIRED
         LDBD R46,R76          !READ IBUFFER
         PUBD R46,+R24         !PUSH ON DATA STACK
         DCB R57               !DECREMENT COUNTER
         JZR STTCED            !IF COUNT=0 THEN DONE
! FAKE WRITE TO OBUFFER
         STBD R46,R76          !STORE TO OBUFFER
         JMP LOP-10            !LOOP TO GET NEXT BYTE
DONIN    BSZ 0
! READ IBUFFER AND STORE TO DATA BUFFER
         LDBD R46,R76          ! READ OBUFFER
         PUBD R46,+R24         ! STORE TO DATA BUFFER
         DCB R57               ! DECREMENT COUNT
         JMP PT..1.            ! FINISH PROTOCOL
! SET CED = 1
STTCED   BSZ 0
         LDB R#,=4
         STBD R#,R26           ! STORE TO CCR
! NOW WAIT FOR BUSY=0
PT..1.   BSZ 0
         LDM R34,R0            !     LOAD TIME-OUT COUNT
LOP-11   LDBD R75,R26          ! READ PSR
         DCM R34               ! DECREMENT COUNT
         JZR ERR--R            ! IF STILL > 0 THEN GOON
         LRB R75               ! BUSY=BIT1 >>> BIT0
         JOD LOP-11            ! LOOP IF BUSY = 1
! RESET CED TO 0
!        CLB R#
!        STBD R#,R#     STORE TO CCR
! RESET DATA BUFFER ADDRESS (R66)
         JMP OPLB++  
! This routine sends one command byte,
! then enters an
! infinite burst-in loop.  CAPRICORN relies on
! an interrupt from the IOP
! (after one sector is transferred) to
! escape the Burst-in loop.
! SEND COMMAND BYTE
BSTIN-   BSZ 0
         JSB =CMDOUT  
! HALT NON-BURST IOPS TO PREVENT STRAY INTERRUPTS
         JSB =HLTIOP  
! NOW ENTER INFINITE (19 CYCLE) BURST-IN LOOP
         DRP R46
         ARP R30
         RTN 
BSTIN    BSZ 0
         JSB =BSTIN-  
! DO DUMMY WRITE TO IOBUFFER TO START BURST
         STBI R#,=INCRA        !  DUMMY WRITER
LOP-23   LDBI R#,=INCRA        !READ IBUFFER
         PUBD R#,+R#           !PUSH DATA
         JMP LOP-23            !LOOP
! THERE IS NO RETURN FROM THIS ROUTINE
! This routine sends one command byte,
! then bursts out one sector
! (256 bytes) to the disk.  Again, the burst-out
! loop is infinite and will be escaped by an IOP
! interrupt.
! FIRST SEND ONE COMMAND BYTE
BSTOUT   BSZ 0
         JSB =BSTIN-  
!********************** ENTER BURST OUT LOOP
LOP-21   POBD R#,+R#           !       POP BYTE
         STBI R#,=INCRA        ! STORE TO STRING
         JMP LOP-21            ! LOOP
! THIS ROUTINE DOES NOT HAVE A RETURN
! THIS SUBROUTINE ADDS THE UNIT (R22) TO
! AN HPIB PRIMARY IN R46.  R46 THEN HAS PARITY
! ADDED. PRIMARY AND SECONDARY IN R46-7 ARE
! PLACED IN THE DATA BUFFER, THEN SENT OVER
! THE HPIB WITH ATN SET TO 1.
OPSU#1   BSZ 0
         ADB R46,R22
         JSB =LLPARI           !ADD PARITY
OPSU#2   BSZ 0
         STMD R46,R66          !PUT IN DATA BUFFER
         LDB R46,=OUT.CO       ! SEND WITH ATN=1
D__OUT   LDB R57,=2            !SEND TWO BYTES
         JSB =DATOUT           !SEND
         RTN 
!******************************************
S2#3     BSZ 0
         LDB R57,=2
         JSB =OPSU#3  
!*******************************************
UNTALI   BSZ 0
         LDM R46,=137,77

         JSB =OPSU#2  
         RTN 
! The Interrupt Service Routine should be
! entered ONLY to complete BURST mode and
! LOGIN operations, and IOP error report.
! Any other entry
! context results in an error and abort.
! FIRST READ THE SC FROM 177500
!
!  ISR ROUTINE NOW HANDLED BY ROM2
!
!  NO ONE BUT THE MASS STORAGE ROM
!  SHOULD HAVE BEEN ENTERING HERE.
! ISR BSZ 0
!
TIMWST   DAD 36561
! ASTORE"MASSPART4.MASROM"
MOVTST   BSZ 0
         LDMD R46,=CURLOC      ! GET CUR ASSSIGN BUF

         CLM R24
         LDBD R24,X46,A.PPTR   ! GET PHYS PTR VAL

         ADM R24,R22           ! PHYS PTR + DATA LEN
         CMM R24,=0,1          ! OVF PHYS RECORD?
         JCY MOVRTN            ! JIF YES
         LDMD R32,X46,A.#B/R   ! BYTES PER LOG REC

         LDMD R26,X46,A.LPTR   ! LOG REC PTR

         ADM R26,R22           ! LOG + DATA LEN
         CMM R26,R32           ! OVF LOG RECORD
         JCY MOVRTN            ! JIF YES
         STMD R26,X46,A.LPTR   ! UPDATE LOG PTR

         CLM R26
         LDBD R26,X46,A.PPTR   ! PHYS PTR (REL)
         ADM R26,R46           ! MAKE IT ABSOLUTE
         ADM R26,=A.DATA  
         STBD R24,X46,A.PPTR   ! UPDATE REL PHYS PTR

MOVRTN   RTN 
! VLHOOK.MASROM
VLHOOK   BSZ 0                 ! CALLS HOOK FOR VOL2AD
         ARP R26
         JSB =HOOK             ! DOES SOMEONE WANT ME?
         LDB R61,=377          ! NEEDED FOR VOL2AD
         RTN 
! RE--EN.MASROM
!LOC!         LOC 75077
RE--EN   BSZ 0
         STBD R#,=INTRSC  
         STBD R#,=GINTEN  
         RTN 
!GETPUT.MASROM
! THE SET UP FOR GETBUF/SEC,PUTBUF/SEC ROUTINES
GSECST   BSZ 0
         CLB R36
         JMP PG+     
PBUFST   BSZ 0
         LDB R36,=1
         JMP BUFSAM  
GBUFST   BSZ 0
         CLB R36
BUFSAM   BSZ 0
         LDM R30,=RECBUF  

PG+      BSZ 0
         SBM R6,=2,0           ! DON'T WANT TO RETURN TO CALLER

         GTO PGCOM+            ! GO TO COMMON ROUTINE

!-----------------------------------------------------------------
GSE+ST   BSZ 0
         CLB R36
         JMP GE+-    
PBU+ST   BSZ 0
         LDB R36,=1
         JMP BUFSM2  
GBU+ST   BSZ 0
         CLB R36
BUFSM2   BSZ 0
         LDM R30,=RECBUF  

GE+-     BSZ 0
         SBM R6,=2,0

         GTO GETP+-            ! GOTO COMMON ROUTINE

!-----------------------------------------------------------------
PSECST   BSZ 0
         ARP R20
         JMP R36+    
PSE+ST   BSZ 0
         ARP R22               ! ARP = 18D
R36+     BSZ 0
         LDB R36,=1
         RTN 
! VOL2ADFIX1.MASROM
CONINC   BSZ 0
         CLB R52               ! FLAG LONG PROTOCAL
         ICB R62               ! INCREMENT COUNT
         RTN 
!--------------------------------------------------------
CKANSW   BSZ 0
         LDB R57,=1            ! COMMON ROUTINE TO
         JSB =DATAIN           ! ASK QUESTION OF CARD
         LDBD R46,R66          ! GET ANSWER
         RTN 
! TOIDHK.MASROM
LLUN     BSZ 0
         ARP R24              ! SET UP FOR HOOK
         JSB =HOOK             ! CALL HOOK
         JSB =LLINIT  
         JSB =UNTALI  
         RTN 
! ASTORE"MASSRUN11B.MASROM"
!LOC!         LOC 75226
HLTIOP   BSZ 0
!  The routine HLTIOP suspends all IO Processors
!  on line, except the IOP of the active msus.
!  This prevents stray interrupts which would
!  interfere with the burst-transfer procedure.
!  HLTIOP interrupts each non-primary IOP and
!  leaves that IOP in mid-protocol waiting
!  for Capricorn.  The sister routine SRTIOP
!  finishes the protocols begun by HLTIOP and
!  thus releases the non-primary IOPs.
         CLE 
         JSB =DONSRT  
         JMP CO++-+  
SRTIOP   BSZ 0
         CLE 
         ICE 
CO++-+   BSZ 0
!  This routine restarts all except the active
!  SC's IOP.  They are assumed to have been
!  suspended by the routine HLTIOP.  This routine
!  finishes the protocol begun by HLTIOP  and
!  thereby starts those IOPs again.
!  SRTIOP is called after each sector burst, just
!  as HLTIOP is called before each sector burst.
         LDBD R56,=IOBITS      !GET IOP LOGIN VECTOR

!
!  FOR SC = 0 TO 7 DO
!
         LDB R65,=377          !START COUNT AT -1
SRTLOP   ICB R65
         CMB R65,=8D
         JZR DONHSI            !TEST FOR LAST SC
         TSB R56
         JEV SRWIND            !TEST FOR LOGGED-IN IOP
         JSB =SETMSU           !SET ACTIVE MSUS
         CMB R45,R65
         JZR SRWIND            !TEST FOR ACTIVE SC
!
!  IS AN IOP TO RESTART-HALT
!
!  STROBE INT
         LDB R#,R#
         JSB =SETCC-  
! ****   LDB R57,=1
         JSB =INIT57           !init R57 & disable interrupts
! DRP IS SET TO R57
         STBD R#,R26           !PUT A 1 IN CCR
         JEZ CIR.01  
!
!  SMALL WAIT LOOP
         LDB R#,=100
!LOC!         LOC 75304
WA--LP   DCB R#
         JNZ WA--LP  
!
!  RESET INT TO 0
         STBD R#,R#
!
!  WAIT FOR PACK =0
CIR.01   BSZ 0
         LDM R34,R0
PACK=1   BSZ 0
         DCM R34
         JNZ CN--OK  
         GTO CNTERR            !IF TIME-OUT THEN ERROR

CN--OK   BSZ 0
         JMP CN--IN            ! enable interrupts
CN--CT   JEZ CIR.02            ! now back to  reg schedul progrmmng
         JSB =REDPSR           ! read PSR and goto correct loop
! ****   LDBD R47,R26           !READ PSR
! ***    ANM R47,=10
         JZR SRWIND  
         JMP PACK=1  
!LOC!         LOC 75336
CIR.02   BSZ 0
         LDBD R47,R26
         ANM R47,=10
         JZR PACK=1  
!*****   LDBD R46,R76           !TRASH IB
!****    LDB R46,=60
!***     STBD R46,R76           !SEND COMMAND
!**      LDB R#,=2
!*       STBD R#,R26            !RESET INT =0  AND COM=1
         JSB =REDCCR           ! do above in subroutine
         JMP SRWIND            ! now back to reg  schedul progrmmng
CN--IN   BSZ 0
         STBD R#,=GINTEN  
         JMP CN--CT  
!
!   NOW PACK = 0
!
!  DONE WITH THIS IOP, GO ON TO NEXT ONE
!LOC!         LOC 75357
SRWIND   BSZ 0
         LRB R56
         JMP SRTLOP  
!********************
DONHSI   JEZ SETCCR  
!******END OF FOR LOOP
DONSRT   BSZ 0
! DISABLE-REENABLE TIMERS AND KEYBOARD
! INTERRUPTS.
         JEZ CIR.03  
         LDB R55,=2
         JSB =TIMW-+  
         LDB R55,=1
         JMP CIR.04  
CIR.03   LDB R55,=1
         JSB =TIMW-+  
         LDB R55,=2
CIR.04   BSZ 0
         STBD R55,=KEYSTS  

!
!  RESET CCR AND RETURN
SETCCR   BSZ 0
         JSB =SETMSU  
SETCC-   LDM R26,=120,377

         ADB R26,R45
         ADB R26,R45
         LDM R76,R26
         ICM R76
!
         RTN 
!******************************
TIMW-+   BSZ 0
! OPTIMIZATION LOOP DISABLES-ENABLES THE
! FOUR TIMERS
         LDB R73,=3
GO++LP   JSB =TIMWST  
         ADB R55,=100
         DCB R73
         JNZ GO++LP  
         RTN 
!************************
LLPARI   BSZ 0
!  This routine adds parity to R46 (using bit 7).
!  FIRST, COUNT THE ONES IN R46 (MOD 2).
         CLB R57               !NO ONES TO START
         LDB R56,R46           !GET WORKING COPY
LOP-70   JZR DONCNT            !IF WORKING COPY IS = 0
!                      !   THEN DONE COUNT
         JEV DONTCM            !   IF BIT 0 = 0 GOON
         NCB R57               !ADD 1 TO COUNT (MOD 2)
DONTCM   BSZ 0                 !DON'T COMPLEMENT COUNT
         LRB R56               !GET NEXT BIT TO CHECK
         JMP LOP-70  
! NOW ADD UPPER 1 BIT IF ODD PARITY (TO CREATE
! EVEN PARITY IN R46)
DONCNT   BSZ 0
         TSB R57               ! TEST R57 (COUNT OF PARITY)
         JEV DONPAR            ! IF ALREADY EVEN PARITY
!                           THEN DONE
         LDB R#,=200
         ORB R46,R57           !    ELSE SET BIT 7 TO 1
DONPAR   BSZ 0
! AND FINALLY, RETURN
         RTN 
!***********************************************
!**                                          ***
!**   GROUP TWO                              ***
!**      HP-IB drivers                       ***
!**                                          ***
!***********************************************
!**
! Now the group two routines.
! First the utility initilizing routine LLINIT.
! LLINIT creates the reg. state necessary to use
! the rest of the low-level package.
!     LLINIT also initialized the input and output
! conditions of the IOP.  (This is done with:
!        WRITEREG       0,0   (NULL OUTPUT EOL)
!    and set IOP parity to no parity
LLINIT   BSZ 0
         BIN 
! NOW LOAD THE DATA BUFFER BASE ADDRESS
         LDM R66,R14
         ADM R66,=DATAB        !ADD DATA BUFFER OFFSET
! NOW SET THE CCR/PSR ADDRESS
! GET ACTIVE MSUS AND ADD SC TO ADDRESS
! AND THE I/O BUFFER ADDRESS
         JSB =SETCCR  
! SET THIS ADDRESS IN INCRA FOR BURST USE
         STMD R76,=INCRA       !INCRA >> IOBUFFER ADD

! SET THE UNIT AND DEVICE IN R23 AND R22
         STM R46,R22
! GET TIME-OUT COUNT
         LDM R0,=300,10

! TEST FOR LONG OR SHORT INIT
! SHORT PROTOCOL IF IOP STATE HAS ALREADY
! BEEN ESTABLISHED.
         TSB R52
         JNZ NOWRR1  
! WRITE CONTROL TO REG 0 (DDDD 0100) TO SET
!  EVEN PARITY
         CLB R46
         JSB =OPSU#4  
! SET BURST COUNT
         LDM R46,=0,1

         STMD R46,R66
         LDB R46,=231
         JSB =D__OUT  
! POINT TO IOP EOL REG (INTERNAL REG 70OCT)
         LDB R46,=70
         STBD R46,R66
         LDB R46,=346          !WRITE AUX POINTER
         JSB =DATO1   
! READ AND SAVE EOL COUNT AND EOI ENABLE
         LDB R46,=167
         LDB R57,=1
         JSB =DATAIN  
         LDBD R70,R66          !SAVE EOL COUNT
         STBD R70,X14,SPAR#    !SAVE

! WRITE OUR EOL COUNT (0) AND ENABLE EOI
NOWRR1   BSZ 0
         LDB R46,=200
         JSB =WR_EOL           !SEND
         RTN 
!
! FINALLY, RETURN
OUTCM1   STBD R#,R66           ! PUT IN DATA BUFFER
         LDB R#,=OUT.CO        ! SEND WITH ATN=1
DATO1    LDB R57,=1
DATO     JSB =DATOUT  
         RTN 
!*************
OPSU#4   BSZ 0
         STBD R46,R66
         LDB R46,=200
         JMP DATO1   
! The first group two routine is FORMAT,
! which prepares a diskette for use
! (detecting bad tracks and renumbering).
! The structure of this command is:
!          1. send MY TALK ADDRESS and
!                  UNLISTEN commands
!          2. send primary and secondary
!          3. send staggar,unit,   ,   .
!          4. send UNLISTEN  + UNTALK
!
FORM.T   BSZ 0
! SEND MY TALK ADDRESS
         JSB =SNDMTA           !SEND COMMAND
! NOW SEND PRIMARY AND SECONDARY
         LDM R46,=40,154       !PRIM AND SEC LISTEN

         JSB =OPSU#1  
! SEND DATA WITH ATN=0 (USING DATA OUT (HEX A0))
         LDB R43,=30
         LDB R47,=333
! SET UNIT AND STAGGAR
!   UNIT IS BYTE 2 AND STAGGER IS BYTE 4
         LDB R44,R23           !LOAD UNIT
!  GET STAGGAR FROM R30
         LDBD R46,X14,PARAMS  

! R45 IS THE FORMAT TYPE (202 ... HP OVERRIDE OLD)
         STMD R43,R66          !STORE TO DATA BUFFER
! REG 47 = 0 IS THE DATA TO FILL EACH SECTOR BYTE
         LDB R57,=5            !SEND 5 DATA BYTES
!*********************************************
!*****   JSB =OPSU#3                   *******
!***** WAIT FOR FORMAT TO COMPLETE     *******
!*****   JMP WAI++T                    *******
!*********************************************
!***    LONGER WAIT FOR 10 MB DISC       *****
         JSB =FORMFX  
         JMP WAI++_  
!*********************************************
!**
OPSU#3   BSZ 0
         LDB R46,=OUT.DO  
         JMP DATO    
VERIFT   BSZ 0
! THIS ROUTINE PERFORMS A VERIFY TO
! THE DESIRED DISC.
! THE VERIFY BEGINS AT THE CURRENT TARGET ADDRESS.
!
! SEND PRIMARY AND SECONDARY LISTEN AND CAPR T.A
         JSB =S40350  
! NOW SEND OPCODE (7) AND UNIT AND SECTOR COUNT
         LDM R44,=7,0,177,000  !LARGE SECTOR COUNT

!*****************************************************
!*****   LDB R45,R23            !UNIT        *********
!*****                                       *********
!*****  FIX FOR 8 INCH FLOPPY. IT DOESN'T    *********
!***** LIKE # OF SECTORS > 177,177. RATS!!!  *********
!*****
         JSB =VERSEC           ! GET UNIT & VER LENGTH
!
         STMD R44,R66          !PUT IN DATA BUFFER
         LDB R57,=4            !SEND 4 BYTES
         JSB =OPSU#3           !SEND
! AND WAIT
         LDM R46,=120,0        ! WAIT 5 MIN (HARD DISC)

         JMP WAI++_  
WAI++T   BSZ 0
         LDM R46,=5,0

WAI++_   BSZ 0
         JSB =PPOLL   
! AND FINISH
         JSB =UNTALI  
         RTN 
INITZE   BSZ 0
! THIS ROUTINE INITIALIZES THE CURRENT TARGET SECTOR
! SETTING D BIT.  ALL SECTORS ON CURRENT TRACK ARE
!  MARKED DEFECTIVE.
!
! SEND PR AND SEC LISTEN AND CAPR T.A.
         JSB =S40350  
! SEND OPCODE (13 + D >>> 53)
! AND UNIT
         LDB R47,R23           !UNIT
         LDB R46,=53           !OPCODE
         STMD R46,R66          !PUT IN DATA BUFFER
! AND FINISH INITIALIZE REQUEST
         JSB =SD&POL  
! NOW SEND FAKE DATA
         LDM R46,=40,140

         JSB =S40+    
! SEND FAKE DATA
         LDB R57,=1
         JSB =OPSU#3           !SEND
! AND WAIT
         JSB =PPOLL   
! FINALLY, COMPLETE PROTOCOL
         JSB =UNTALI  
         RTN 
! ASTORE"MASSRUN12.MASROM"
HLFMT    BSZ 0
         ARP R10               ! flag for vector
         JSB =HLINI   
! THIS ROUTINE FORMATS A NEW DISCETTE
! VERIFY AND INITIALIZE ARE USED TO MARK
! BAD TRACKS TO BE MADE INVISIBLE.
         JSB =TOID    
!****    STB R44,R50              !SAVE # CYLINDERS
!**      TSB R37
!
         JSB =MKROOM           ! makes room for arp flag
         TSB R#
         JNZ OO_-P*  
         JSB =L.D.S            !REMOVE POSSIBLE HOLDOFF
         LDB R45,=202
         JSB =FORM.T           !FORMAT DISC
         JSB =DSJ              !CHECK RESULT OF FORMAT
         JEV LLOK#2  
         JSB =LLERR   
LLOK#2   BSZ 0
! IDENTIFY AND GET #CYLINDERS AND # SECTORS/TRK
!   SET # SPARES
         LDB R64,=4
! SET REFORMAT FLAG TO FALSE
FMTLOP   BSZ 0
         CLB R33
! SEEK TO SECTOR 0
         CLM R30
         JSB =SEEK    
         JZR OK.1A   
         GTO BADDDD  

OK.1A    BSZ 0
! NOW ENTER VERIFY LOOP
VFYL.P   BSZ 0
         JSB =VERIFT  
! AND REQUEST DISC ADDRESS
         JSB =REQDA   
! COMPARE TO TARGET LAST ADDRESS
!*****   SBB R45,R50
         JSB =CMPTAR           ! need to compare two bytes
         JNG ERRVER  
! DISC SURFACE IS O.K., EXIT
         TSB R33
         JZR NOFM..  
         LDB R72,=2
         JSB =FORM.T  
         JMP FMTLOP            !TRY TO VERIFY AGAIN
NOFM..   BSZ 0
         JSB =EX__IT  
         RTN 
!***********************************
ERRVER   BSZ 0
! DECREMENT SPARE TRACK COUNT
         DCB R64
         JNG BADETT  
! VERIFY ERROR, MARK DEFECTIVE TRACK
         JSB =INITZE           !INITIALIZE BAD TRACK
         ICB R33
!                             SET REFORMAT FLAG = T
!
! SEEK TO NEXT SECTOR
!   GET DISC ADDRESS
         JSB =REQDA   
!****    CLB R47                 !SECTOR << 0
!***     ICB R46
!**      CMB R46,=2
!**      JNZ OK.HHH
! HEAD IS 2, GO TO NEXT CYLINDER
!***     CLB R46
!****    ICB R45
! AND SEEK TO NEXT TRACK
         LDBD R47,X14,HEADCT   !# OF HEADS

         ICB R46
         ARP R47
         JSB =HEADCH           ! COMPUTE HEAD,CYLINDER ETC
!LOC!         LOC 76161
OK.HHH   BSZ 0
         JSB =SEEK2   
! AND LOOP FOR THE REST OF THE DISCETTE
         JMP VFYL.P  
!*******************************
BADETT   BSZ 0
         JSB =EX__IT  
         JSB =MSERR   
         BYT 29D               !"BAD MEDIUM"
!--------------------------------------
! This routine accepts one DSJ byte .  The
! structure of this routine is:
!     1. UNTALK,UNLISTEN (using CMDOUT)
!     2. Primary TALK, Secondary
!     3. Send My Listen Address (CAPR addr)
!     4. Get DSJ byte (using DATAIN)
!     5. UNTALK
! Returns with DSJ byte in R46.
DSJ      BSZ 0
! NOW SEND PRIMARY AND SECONDARY
         LDM R46,=100,360

         JSB =OPSU#1  
! SEND CAPRICORN LISTEN ADDRESS
         JSB =SNDMLA           !SEND
! NOW GET DATA BYTE
         LDB R57,=1            !WANT ONE BYTE ONLY
         JSB =GET_BY           !GET DATA
         TSB R44
         RTN 
!-----------------------------------------
OO_-P*   JMP OO__P*  
!----------------------
! This performs a parallel poll and returns the
! resulting byte in R46.  The structure of this
! routine is:
! 1. Interface control (parallel poll)
! 2. Shift PPOLL byte until bit device is right
! 3. If bit not set then loop,else return
! This routine actually constitutes a wait loop,
! waiting for the device specified
! by R22 to respond to Parallel
! Poll.
PPOLL    BSZ 0
         STM R0,R44            !TIME-OUT COUNT
LOP-40   BSZ 0
         PUMD R44,+R6
         LDB R57,=1            !GET ONE BYTE
         LDB R46,=OUT.S4       !PARALLEL POLL
         JSB =DATAIN           !GET THE PPOLL BYTE
         LDBD R43,R66          !PUT IT IN R43
! CHECK FOR RELEVANT BIT SET (I.E. BIT OF DEVICE)
! THE DEVICE # IS ASSUMED IN R22.
! HERE FOLLOWS A LOOP WHICH SHIFTS THE PPOLL BYTE
! RIGHT (LOGICAL) DEVICE BITS.
!
! DETERMINE BIT RESPONSE EXPECTED
         LDB R44,=7
         SBB R44,R22           !SUBTRACT DEVICE
! DEVICES ARE NUMBERED S.T. DEV 7 IS BIT 0 ...
LOP-41   BSZ 0
         JZR SHFTDN            !IF DEVICE=0 THEN DONE
         LRB R43               !RIGHT SHIFT
         DCB R44               !DECREMENT DEVICE
         JMP LOP-41            !LOOP
SHFTDN   BSZ 0
         POMD R44,-R6
         DCM R44
         JNG PP_FAL  
         TSB R43
! CHECK TO SEE THAT BIT 0 (I.E. BIT DEVICE) = 1
         TSB R43               !CHECKING PPOLL BYTE
         JEV LOP-40            !IF NOT PRESENT POLL AGAIN
         RTN                   !  ELSE RETURN
!********************************
PP_FAL   BSZ 0
         JSB =UNTALI           ! CLEAR BUS TALKERS
OO__P*   GTO CNTERR  

!*************NO RETURN**********************
! This routine issues a SEEK command.
!     The target sector (conceptual) is given
! as a binary integer in R30,31.  The UNIT to
! send the SEEK to is given in R43.
!     formulae for finding the actual cylinder,
! head, and sector issued by this routine are:
!  CYLINDER = con-SECTOR DIV S
!  HEAD= (con-SECTOR DIV  E) MOD T
!  SECTOR = con-SECTOR MOD E
!           WHERE:   S = SECTORS/CYL
!                    E = SECTORS/TRACK
!              AND   T = TRACKS/CYL = NO HEADS
!
SEEK2    BSZ 0
!
!  SEEK2 PERFORMS A SEEK USING TARGET ADDRESS
!  IN R44-47
!
         CLB R41               !FLAG INDICATING TARGET ADDRESS
!                  ALREADY IN R44-47
         JMP PT.02-  
SEEK     BSZ 0
         JSB =UNTALI  
         JSB =TO_ID   
         TSB R37
         JNZ OO__P*  
         LDB R41,=1            !FLAG INDICATES TARGET ADDRESS IN R30,31
PT.02-   PUMD R44,+R6          !PUSH STACK FOR LATER POP
         JSB =UNTALI           !UNTALK AND UNLISTEN
!                                      IF NOT THEN
! SEND THE PRIMARY AND SECONDARY ADDRESS NOW
! SEND MY TALK ADDRESS
         JSB =S40              !   SEND
! NOW PREPARE TO SEND THE SEEK INFORMATION:
!    6 BYTES .....   002,UNIT,BYTE1CYLINDER,BYTE2-
!                    CYLINDER,HEAD,SECTOR
! THESE WILL BE BUILT IN R42-47
         LDB R42,=2            !             SEEK OPCODE
         LDB R43,R23           !             UNIT
! IF THE ADDRESS INFO IS ALREADY IN R44-47 THEN
! SEND IT DIRECTLY.  IF NOT, THEN GENERATE IT
! (USE R41 FLAG TO DECIDE)
         POMD R44,-R6          !RESTORE SEEK2 ADDRESS
         TSB R41
         JZR EASYAD            !JUMP IF ADDRESS IN R44-47
!  LOAD PARAMETERS FROM PREVIOUS TOID
         LDM R24,R44           !PUT IN R24,25
! NOW CALCULATE TARGET CYLINDER (= SECTOR DIV (2*S))
!   WHERE S = #SECTORS / TRACK
         CLM R44               ! START DIV AT 0
         CLM R56
         STB R25,R56           !EXTEND SEC-CYL TO 2-BYTES
DIVLOP   BSZ 0
! ***************************************************
! ****   SBM R30,R56            !SUBTRACT ONCE
! **     JNG DONDIV
! **     ICM R46                !AND INCREMENT DIV
! ****   JMP DIVLOP             !LOOP
! ***************************************************
         JSB =CYLFIX           ! ROUTINE WITH CYL>256 FIX
         JMP DONDIV            ! SKIP HOLE
!LOC!         LOC 76376
!---------------------------
DONDIV   BSZ 0
!*******************************************************
!**** DIVISION DONE, FIRST ERASE LAST SUBTRACT
!**  TO GET POSITIVE REMAINDER
!*       ADM R30,R56
!**    CYLFIX handles the mod differently
!****  It now returns when R30 still is positive.
!*******************************************************
!  NOW MOD IS IN R30,31 AND DIV IS IN R46,47
!  PUT TARGET CYLINDER (DIV) IN R44,45.
         LDB R44,R47           ! get high order byte
         LDB R45,R46           ! get low order byte
!  NOW PUT HEAD IN R46 AND SECTOR IN R47
!****    CLB R46                !TRY HEAD 0
!***     LRB R25                !R25 << SECTORS/TRACK
!**      CMB R30,R25
!**      JNG HD__00             !IF >0 THEN HEAD SHOULD BE 1
!***     ICB R46
!****    SBB R30,R25            !REMOVE ONE TRACKS WORTH
!*******MULTIPLE HEAD FIX**********************************
         JSB =COMHED           ! # OF SECS/TRACK
HDCNT    BSZ 0
         CMB R30,R57           ! MORE THAN ONE TRACK'S WORTH
         JNG HD__00            ! JIF NO
         SBB R30,R57           ! SUBTRACT OFF
         ICB R46               ! INCREASE HEAD COUNT
         JMP HDCNT   
!LOC!         LOC 76421
HD__00   BSZ 0
         STB R#,R47            !STORE SECTOR NUMBER
! ALL ADDRESS INFO IS NOW READY
! NOW STORE TO DATA BUFFER
EASYAD   BSZ 0
         STMD R42,R66
         LDB R57,=6            ! SIX DATA BYTES
         JSB =OPSU#3           !    SEND
! NOW WAIT FOR SEEK TO COMPLETE
         JSB =WAI++T  
         JSB =DSJ     
         RTN 
!********************************
! This routine performs the burst out-in
! of one sector (256 bytes) from-to the string
! addressed by R31,30.  The structure
! of this routine is:
!     1.  UNTALK send MTA
!     2.  UNLISTEN,UNTALK
!     3.  send Primary and Secondary (LISTEN)
!     4.  send OPCODE,UNIT
!     5.  UNLISTEN,UNTALK
!     6.  Primary and Secondary (LISTEN,TALK)
!     7.  Start burst mode
!     8.  UNLISTEN,UNTALK
!  The unit number is assumed to be in R23
RDBUFF   BSZ 0
         CLB R36
         JMP GO+.1   
!***********************************
WRBUFF   BSZ 0
         LDB R36,=40
GO+.1    BSZ 0
! SEND PRIMARY AND SECONDARY LISTEN ADDRESSES
         LDM R46,=40,151       !PRIMARY AND SECONDARY

         TSB R36
         JNZ GO+.2   
         ICB R47
GO+.2    BSZ 0
! SEND MY TALK ADDRESS
         JSB =S40+             !SEND
! NOW SEND OPCODE (10-5) AND UNIT
         LDB R46,=10           !PCODE
         TSB R36
         JNZ GO+.3   
         LDB R46,=5
GO+.3    BSZ 0
         LDB R47,R23           !UNIT
         STMD R46,R66          !STORE TO DATA BUFFER
         LDB R57,=2            !TWO DATA BYTES
         JSB =OPSU#3           !SEND
! NOW WAIT FOR DISC CONTROLLER TO ENABLE PPOLL
         TSB R36
         JNZ XNOPPX  
         CLM R46
         JSB =PPOLL   
XNOPPX   JSB =UNTALI  
! SEND PRIMARY AND SECONDARY LISTEN ADDRESSES
         LDM R46,=100,140      !      BURST OUT

         SBB R46,R36           !  (OR IN)
         JSB =OPSU#1  
! SEND MY TALK ADDRESS
         TSB R36
         JNZ GO+.5   
         JSB =SNDMLA  
         JMP GO++--  
GO+.5    BSZ 0
         JSB =SNDMTA           ! SEND
GO++--   BSZ 0
! NOW ENTER BURST LOOP
         TSB R36
         JNZ GO+.6   
         LDB R46,=41
         JSB =BSTIN   
         JMP GO+.7   
GO+.6    BSZ 0
         LDB R46,=40           ! HEX 20 (BURST OUTPUT)
         JSB =BSTOUT           ! ENTER BURST LOOP
GO+.7    BSZ 0
!********************************
! THIS LOCATION IS ENTERED FROM THE ISR
         JSB =SRTIOP  
         JSB =UNTALI           ! UNTALK UNLISTEN
         TSB R36
         JZR YNOPPY  
         CLM R46
         JSB =PPOLL   
YNOPPY   RTN 
TOID     BSZ 0
! TOID IS A HIGH-LEVEL ENTRY POINT!
! Time out identify.  This routine performs an identify
! command to the device specified by AMSUS.  If the
! identify times-out (i.e. no device present) then
! LLERR returns control to TOID.  TOID returns allways
! therefore.
!
! TO_ID (and TOID) are called from: VOL2AD, SEEK,
! FORM_T , and from the high-level.
!   TOID returns:   R37 --  0- good
!                           1- no disc controller
!                   R44 --  # cylinders
!                   R45 --  # sectors / cylinder
!                   R46-7 --  total # sectors on disc
!
         JSB =LLUN             ! init & untalk
         JSB =TO_ID   
!*********
!   THE COMMON EXIT ROUTINE EX__IT OCCURS HERE IN LINE
EX__IT   BSZ 0
         PUMD R46,+R6          !SAVE R46,47
         LDB R46,=111          !RESUME IO
         JSB =CMDOUT           !SEND
         LDBD R46,X14,SPAR#   

!          RESET EOI ENABLE AND EOL COUNT
WR_EOL   BSZ 0
         STBD R#,R66
         LDB R#,=220
         JSB =DATO1   
         POMD R46,-R6          !RESTORE R46,47
         RTN 
!*******************************
!**
! SEND CAPRICORN LISTEN ADDRESS
TO_ID    BSZ 0
         JSB =SNDMLA           !  SEND
! SEND UNTALK (137)
         LDB R46,=137          !UNTALK
         JSB =OUTCM1           ! SEND
! SEND SECONDARY P11[ DEVICE ]
!----------------------------------------------
!OA's miracle TIMEOUT fix:
!     CLB R46       COUNT 256
!O_FIX DCB R#
!     JNZ TO_FIX    STALL 256 LOOPS
!----------------------------------------------
         LDB R46,=140
         ADB R#,R22            !ADD DEVICE
         JSB =LLPARI           ! ADD PARITY BIT
         DRP R46
         JSB =OUTCM1           !  SEND
RTNAD2   BSZ 0
! GET 2 BYTES BACK
         LDB R57,=2            !GET 2 BYTES
         LDB R46,=OUT.EN       !ENTER BYTES FROM HP-IB
         CLB R37
!                      CLEAR IDENTIFY ERROR FLAG
         JSB =DATAIN           ! GET ID BYTES
!                       TRY TO GET DATA
RTNADD   BSZ 0                 !R.A. FOR ERROR RETURN FROM
!                        CNTERR (COUNT ERROR)
!
!   SAVE R54-7 AND USE TO GATHER DISC PARAMETERS
!
         PUMD R52,+R6
         TSB R37
         JNZ TOIDER            !IF TIME-OUT THEN RETURN ERROR
         LDMD R46,R66          !GET IDENTIFY BYTES
!******* LDM R54,=41,40,40,4    !   MINI FLOPPY PARAMETERS
!******                      41 = 33D   -- CYLINDERS
!*****                       40 = 32D   -- SECTORS/CYLINDER
!****                      1056D = 2040 = 4,40
!***                                    -- TOTAL SECTORS
!**      CMM R46,=1,4
!*       JZR OOOK.              !IF MINI CONTROLLER
!**      LDM R54,=113,74,224,21 !8" FLOPPY PARAMETERS
!***                          113 = 75D  -- CYLINDERS
!****                         74  = 60D  -- SEC/CYL
!*****            4320D = 10624 = 21,224 -- SECTORS TOT
!******  CMM R46,=0,201
!******* JZR OOOK.              ! R40 << 1 IF 8" CONTROLLER
!******  LDM R54,=104,40,200,10 !QUAD MINI PARAMETERS
!*****                           104 = 68D -- CYL
!****                             40 = 32D -- SEC/CYL
!***              2176D = 4200 = 10,200    -- TOT SEC
!**      CMM R46,=1,5
!*       JZR OOOK.              !R40 << 2 IF QUAD DENSITY MINI
!**                    THIS IS A HOOK FOR FUTURE USE
!***  SOMETHING THERE, BUT NOT A DISC CONTROLLER
!**** THUS, ERROR
!*************************************************************
!*    MULTIPLE HEAD AND GREATER DISC SUPPORT                 *
!*                                                           *
TOID2    DAD 76650
         JSB =ROMJSB           ! no room in this rom
         DEF TOID2             ! let ED rom handle it
         BYT 321
         JMP OOOK.   
!*                                                           *
!*************************************************************
HEDSET   BSZ 0
         STM R53,R43           ! SAVE CYL#,TOTAL ETC
         STBD R52,X14,HEADCT   ! SAVE HEAD COUNT

         RTN 
!-------------------------------------------------------------
!
HEADCH   BSZ 0
         CMB R#,R#
         JNZ OK.HH-  
         CLB R#
         ICB R45
         JNC OK.HH-  
         ICB R44
OK.HH-   BSZ 0
         CLB R47
         RTN 
!-------------------------------------------------------------
!
CMPTAR   BSZ 0
         LDM R46,R44           ! SWITCH REGISTERS
         CMM R46,R50           ! SAME AS LAST?
         RTN 
!LOC!         LOC 76774
TOIDER   BSZ 0
!OA's miracle save 2 bytes:
         ICB R37
!-------------------------------------
OOOK.    BSZ 0
!    PUT TOID INFO IN R44-7 AND RESTORE R54-7
!****    STM R54,R44
         JSB =HEDSET           ! multiple head recover
!        DRP !52
         POMD R#,-R6
         JSB =UNTA.!           !SEND UNTALK AND UNLISTEN
         RTN                   !RETURN
!------------------------------
L.D.S    BSZ 0
!*********************
!  L.D.S is an optimization routine.
         JSB =LLINIT  
         JSB =DSJ     
STATUS   BSZ 0
! The STATUS routine gets 2 status words from a
! controller.  Status word 1 gives info on the
! most recent operation and status 2 gives info
! on the current state of a unit.
! Bytes returned are:
!    R44    Status 1 Byte 1
!    R45    Status 1 Byte 2
!    R46    Status 2 Byte 1
!    R47    Status 2 byte 2
!
!   The comand sequence involves*
!       First a REQUEST STATUS then
!             a RECIEVE STATUS.
!
! FIRST request status
!
         JSB =S40350           !SEND UNTALK AND UNLISTEN
!
!   SEND PRIMARY LISTEN AND SECONDARY
!
! SEND CAPRICORN TALK ADDRESS
! NOW SEND OPCODE AND UNIT
!          WITH ATN =0
         LDB R47,R23           ! UNIT FROM R23
         LDB R46,=3            !OPCODE =3
         JMP REQ+++  
!
! SEND MY LISTEN ADDRESS
!     (ALSO INCLUDES SEND MY TALK ADDRESS
!      ENTRY SNDMTA)
!
S40350   JSB =UNTALI  
S40      LDM R46,=40,350

S40+     JSB =OPSU#1           !SEND
!************   ********************
SNDMTA   BSZ 0
         LDB R46,=OUT.S5  
         JMP CO++MN  
!************************************
SNDMLA   BSZ 0
         LDB R46,=OUT.S6  
!************    *********************
CO++MN   BSZ 0
! AND SEND MY ISTEN ADDRESS
         JSB =CMDOUT           !SEND
! AND FINALLY, RETURN
         RTN 
REQDA    BSZ 0
! THIS ROUTINE PERFORMS A REQUEST DISC LOGICAL
! ADDRESS OF THE DISC CONTROLLER (LAST UNIT
! ACCESSED).  THIS ADDRESS (CYLINDER BYTE1,
! CYLINDER BYTE2, HEAD, SECTOR) IS RETURNED
! IN R44-47
         JSB =S40350           !SEND UNTALK AND UNLISTEN
! SEND PRIMARY AND SECONDARY LISTEN
! SEND CAPR TALK ADDRESS
! SEND OPCODE (24) AND DUMMY EOI BYTE
         LDB R46,=24
REQ+++   STMD R#,R66           !PUT IN DATA BUFFER
         JSB =S2#3    
! AND UNTALK UNLISTEN
         JSB =WAI++T  
! NOW GET FOUR ADDRESS BYTES
!
! SEND PRIMARY AND SECONDARY TALK
         JSB =SNDMLA           !SEND CAPR LISTEN ADDRESS
         LDM R46,=100,350

         JSB =OPSU#1           ! SEND
!
! AND GET FOUR BYTES
         LDB R57,=4
GET_BY   LDB R46,=OUT.EN  
         JSB =DATAIN           ! GET FOUR BYTES
! AND TERMINATE WITH UNTALK UNLISTEN AND RETRUN
         LDMD R44,R66          !GET ADDRESS
UNTA.!   PUMD R44,+R6
         JSB =UNTALI  
         POMD R44,-R6
         RTN 
!*********************************************
!**                                        ***
!**     GROUP THREE                        ***
!**        CONCEPTUAL LEVEL DISC UTILITIES ***
!**                                        ***
!*********************************************
!**
! The third group of low-level routines follows.
! All routines in this group call HLINI as their
! first act, for the purpose of future retries.
! HLINI records the information (HL entry point,
! input parameter values, and retry count)
! necessary to retry following a bad disk operation
! (DSJ = 1).
HLINI    BSZ 0
! SET RETRY VECTOR IN R72,73,74
!*****   CLB R71                !CLEAR NO HEAD MOVES
!***     CLB R52                !SET FULL PROTOCOL
!*       LDB R74,=10            ! RETRY COUNTER
!
         JSB =HOOK             ! call hook from common routine
         DRP R71               ! for make room routine
         JSB =SETHLI           ! makes room for hook call
! SAVE RETRY ADDRESS (FROM R.A. STACK) IN R20,21
         POMD R20,-R6          ! POP R.A.
         PUMD R20,+R6          ! RESTORE R.A. FOR RETURN
! AND SAVE INPUT PARAMETERS (SAVE R30-33)
SAV_PA   LDM R44,R30
         STMD R#,X14,PARAMS    !SAVE R32,33

! AND RETURN
         RTN 
! the routine PUTSEC transfers one sector (256
! bytes) TO the disk (sector number specified
! in R32,33) FROM Capricorn RAM (address in R30,
! 31).  Each suboperation (SEEK,WRBUFF) is
! followed by a DSJ. If DSJ returns a 1 result
! then this routine aborts through MSERR.
! The structure of this routine is:
!     1. save R30,31, and initialize
!     2. SEEK target sector
!     3. DSJ (and exit if error)
!     4. WRBUFF FROM RAM specified
!     5. DSJ (and exit if error)
!
! ENTRY POINTS ARE:
!                    PUTBUF
!                    PUTSEC
!                    GETBUF
!                    GETSEC
!                    GETBU+
!                    GETSE+
!                    PUTBU+
!               AND  PUTSE+
!
PUTBUF   BSZ 0
!****    LDM R30,=RECBUF        !TAPE BUFFER ADDR
!
         ARP R14              ! flag for hook
         JSB =PBUFST           ! set up for PUTBUF
!
PUTSEC   BSZ 0
!****    LDB R36,=1
!
         JSB =PSECST           ! setup for PUTSEC
!
PGCOM+   BSZ 0
         JSB =HLINI   
         JSB =LLINIT  
! FIRST SAVE THE RAM ADDRESS AND INITIALIZE
         JSB =SAV_PA  
!                              SAVE TARGET SECTOR
! NOW SEEK AND DSJ
         STM R32,R30           !    LOAD TARGET SECTOR
         JSB =SEEK             !PERFORM DISC SEEK
         JZR OK.3A   
         JSB =LLERR   
OK.3A    BSZ 0
         LDMD R30,X14,PARAMS   !LOAD RAM ADDR

! NOW PERFORM BURST OUTPUT AND DSJ
LLOK     BSZ 0
         TSB R36               !JIF GETSECTOR
         JZR GETS++  
         JSB =WRBUFF           !PERFORM WRITE BUFFERED
         JMP PGCONT            ! CONTINUE
GETS++   JSB =RDBUFF           ! PERFORM READ BUFFERED
PGCONT   JSB =DSJ              !GET OPERATION STATUS
         JEV LLOK2             !     ELSE GO-ON
         JSB =LLERR            !          ERROR EXIT
! DONE SUCCESSFULLY, RETURN
LLOK2    BSZ 0
         JSB =EX__IT  
         RTN 
!-------------------------------------------------
GETBUF   BSZ 0
!****    LDM R30,=RECBUF
!
         ARP R0                ! flag for hook
         JSB =GBUFST           ! set up for GETBUF
!
GETSEC   BSZ 0
!Same as PUTSEC but does a read from disk
!to capricorn.
!*****   CLB R36                ! FLAG GETSECTOR
!***     JMP PGCOM+
!
         ARP R4               ! setup for hook
         JSB =GSECST           ! set up for GETSEC
!
!-----------------------------------------------------
GETBU+   BSZ 0
!****    LDM R30,=RECBUF
!
         ARP R2               ! flag for hook
         JSB =GBU+ST           ! set up for GETBU+
!
GETSE+   BSZ 0
!****    CLB R36
!SAME AS GETSEC BUT NO SEEK
!***     JMP GETP+-
!
         ARP R6               ! flag for hook
         JSB =GSE+ST           ! set up for GETSE+
!
!------------------------------------------------------
PUTBU+   BSZ 0
!****    LDM R30,=RECBUF
!
         ARP R16              ! flag for hook
         JSB =PBU+ST           ! set up for PUTBU+
!
PUTSE+   BSZ 0
!****    LDB R36,=1
!
         JSB =PSE+ST           ! setup for hook & PUTSE+
!
GETP+-   BSZ 0
         JSB =HLINI            !HIGH-LEVEL INIT
         ICB R52
         JSB =LLINIT  
!SAME AS PUTSEC BUT NO SEEK
         JMP LLOK    
!*****************************************
!                                        *
!   SEE FORMAT                           *
!                                        *
!*****************************************
!
! FORMAT then DSJ and check DSJ byte.
!LFMT   BSZ 0     HIGH LEVEL ENTRY POINT
! FORMAT CALLS LLINIT
!       JSB =HLINI   HIGH-LEVEL INIT
!TFORM  BSZ 0        RETRY ENTRY POINT
!       JSB =FORMAT  PERFORM FORMAT
!       JMP PGCONT
!
! This routine performs a seek to the
! conceptual sector in R30,31.  The call
! to SEEK is preceeded by a call to LLINIT,
! and followed by a checking DSJ call.
HLSEEK   BSZ 0
         ARP R12              ! hook flag
         JSB =HLINI   
!****    JSB =LLINIT
!**      JSB =SEEK              !SEEK
!
         JSB =MKROM2           ! make room for hook arp flag
         JMP PGCONT  
!********************************************
!
!         ++++  THIS ROUTINE BELONGS TO VOL2AD ++++
!
!LOC!         LOC 77323
ESCFOR   BSZ 0                 !END OF SC FOR
         JSB =CK_-RA           !CHECK FOR CALL FROM RESET
         JNZ ERXXX   
         CLM R44
PUTMSU   STMD R44,X14,ACTMSU   !SAVE MSUS

         RTN 
!***********************************
ERXXX    BSZ 0
         JSB =MSERR   
         BYT 25D               ! "NO SUCH VOLUME"
!************************************
CK_-RA   BSZ 0
         LDM R30,=RSR.A.       !GET RESET PWO R.A.

         POMD R44,-R6          !GET SECOND R.A. IN STACK
         PUMD R44,+R6
         CMM R30,R44           !COMPARE THE TWO
         RTN 
VOL2AD   BSZ 0
!  This routine accepts a volume label in ram
!  (SPECIF) and converts that to an MSUS (in
!  AMSUS).  This is accomplished by searching the
!  media present for the given volume label.  Search
!  is in order of ascending Controller address, and
!  ascending SC (thus if duplicate labels exist then
!  the one residing in the lower address MSUS will be
!  found).  If the volume label specified is not
!  then an error return occurs.
!
! FOR SC := 0 TO 7 DO
!
         BIN 
         STMD R42,X14,SPECIF   !SAVE TARGET LABEL IN RAM

!****    LDB R61,=377           !START COUNT AT -1
!
         JSB =VLHOOK           ! call hook for VOL2AD
SCFOR    BSZ 0                 !**START OF FOR*******
         ICB R61               !  INCREMENT COUNT
         CMB R61,=8D
         JZR ESCFOR            !   AND END IF EQUAL
!  CHECK GLOBAL VECTOR IOBITS TO ENSURE THAT AN
!  IOP IS LOGGED IN FOR THIS SC
!
!  SC COPY IN R47 IS DECREMENTED AS IOBITS COPY IN
!  R46 IS LOGICAL RIGHT SHIFTED.  WHEN SC IS
!  REDUCED TO 0 THEN IOBITS MUST BE ODD.
         LDBD R46,=IOBITS      !GET COPY OPF IOBITS

         LDB R47,R61           !GET COPY OF SC
LOPBIT   JZR CKBITA            !IF SC=0 THEN DONE SHIFTING
         LRB R46               ! ELSE SHIFT IOBITS
         DCB R47               !      AND DEC SC
         JMP LOPBIT            !      AND LOOP
CKBITA   BSZ 0
         TSB R46
         JEV SCFOR             !IF IOBITS EVEN THEN DONE
!                               WITH THIS SC
!
!   FOR CONTROLLER-ADDRESS :=0 TO 7
!
         CLB R52
         LDB R62,=377          !START COUNT AT -1
CONFOR   BSZ 0                 !***START OF CA FOR*******
! ***    ICB R62                !     INCREMENT COUNT
! **     DRP !62
         JSB =CONINC           ! increment for loop
         CMB R#,=8D
         JZR SCFOR             !         ELSE END OF C.A. FOR
!
!       DO BEGIN (* CA FOR LOOP *)
!            TIME OUT IDENTIFY
!            IF DISC CONTROLLER THEN
!
! store test MSUS in AMSUS for TOID
! *****  LDB R60,=1             !DISC FLAG
! ****   CLB R63                !DUMMY UNIT (0)
! ***    LDM R44,R60
! **     JSB =PUTMSU            !           ONLY NEED SC
!                                 AND CA (R61,62)
         JSB =CKHPIB           ! check for HPIB cards
         JNZ SCFOR             ! jif not an HPIB card
         JSB =CKCLLR           ! check for controller
         JPS SCFOR             ! jif not a controller
         JSB =TOID             !  TIME-OUT IDENTIFY
!  TIME-OUT IDENTIFY (TOID) ALLWAYS RETURNS
!  THE SUCCESS OR FAILURE (DISC CONTROLLER OR NOT)]
!  IS INDICATED IN RAM FLAG TOIDFG
         TSB R37
         JNZ CONFOR            !IF FAILURE (NO DISC CONTROLLER
!
!  DISC COMTROLLER FOUND
!  IF (FROM RESET)
!     THEN RETURN
!  (Look in RA stack for RSR.A.)
!
         JSB =CK_-RA  
         JNZ NOTRST            !IF UNEQUAL THEN NOT RESET
         JSB =EX__IT  
         RTN                   !           ELSE RETURN
!LOC!         LOC 77470
NOTRST   BSZ 0
!                         THEN (GET NEXT C.A.)
!
!                 BEGIN (* IS DISC CONTROLLER *)
!                 FOR UNIT :=0 TO 3 DO
!                     BEGIN
!                       IF STATUS O.K. THEN
!                          READ VOLUME LABEL
!                          IF VOL LABEL MATCHES
!                             THEN RETURN SUCCESS
!                                  SET R44-47
!                     END
!                 END (* IS DISC CONTROLLER *)
!
         LDB R63,=377          !START UNIT
UNFOR    BSZ 0                 !*********START OF UNIT FOR *******
         ICB R63               ! INCREMENT COUNT
         CMB R63,=4
         JZR CONFOR            !IF EQUAL THEN END OF FOR
! STORE MSUS IN AMSUS
         LDB R60,=1            !         DISC FLAG (TYPE)
         LDM R44,R60
         JSB =PUTMSU           !         PUT IN RAM
!                                     *
!  CHECK STATUS ON THIS UNIT
!  IF BYTE1 STATUS2 IS ODD THEN STATUS 2 ERROR
!                               GET NEXT UNIT
!
         JSB =L.D.S            !CLEAR POSSIBLE HOLDOFF
         ICB R52               !CHANGE TO SHORT PROTOCOL
         TSB R46
         JNG UNFOR             !ERROR IF STATUS2 ERROR BIT SET
         CLM R30
         JSB =SEEK    
         JNZ UNFOR             !IF NEGATIVE THEN NEXT UNIT
! AT THIS POINT WE HAVE FOUND A DISC CONTROLLER
! AND A GOOD UNIT, SO GET THE VOLUME LABEL.
         LDM R30,=RECBUF  

         JSB =RDBUFF  
! IF DESIRED LABEL THEN RETURN
         LDMD R42,X14,SPECIF   !GET TARGET LABEL

         LDM R30,=RECBUF  

         LDMD R72,X30,V.LABL   !GET MEDIUM'S LABEL

         CMM R72,R42           !COMPARE THE TWO LABELS
         JNZ UNFOR             !IF NOT SAME THEN GET NEXT UNIT
!************************
!
!  SUCCESSFULL RETURN >>>>>>>>
!
!    SET R44-47
         JSB =LLINIT  
         JSB =EX__IT  
SETMSU   LDMD R44,X14,ACTMSU   !LOAD AMSUS

         RTN 
!
!****************************
! This routine performs the clean-up necessary
! before a retry (after a DSJ error).  First,
! the retry count is incremented and tested.
! If the count  is not satisfied then restore
! the input parameters, and recall the high-level
! entry point (from R20,21) to jump to.
!
! FIRST DECREMENT THE RETRY COUNT
LLERR    BSZ 0
         JSB =STATUS  
! RETURNS WITH STATUS BYTES IN R44-47
! TEST STATUS 1 BYTE 1 (PUT COPY OF R47 IN R46)
         STB R47,R46
         CMB R44,=7            !CYLINDER COMPARE ERROR
         JZR BAD...  
         CMB R44,=21           !DEFECTIVE TRACE OR SECTOR
         JZR BAD...  
         CMB R44,=23           !STATUS TWO ERROR
         JZR BAD...  
         ANM R47,=4            ! 0000 0100 SEEK CHECK BIT
         JNZ BAD...  
         JMP OK..01  
BAD...   BSZ 0
         ANM R47,=10           !  CHECK FOR FIRST STATUS HOLDOFF
         JNZ OK..01            !  BIT SET, RE-TRY
! DO NOT RETRY
! CHECK FOR WRITE PROTECT
         ANM R46,=100,0        !  WRITE PROTECT BIT

         JZR BADDDD  
         JSB =EX__IT  
         JSB =MSERR+  
         BYT 60D               !"WRITE PROTECT"
!                   USE SYSTEM ERROR
!---------------------
BADDDD   BSZ 0
         CLB R71               !CLEAR HEAD POSITION
         JSB =EX__IT  
         JSB =MSERR   
         BYT 30D               !"DISC ERROR"
!--------------------------
OK..01   BSZ 0
! DECREMENT RETRY COUNT AND TEST
         DCB R74
         JZR RTCNTO  
! RETRY AREA
RETRY    BSZ 0
         LDMD R44,X14,PARAMS  

         STM R44,R30
! INPUT PARAMETERS RESTORED, POP CALING
! R.A. AND REPLACE WITH HIGH LEVEL ENTRY
         POMD R46,-R6
! H.L. R.A. WAS SAVED IN R20,21 BY HLINIT
         PUMD R20,+R6
! AND RETURN TO TRY AGAIN
LL__EX   BSZ 0
         JSB =EX__IT  
         RTN 
!--------------------------
! RETRY COUNT EXPIRED, CHECK HEAD STATE
RTCNTO   BSZ 0
         LDB R74,=10           !RESET RETRY COUNT
! TEST R71    (IF < 2 THEN MOVE HEAD AND RETRY)
         CMB R71,=2
         JZR BADDDD  
! MOVE HEAD AND RETRY
         JSB =HDMOVE  
         JMP RETRY   
!-----------------------------
HDMOVE   BSZ 0
! MOVE HEAD  IN IF R71=0
!           OUT IF R71=1
!                  AND MOVE HEAD BACK
! THEN INCREMENT R71
!
! FIRST, GET DISC ADDRESS
         JSB =REQDA   
! RETURNS WITH ADDRESS IN R44-47
!
         LDB R24,R45           !LSB OF CYLINDER COUNT
         TSB R71
         JNZ MOVOUT            !   IF <>0 THEN MOVEOUT
         TSB R24
         JZR DON.E             !CAN'T MOVE IN IF CYL 0,
!                     SO DON'T
! DECREMENT CYLINDER AND SEEK
         DCB R#
         JMP MOV-..  
! INCREMENT CYLINDER AND SEEK
MOVOUT   BSZ 0
         ICB R24
MOV-..   PUMD R44,+R6          !SAVE ADDRESS
         STB R24,R45
         JSB =SEEK2   
! RETURN TO DESIRED CYLINDER
         POMD R44,-R6          !RESTORE ADDRESS
         JSB =SEEK2   
!***************************
DON.E    BSZ 0
! INCREMENT R71  (HEAD STATUS)
         ICB R71
! AND REUURN
         RTN 
!********************************************
!                                           *
         FIN
