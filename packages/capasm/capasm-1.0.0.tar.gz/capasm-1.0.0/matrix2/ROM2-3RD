100 !        HED MAT C = TRANSPOSE(A) ROUTINE
110 !**************************************************************
120 !*** MAT C = TRN (A) :                                      ***
130 !***         RESULT ARRAY WILL CONTAIN THE SAME ELEMENTS    ***
140 !***         AS THE OPERAND ARRAY, BUT THE ROWS AND COLUMNS ***
150 !***         WILL BE INTERCHANGED.                          ***
160 !*** IN    : RELATIVE ADDRESS C                             ***
170 !***         RELATIVE ADDRESS A                             ***
180 !***                           <--- R12                     ***
190 !*** OUT   : STACK POPPED & ARRAY ASSIGNED                  ***
200 !***         (AND REDIMENSIONED IF NECESSARY)               ***
210 !**************************************************************
220 !
230          LST 
240 TRNPS2   BSZ 0
250          UNL 
260 !        -------------------
270 !        -- GET A INFO &  --
280 !        -- REDIMENSION C --
290 !        -------------------
300          JSB =LOCSZ2             !Ba, Ma, Na
310          LDM R70,R22             !SAVE Ma & Na
320          STM R24,R14             !COPY Na
330          LDM R24,R22             !Mc = Na
340          STM R14,R22             !Nc = Ma
350          JSB =RDIM2              !REDIM C -- Na X Ma
360          JSB =ZERTST             !SEE IF NULL ARRAY RESULTS
370          JNZ TRNPOS              !IF (NULL ARRAY)
380          RTN                     !   QUIT
390 TRNPOS   BSZ 0                   !END IF
400 !        -------------------
410 !        -- COPY A INTO C --
420 !        -------------------
430          JSB =EQUA2              !COPY A INTO C
440          JSB =ROMJSB  
450          DEF MNMUL               !FIND MN = Mc * Nc
460          BYT 260
470          LDM R10,R55             !MN
480          STM R10,R14
490          DCM R14                 !MN - 1
500          LDMD R20,=INCRC         !GET ELE SIZE OF C
510          LDM R0,=70,0            !INIT R0
520          SBB R0,R20              !60(REAL), 64(SHORT), 65(INTEGER)
530 !        ---------------------
540 !        -- TAG BYTE & INCR --
550 !        ---------------------
560          BSZ 0                   !ASSUME INTEGER OR SHORT ...
570          CLM R26                 !   TAG INCR = 0
580          LDB R74,=100            !   TAG = 2nd M.S.BIT OF SIGN
590          CMB R20,=10             !TEST TYPE OF ARRAY C
600          JNZ TRN09               !IF (REAL)
610          LDB R26,=6              !   TAG INCR = 6
620          LDB R74,=4              !   TAG = 2nd M.S.BIT OF SIGN
630 TRN09    BSZ 0                   !END IF
640 !        ----------------------
650 !        -- IN PLACE CYCLING --
660 !        ----------------------
670 CYCLE1   BSZ 0                   !REPEAT
680          JSB =TRNUT2             !   FIND ADDR Pth ELE (R45)
690          STM R#,R65              !   SAVE IT
700          CLB R30
710          SBM R45,R26             !   ADDR TAG BYTE Pth ELE
720          STMD R45,=PTR2          !   STORE ADDR IN PTR2
730          LDBI R35,=PTR2-         !   GET TAG BYTE
740          STB R35,R34             !   SAVE IT
750          ANM R35,R74             !   Pth ELE TAGGED OR UNTAGGED ?
760          JNZ CYCLE4              !   IF (Pth ELE UNTAGGED)
770          LDB R35,R74             !      GET TAG
780          ADB R35,R34             !      TAG THE BYTE
790          STBI R35,=PTR2          !      STORE TAGGED BYTE
800          LDM R45,R65             !      RESTORE ADDR Pth ELE
810          JSB =LDR*               !      Y = [P]
820 CYCLE2   BSZ 0                   !      LOOP
830          PUMD R*,+R12            !         SAVE Y
840          JSB =TRNUT1             !         GET NEW P
850          JSB =TRNUT2             !         GET IT'S ADDR
860          JSB =LDR*               !         GET [P]
870          PUMD R*,+R6             !         SAVE [P]
880          POMD R*,-R12            !         GET Y
890          JSB =STR*               !         [P] = Y
900          POMD R*,-R6             !         Y = [P]
910          CMB R20,=10             !         TEST TYPE
920          JZR TRN08               !         IF (INTEGER OR SHORT)
930          ADB R0,R20              !            ADD IN ELE SIZE
940          DCB R0                  !            R0 = 67
950          JMP TRN04   
960 TRN08    BSZ 0                   !         ELSE - (REAL)
970          ICB R0                  !            R0 = 61
980 TRN04    BSZ 0                   !         END IF
990          LDB R35,R74             !         GET TAG
1000          ANM R35,R*             !         IS Y TAGGED ?
1010          JNZ CYCLE3             !         ESCAPE LOOP IF Y TAGGED
1020          ADB R*,R74             !         TAG Y
1030          JSB =RSTR0             !         RESTORE R0
1040          JMP CYCLE2             !         LOOP
1050 CYCLE3   BSZ 0                  !      END LOOP
1060          JSB =RSTR0             !      RESTORE R0
1070 CYCLE4   BSZ 0                  !   END IF
1080          DCM R10                !   P = P - 1
1090          JNZ CYCLE1             !UNTIL (P = 0)
1100 !        ----------------------
1110 !        -- UNTAG SIGN BYTES --
1120 !        ----------------------
1130          ICM R14                !MN
1140          NCB R74                !UNARY NOT THE TAG
1150          CLB R30
1160          LDMD R45,=TMP3++       !GET Bc
1170          SBM R45,R26            !ADDR TAG BYTE
1180 UNTAG    BSZ 0                  !REPEAT
1190          STMD R45,=PTR2         !   POINT TO TAG BYTE
1200          LDBI R35,=PTR2-        !   GET TAG BYTE
1210          ANM R35,R74            !   CLEAR TAG BYTE
1220          STBI R35,=PTR2         !   STORE CLEARED TAG BYTE
1230          LDMD R55,=INCRC        !   GET ELE SIZE OF C
1240          CLB R57
1250          SBM R45,R55            !   GET NEXT TAG BYTE ADDR
1260          DCM R14                !   MN = MN - 1
1270          JNZ UNTAG              !UNTIL (MN = 0)
1280          RTN 
1290 !
1300 !******************************************************************
1310 !* TRNUT1: THE Pth ELE OF AN M X N MATRIX A IS MAPPED BY THE      *
1320 !*         TRANSPOSE TO ELE M(P-1)+1-(MN-1)INT((P-1)/N) OF TRN(A) *
1330 !* ENTRY : R10/11 = P; R70/71 = M; R72/73 = N; R14/15 = MN-1      *
1340 !* EXIT  : R10/11 = M(P-1)+1-(MN-1)INT((P-1)/N)                   *
1350 !******************************************************************
1360 !
1370 TRNUT1   BSZ 0
1380          DCM R10                !P - 1
1390          STM R10,R66            !MOVE IT
1400          LDM R76,R70            !MOVE M
1410          JSB =INTMUL            !M(P-1)
1420          ICM R54                !M(P-1)+1
1430          STM R54,R44            !SAVE IT
1440          CLM R66
1450          DCM R66                !INIT COUNTER
1460 TRN07    BSZ 0                  !REPEAT
1470          ICM R66                !   BUMP CURRENT INT((P-1)/N)
1480          SBM R10,R72            !   SUBTRACT OUT N
1490          JCY TRN07              !UNTIL (ANSWER IS NEGATIVE)
1500          STM R14,R76            !MN -1
1510          JSB =INTMUL            !(MN-1)INT((P-1)/N)
1520          SBM R44,R54            !EXIT VALUE
1530          LDM R10,R44
1540          RTN 
1550 !
1560 !***************************************************************
1570 !* TRNUT2: COMPUTES ADDR OF Pth ELE OF MATRIX A                *
1580 !* ENTRY : R10/11 = P; R20,21 = 8,4 OR 3; TMP3++ = Bc          *
1590 !* EXIT  : R45/46/47 = ADDR Pth ELE                            *
1600 !***************************************************************
1610 !
1620 TRNUT2   BSZ 0
1630          LDM R32,R10            !P
1640          DCM R32                !P - 1
1650          STM R32,R34            !COPY P - 1
1660          LLM R32                !2(P-1)
1670          LLM R32                !4(P-1)
1680          CMB R20,=4             !TEST TYPE OF ARRAY C
1690          JCY TRN06              !IF (INTEGER)
1700          SBM R32,R34            !   3(P-1)
1710          JMP TRN05   
1720 TRN06    BSZ 0
1730          JZR TRN05              !ELSE IF (REAL)
1740          LLM R32                !   8(P-1)
1750 TRN05    BSZ 0                  !END IF
1760          CLB R34
1770          LDMD R45,=TMP3++       !GET Bc
1780          SBM R45,R32            !ADDR Pth ELE
1790          RTN 
1800 !
1810 !***************************************************************
1820 !* LDR* : LOADS R[R0] WITH VALUE ADDRESSED BY PTR2             *
1830 !* ENTRY: R0 = 60(REAL), 64(SHORT), 65(INT); R45 = ADDR OF ELE *
1840 !* EXIT : R60 OR 64 OR 65 LOADED WITH APPROPRIATE              *
1850 !*        REAL ,SHORT OR INTEGER VALUE                         *
1860 !***************************************************************
1870 !
1880 LDR*     BSZ 0
1890          STMD R45,=PTR2         !POINT TO ARRAY VALUE
1900          CMB R0,=64             !TEST TYPE
1910          JCY LDR*1              !IF (REAL)
1920          LDMI R60,=PTR2-        !   LOAD 8 BYTES
1930          RTN 
1940 LDR*1    JZR LDR*2              !ELSE IF (INTEGER)
1950          LDMI R65,=PTR2-        !   LOAD 3 BYTES
1960          RTN 
1970 LDR*2    BSZ 0                  !ELSE (SHORT)
1980          LDMI R64,=PTR2-        !   LOAD 4 BYTES
1990          BSZ 0                  !END IF
2000          RTN 
2010 !
2020 !****************************************************************
2030 !* STR* : STORES R[R0] INTO ARRAY ELE POINTED TO BY PRT2        *
2040 !* ENTRY: R0 = 60(REAL), 64(SHORT), 65(INT); PTR2 = ADDR OF ELE *
2050 !* EXIT : [PTR2] STORED WITH VALUE CONTAINED IN R60 OR 64 OR 65 *
2060 !****************************************************************
2070 !
2080 STR*     BSZ 0
2090          CMB R0,=64             !TEST TYPE
2100          JCY STR*1              !IF (REAL)
2110          STMI R60,=PTR2         !   STORE 8 BYTES
2120          RTN 
2130 STR*1    JZR STR*2              !ELSE IF (INTEGER)
2140          STMI R65,=PTR2         !   STORE 3 BYTES
2150          RTN 
2160 STR*2    BSZ 0                  !ELSE (SHORT)
2170          STMI R64,=PTR2         !   STORE 4 BYTES
2180          BSZ 0                  !END IF
2190          RTN 
2200 !
2210 !**********************************************************
2220 !* RSTR0: RESTORES R0 TO 64 IF SHORT, 65 IF INTEGER       *
2230 !* ENTRY: R0 = 67(SHORT & INTEGER), 61(REAL)              *
2240 !*        R20 = 10(REAL),  4(SHORT),  3(INTEGER)          *
2250 !* EXIT : R0  = 60(REAL), 64(SHORT), 65(INTEGER)          *
2260 !**********************************************************
2270 !
2280 RSTR0    BSZ 0
2290          CMB R20,=10            !TEST TYPE
2300          JZR RSTR01             !IF (INTEGER OR SHORT)
2310          SBB R0,R20             !   SUBTRACT ELE SIZE
2320          ICB R0                 !   R0 = 65 IF INTEGER
2330          JMP RSTR02             !   R0 = 64 IF SHORT
2340 RSTR01   BSZ 0                  !ELSE - (REAL)
2350          DCB R0                 !   R0 = 60
2360 RSTR02   BSZ 0                  !END IF
2370          RTN 
2380 !
2390 !        HED LBND AND UBND ROUTINES
2400 !****  LBND ATTRIBUTES TABLE  **********************************
2410          BYT 44,55
2420 !***************************************************************
2430 !*** LBND (A,EXP) : LOWER BOUND OF ARRAY SUBSCRIPT (1 OR 2)  ***
2440 !***                OF ARRAY A, SPECIFIED BY ROUNDED INTEGER ***
2450 !***                VALUE OF EXPRESSION.  EQUAL TO THE       ***
2460 !***                OPTION BASE IN EFFECT.                   ***
2470 !*** IN           : RELATIVE ADDRESS A                       ***
2480 !***                INTEGER VALUE OF EXPRESSION              ***
2490 !***                                           <--- R12      ***
2500 !*** OUT          : LOWER BOUND OF ARRAY A                   ***
2510 !***                                           <--- R12      ***
2520 !***************************************************************
2530 !
2540          LST 
2550 LDIM2    CLB R70                !CLEAR FLAG.
2560          UNL 
2570          JMP UDIM+              !PUSH OPTION BASE ON STACK.
2580 !
2590 !****  UBND ATTRIBUTES TABLE  **********************************
2600          BYT 44,55              !ONE ARRAY, ONE NUMERIC
2610 !***************************************************************
2620 !*** UBND (A,EXP) : UPPER BOUND OF ARRAY SUBSCRIPT (1 OR 2)  ***
2630 !***                OF ARRAY A, SPECIFIED BY ROUNDED INTEGER ***
2640 !***                VALUE OF EXPRESSION.                     ***
2650 !*** IN           : RELATIVE ADDRESS A                       ***
2660 !***                INTEGER VALUE OF EXPRESSION              ***
2670 !***                                           <--- R12      ***
2680 !*** OUT          : UPPER BOUND OF ARRAY A                   ***
2690 !***                                           <--- R12      ***
2700 !***************************************************************
2710 !
2720          LST 
2730 UDIM2    CLB R70                !CLEAR FLAG .
2740          UNL 
2750          ICB R70                !FLAG SAYING CALC UDIM.
2760 UDIM+    JSB =ONEB              !GET INTEGER N.
2770          PUMD R46,+R6           !SAVE ANSWER FROM LOCSZ
2780          JSB =LOCSZ2            !GET UPPER DIMS & OPTION BASE.
2790          POMD R46,-R6           !RESTORE ANSWER
2800          TSB R70                !UDIM OR LDIM?
2810          JNZ NOTLDM             !JIF NOT LDIM.
2820          CLM R22                !1 IN R22-ADDS TO OPT BASE.
2830          ICM R22                !THIS 1 GETS DECR OUT AT UDIM17.
2840          STM R22,R24            !SAME FOR R24.
2850 NOTLDM   TSM R46                !N=1 OR 2?
2860          JNG UDIM22             !JIF NEG; INPUT ERROR.
2870          DCM R#                 !N=1?
2880          JNZ UDIM16             !JIF N#1.
2890          ADM R36,R22            !ELSE ADD COL SIZE TO OPT BASE.
2900          JMP UDIM17             !GO DECR & PUSH ANS ON STACK.
2910 UDIM16   DCM R#                 !N=2?
2920          JNZ UDIM22             !JIF N#2; ERROR.
2930          JEN UDIM22             !ERROR IF A VECTOR.
2940          ADM R36,R24            !ELSE ADD ROW SIZE TO OPT BASE.
2950 UDIM17   DCM R#                 !ADJUST ANSWER.
2960 UDIM20   JSB =CONBIN            !BINARY INT TO BCD INT.
2970          PUMD R40,+R12          !PUSH ANSWER ONTO STACK.
2980          RTN 
2990 UDIM22   BSZ 0                  !ERROR EXIT
3000          JSB =ERROR   
3010          BYT 89D
3020 !
3030 !********************************************************
3040 !*** ERROR+ : SETS ERRROM WITH ROM NUMBER IF NO OTHER ***
3050 !***          ERRORS ARE FLAGGED.                     ***
3060 !********************************************************
3070 !
3080 ERROR+   BSZ 0
3090          CLB R36
3100          CMBD R36,=ERRORS       !ERROR FLAG ALREADY SET
3110          JNZ DOERR+             !IF (NO OTHER ERRORS FLAGGED)
3120          LDB R36,=260           !   SELECT MATRIX ROM
3130          STBD R36,=ERRROM       !   FLAG ERROR
3140 DOERR+   BSZ 0                  !END IF
3150          RTN 
3160 !
3170 !******************************
3180 !***   EXTERNAL LABEL TABLE ***
3190 !******************************
3200 !
3210          LST 
3220 TMP1+    DAD 104465             !3 BYTES PAST TMP1
3230 TMP2+    DAD 104475             !3 BYTES PAST TMP2
3240 TMP3++   DAD 104507             !5 BYTES PAST TMP3
3250 FTR61    DAD 55514
3260 LINEAL   DAD 43420              !ALLOCATE LINE NUMBER
3270 !        ------------
3280 !        --- ROM1 ---
3290 !        ------------
3300 CKTRC    DAD 66312              !CHECK TRACE
3310 MPYR70   DAD 70141              !MULTIPLICATION
3320 NXTB     DAD 70341              !NEXT ELEMENT OF ARRAY 'B'
3330 NXTA     DAD 70361              !NEXT ELEMENT OF ARRAY 'A'
3340 NXTELE   DAD 70401              !NEXT ELEMENT OF ARRAY
3350 DOTPRD   DAD 70715              !DOT PRODUCT
3360 RONF5-   DAD 70724              !ROUND ANSWER
3370 DOTACC   DAD 70755              !ACCUMULATE DOT PRODUCT
3380 RUNSUM   DAD 71040              !RUNNING SUM
3390 STOV--   DAD 71276              !STORE ELEMENT
3400 STOV     DAD 71301              !STORE ELEMENT
3410 FETCH-   DAD 71426              !FETCH ELEMENT
3420 C=AORB   DAD 73704              !TEST BASE ADDR -- A,B,C
3430 COPYAB   DAD 74007              !COPY ARRAY A OR B
3440 ACOLEL   DAD 74113              !NEXT COL ELE OF 'A' TYPE ARRAY
3450 MNMUL    DAD 74365              !MULTILICATION
3460 LOCSZ-   DAD 74406              !LOCATE 'C' TYPE MATRIX
3461 VECFLG   DAD 74413              !SET VECTOR MATRIX FLAG
3470 LOCSZI   DAD 74426              !LOCATE 'B' TYPE MATRIX
3471 LOCSZ    DAD 74432              !LOCATE 'A' TYPE MATRIX
3472 COMRC-   DAD 74702              !
3473 GELT     DAD 74745              !GET ELEMENT
3474 REDIM.   DAD 77023              !REDIMENSION
3480 PUTREG   DAD 77520              !SAVE REGISTERS
3490 GETREG   DAD 77553              !GET REGISTERS
3500          FIN 
