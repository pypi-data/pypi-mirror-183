# This is for compatability issues to make sure the agent would know how to parse the communication with it
import traceback
from abc import ABCMeta, abstractmethod

SDK_VERSION = '0.0.0'

from xmlrpc.server import SimpleXMLRPCServer

import xmlrpc.client


class Detector(metaclass=ABCMeta):
    def __init__(self):
        pass

    @abstractmethod
    def start(self):
        pass

    @abstractmethod
    def stop(self):
        pass

    @abstractmethod
    def request_detection(self):
        """
        this should make the detector do a detection iteration asap, may be not relevant for some detector,
        but maybe useful for detectors that are polling in a fixed rate for example
        """
        pass

    def on_detection(self, detection):
        """
        Call this method when you have a detection to be sent to Testape
        :param detection:
        :return:
        """
        self.subject.next(detection)


class InputDetector(Detector):
    pass


class StateDetector(Detector):

    @abstractmethod
    def get_detection_keys(self):
        pass


class Adapter:

    @abstractmethod
    def replay_event(self, event):
        """
        replay a event, which can be either one of :
        1. an event that was previously generated by some detector of this adapter
        2. a command supported by this adapter
        :param detection:
        :return:
        """
        pass

    @abstractmethod
    def source_timestamp(self):
        """
        :return:  the current timestap from what we adapt to, as accurate as you can get
        """
        pass

    @abstractmethod
    def about(self):
        """
        :return:  a dict with data about what we adapt to, for example in the Android adapters we return stuff like Android SDK level, device model and manufacturer etc.
        use a field with key "name" to give the adapter a name that will be shown in the control panel for this adapter instance.
        """
        pass

    @abstractmethod
    def adapter_type(self):
        """
        may be relevant in cases where adapters are of same type yet can have multiple instances,
        the typing can be used to let user configure adapters by types instead of on the specific adapter level.
        for example:
        adb_adpater type has instance for each Android device
        :return:
        """
        pass

    @abstractmethod
    def unique_id(self):
        """
        a unique id that will identify this specific adapter instance
        :return:
        """
        pass

    @abstractmethod
    def available_commands(self):
        """
        array of dicts, each representing a command that should be available for the users to add from the control panel.
        each command should have id, title and optionally list of params where each has a title,key and type.
        for example :
        [
            {
                'id': 'adb_clear_app_storage',
                'title': "Clear App Storage",
                'params': [{
                    'title': "Package Name",
                    'key': 'package',
                    'type': 'string'
                }]
            },
            {
                'id': 'adb_open_app',
                'title': "Open App by Package",
                'params': [{
                    'title': "Package Name",
                    'key': 'package',
                    'type': 'string'
                }]
            },
            {
                'id': 'adb_force_stop_app',
                'title': "Force Stop App by Package",
                'params': [{
                    'title': "Package Name",
                    'key': 'package',
                    'type': 'string'
                }]
            }
        ]
        :return:
        """
        pass

    @abstractmethod
    def destroy(self):
        """
        Called when this adapter is no longer used by the user and needs to shut down and destroy itself
        :return: 
        """
        pass


class CommandExecutor:

    @abstractmethod
    def replay_event(self, event):
        """
        replay a event, which can be either one of :
        1. an event that was previously generated by some detector of this adapter
        2. a command supported by this adapter
        :param detection:
        :return:
        """
        pass

    @abstractmethod
    def adapter_type(self):
        """
        may be relevant in cases where adapters are of same type yet can have multiple instances,
        the typing can be used to let user configure adapters by types instead of on the specific adapter level.
        for example:
        adb_adpater type has instance for each Android device
        :return:
        """
        pass

    def available_commands(self):
        """
        array of dicts, each representing a command that should be available for the users to add from the control panel.
        each command should have id, title and optionally list of params where each has a title,key and type.
        for example :
        [
            {
                'id': 'adb_clear_app_storage',
                'title': "Clear App Storage",
                'params': [{
                    'title': "Package Name",
                    'key': 'package',
                    'type': 'string'
                }]
            },
            {
                'id': 'adb_open_app',
                'title': "Open App by Package",
                'params': [{
                    'title': "Package Name",
                    'key': 'package',
                    'type': 'string'
                }]
            },
            {
                'id': 'adb_force_stop_app',
                'title': "Force Stop App by Package",
                'params': [{
                    'title': "Package Name",
                    'key': 'package',
                    'type': 'string'
                }]
            }
        ]
        :return:
        """
        pass


class AgentConnection(metaclass=ABCMeta):

    def __init__(self, agent):
        self.agent = agent

    def add_adapter(self, adapter: Adapter):

        my_port, agent_port = self.agent.allocate_ports_for_new_adapter(adapter.unique_id())
        if my_port is None or agent_port is None:
            raise Exception(f"Couldnt allocate ports for adapter {adapter}")
        server = SimpleXMLRPCServer(("localhost", my_port))
        for name, method in Adapter.__dict__.items():
            if callable(method):
                server.register_function(method, name)
        server.serve_forever()

    def add_detector(self, detector: Detector, adapter_unique_id: str):

        my_port, agent_port = self.agent.allocate_ports_for_new_detector(adapter_unique_id)
        if my_port is None or agent_port is None:
            raise Exception(f"Couldnt allocate ports for detector {detector} in adapter {adapter_unique_id}")

        with xmlrpc.client.ServerProxy(f"http://localhost:{agent_port}/") as agent_detector:
            detector.subject.subscribe(lambda d, agent=agent_detector: agent.on_detection(d))
            server = SimpleXMLRPCServer(("localhost", my_port))
            for name, method in Detector.__dict__.items():
                if name != "on_detection" and callable(method):
                    server.register_function(method, name)
            server.serve_forever()


def connect(testape_api_key, agent_url='http://localhost') -> AgentConnection:
    with xmlrpc.client.ServerProxy(f"{agent_url}:8000/") as agent:
        error = agent.validate_sdk(SDK_VERSION, testape_api_key)
        if type(error) == str:
            raise Exception(error)
        return AgentConnection(agent)

    raise Exception("Couldnt create agent connection")
