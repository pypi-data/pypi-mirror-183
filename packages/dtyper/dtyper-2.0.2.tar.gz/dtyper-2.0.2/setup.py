# -*- coding: utf-8 -*-
from setuptools import setup

modules = \
['dtyper']
install_requires = \
['typer']

setup_kwargs = {
    'name': 'dtyper',
    'version': '2.0.2',
    'description': '⌨️dtyper: Call typer commands or make dataclasses from them ⌨',
    'long_description': '# ⌨️dtyper:  a tiny library to improve `typer` ⌨️\n\n## What is `dtyper`?\n\n`typer` is a famously clear and useful system for writing Python CLIs but it has\ntwo issues that people seem to run into a lot:\n\n1. You can\'t call the `typer.command` functions it creates directly because they\nhave the wrong defaults.\n\n2. As you add more arguments to your CLI, there is no easy way to break up the\ncode sitting in one file without passing around long, verbose parameter lists.\n\n`dtyper` is a single-file library that adds to an existing installation of\n`typer` that solves these two problems without changing existing code at all.\n\n* `dtyper.function` decorates a `typer.command` to make it callable.\n\n* `dtyper.dataclass` automatically makes a `dataclass` from\na `typer.command`.\n\n## How to use `dtyper`?\n\nInstall as usual with `poetry add dtyper`, `pip install dtyper`, or your\nfavorite package manager.\n\n`dtyper` is a drop-in replacement for `typer` - it copies all `typer`s\nproperties - so you can even write\n\n    import dtyper as typer\n\nto experiment with it before deciding.\n\n`dtyper` has two new functions that `typer` doesn\'t, and overrides a `typer`\nclass:\n\n* `@dtyper.function` is a decorator that takes a `typer` command and returns\n  a callable function with the correct defaults.  It is unncessary if you use\n  `dtyper.Typer` (below)\n\n* `@dtyper.dataclass` is a decorator that takes an existing `typer` or `dtyper`\ncommand and makes a `dataclass` from it.\n\n* `dtyper.Typer`is a class identical to `typer.Typer`, except it fixes\n  `Typer.command` functions so you can call them directly.\n\nNone of the `typer` functionality is changed to the slightest degree - adding\n`dtyper` will not affect how your command line program runs at all.\n\n## Examples\n\nAll the examples will assume this block of code exists somewhere:\n\n    from typer import Typer\n\n    app = Typer()\n    command = app.command\n\n### Example: using `dtyper.function`\n\nVery little to type, it fixes the problem:\n\n    import dtyper\n\n\n    @dtyper.function  #  <--- add this one line\n    @command(help=\'test\')\n    def get_keys(\n        bucket: str = Argument(\n            \'buck, help=\'The bucket to use\'\n        ),\n\n        keys: bool = Option(\n            False, help=\'The keys to download\'\n        ),\n    ):\n        print(bucket, keys)\n\n\n    # Elsewhere in the code\n\n    get_keys()  # correctly prints \'buck False\'\n\n### Example: a simple `dtyper.dataclass`\n\nHere\'s a simple CLI in one Python file with two arguments `bucket`, `keys` and\none option `pid`:\n\n    @command(help=\'test\')\n    def get_keys(\n        bucket: str = Argument(\n            ..., help=\'The bucket to use\'\n        ),\n\n        keys: str = Argument(\n            \'keys\', help=\'The keys to download\'\n        ),\n\n        pid: Optional[int] = Option(\n            None, \'--pid\', \'-p\', help=\'process id, or None for this process\'\n        ),\n    ):\n        get_keys = GetKeys(**locals())\n        print(get_keys.run())\n\n\n    @dtyper.dataclass(get_keys)\n    class GetKeys:\n        site = \'https://www.some-websijt.nl\'\n\n        def run(self):\n            return self.url, self.keys, self.pid\n\n        def __post_init__(self):\n            self.pid = self.pid or os.getpid()\n\n        def url(self):\n           return f\'{self.site}/{self.url}/{self.pid}\'\n\n\n### Example: splitting a large `typer.command` into multiple files\n\nReal world CLIs frequently have dozens if not hundreds of commands, with\nhundreds if not thousands of options, arguments, settings or command line flags.\n\nThe natural structure for this is the "big ball of mud", a popular\nanti-pattern known to cause misery and suffering to maintainers.\n\n`dtyper.dataclass` can split the user-facing definition of the API from its\nimplementation and then split that implementation over multiple files in a\nnatural and convenient way.\n\nThe example has three Python files.\n\n`interface.py` contains the Typer CLI definitions for this command.\n\n    @command(help=\'test\')\n    def big_calc(\n        bucket: str = Argument(\n            ..., help=\'The bucket to use\'\n        ),\n        more: str = Argument(\n            \'\', help=\'More information\'\n        ),\n        enable_something: boolean = Option(\n            False, help=\'Turn on one of many important parameters\'\n        ),\n        # [dozens of parameters here]\n    ):\n        d = dict(locals())  # Capture all the command line arguments as a dict\n\n        from .big_calc import BigCalc  # Lazy import to avoid a cycle\n\n        bc = BigCalc(**d)\n        bc.run()\n\n\n`big_calc.py` contains the `dtyper.dataclass` implementation\n\n    from .interface import big_calc\n    from . import helper\n    import dtyper\n\n\n    @dtyper.dataclass(big_calc)\n    class BigCalc:\n        def run(self):\n           # Each argument in `big_calc` becomes a dataclass field\n           print(self.bucket, self.more)\n           print(self)  # dataclass gives you a nice output of all fields\n\n           if helper.huge_thing(self) and self._etc():\n              self.stuff()\n              helper.more_stuff(self)\n              ...\n\n        def _etc(self):\n           ...\n           # Dozens more methods here perhaps!\n\nSome of the code is offloaded to helper files like `helper.py`:\n\n    def huge_thing(big_calc):\n        if has_hole(big_calc.bucket):\n           fix_it(big_calc.bucket, big_calc.more)\n\n    def more_stuff(big_calc):\n        # even more code\n',
    'author': 'Tom Ritchford',
    'author_email': 'tom@swirly.com',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'https://github.com/rec/dtyper',
    'py_modules': modules,
    'install_requires': install_requires,
    'python_requires': '>=3.7',
}


setup(**setup_kwargs)
